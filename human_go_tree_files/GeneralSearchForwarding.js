(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/* 
 * The framework to hang the rest of the amigo2 package internals on.
 *
 * @module: amigo2
 */

var us = require('underscore');
var bbop = require('bbop-core');

/**
 * "Constructor" for amigo2.
 * 
 * Parameters:
 *  more_dispatch - addition to or override of default dispatch table
 *
 * @constructor 
 * @returns {Object} amigo2 object
 */
var amigo = function amigo(more_dispatch) {
  this._is_a = 'amigo2-instance-data';
  var anchor = this;

  // // The (TODO: now unused?) API lib.
  // this.api = require('./api');

  // // TODO: No longer necessary w/NPM switch.
  // this.version = require('./version');

  // // TODO: Not entirely sure what this was doing anyways.
  //this.data.statistics = require('./data/statistics');

  ///
  /// Dealing with access to the "statically" created instance data.
  ///

  // .data subsection.
  this.data = {};
  // Objects.
  this.data.context = require('./data/context');
  this.data.definitions = require('./data/definitions');
  this.data.golr = require('./data/golr');
  this.data.xrefs = require('./data/xrefs');
  this.data.server = require('./data/server');

  ///
  /// Externalized functions built on our data base.
  ///

  // Does it look like a term?
  var meta_data = this.data.server.meta_data;
  var tre_str = meta_data.term_regexp;
  var tre = new RegExp(tre_str); // compile upfront

  // Construct a one-time map of aliases to canonical IDs.
  var alias_map = {};
  if (anchor.data && anchor.data.context) {
    us.each(anchor.data.context, function (context_data, context_id) {
      if (context_data.aliases) {
        us.each(context_data.aliases, function (alias) {
          alias_map[alias] = context_id;
        });
      }
    });
  }

  /*
   * Function: term_id_p
   * 
   * True or false on whether or not a string looks like a GO term id.
   * 
   * Parameters:
   *  term_id - the string to test
   * 
   * Returns:
   *  boolean
   */
  this.term_id_p = function (term_id) {
    var retval = false;
    if (tre.test(term_id)) {
      retval = true;
    }
    return retval;
  };

  /*
   * Function: get_image_resource
   * 
   * Get a named resource from the meta_data hash if possible.
   * 
   * Parameters:
   *  resource - the string id of the resource
   * 
   * Returns:
   * string (url) of resource
   */
  this.get_image_resource = function (resource) {
    var retval = null;
    var mangled_res = 'bbop_img_' + resource;
    if (meta_data[mangled_res]) {
      retval = meta_data[mangled_res];
    }
    return retval;
  };

  ///
  /// Function/object generators.
  ///

  // Generate the linker from the internal xrefs and server refs.
  var linker_gen = require('./linker');
  this.linker = new linker_gen(this.data.xrefs, this.data.server);

  // Need the to feed the linker into the dispatch table generator.
  var dispatch_gen = require('./data/dispatch');
  anchor.data.dispatch = dispatch_gen(anchor.linker);
  // Allow override of dispatch table with arguments into AmiGO at
  // instantiation time.
  if (us.isObject(more_dispatch)) {
    us.each(more_dispatch, function (contexts, field_name) {
      // Make sure we start with a nice something here.
      if (!us.isObject(anchor.data.dispatch[field_name])) {
        anchor.data.dispatch[field_name] = {};
      }

      // Add any default functions (if no context is provided).
      if (us.isFunction(contexts["default"])) {
        anchor.data.dispatch[field_name]['default'] = contexts["default"];
      }

      // Add additional context information.
      if (contexts.context) {
        // double check the jump
        us.each(contexts.context, function (run_fun, context) {
          // Now merge the structure in if it fits.
          if (us.isFunction(run_fun) && us.isString(context) && us.isString(field_name)) {
            if (!us.isObject(anchor.data.dispatch[field_name]) || !us.isObject(anchor.data.dispatch[field_name]['context'])) {
              anchor.data.dispatch[field_name]['context'] = {};
            }
            // Write into the final form.
            anchor.data.dispatch[field_name]['context'][context] = run_fun;
          }
        });
      }
    });
  }

  // Use this nice dispatch table as the argument to the handler.
  var handler_gen = require('./handler');
  this.handler = new handler_gen(this.data.dispatch);

  // .ui subsection.
  //    this.ui = {};

  /*
   * Function: dealias
   * 
   * Attempt to convert an incoming ID into the canonical ID used
   * for the context.
   * 
   * Parameters:
   *  map_id - the string id of the entity
   * 
   * Returns:
   *  string (true id) or null
   */
  this.dealias = function (map_id) {
    var retval = null;
    if (alias_map[map_id]) {
      retval = alias_map[map_id];
    }
    return retval;
  };

  /*
   * Function: readable
   * 
   * Get readable label for the entity, if it can be found in the
   * context.
   * 
   * Parameters:
   *  id - the string id of the entity
   * 
   * Returns:
   *  string label, or incoming id if not found
   */
  this.readable = function (id) {
    if (this.dealias(id)) {
      id = this.dealias(id);
    }
    var retval = id;
    if (anchor.data && anchor.data.context && anchor.data.context[id]) {
      var entry = anchor.data.context[id];
      if (entry['readable']) {
        retval = entry['readable'];
      }
    }
    return retval;
  };

  /*
   * Function: color
   * 
   * Get color string for the entity, if it can be found in the
   * context.
   * 
   * Parameters:
   *  id - the string id of the entity
   * 
   * Returns:
   *  string label, or "#888888" if not found
   */
  this.color = function (id) {
    if (this.dealias(id)) {
      id = this.dealias(id);
    }
    var retval = '#888888';
    if (anchor.data && anchor.data.context && anchor.data.context[id]) {
      var entry = anchor.data.context[id];
      if (entry['color']) {
        retval = entry['color'];
      }
    }
    return retval;
  };
};

///
/// Exportable body.
///

module.exports = amigo;

},{"./data/context":2,"./data/definitions":3,"./data/dispatch":4,"./data/golr":5,"./data/server":6,"./data/xrefs":7,"./handler":8,"./linker":9,"bbop-core":10,"underscore":11}],2:[function(require,module,exports){
/*
 * Package: context.js
 *
 * Namespace: amigo.data.context
 *
 * Another context.
 */

/*
 * Variable: context
 *
 * Manually added in from conf/context.yaml.
 */
var data_context = {
  "instance_of": {
    "readable": "instance of",
    "priority": 8,
    "aliases": ["instance of"],
    "color": "#FFFAFA"
  },
  "is_a": {
    "readable": "is a",
    "aliases": ["is a"],
    "color": "#000000"
  },
  "BFO:0000050": {
    "readable": "part of",
    "priority": 15,
    "aliases": ["http://purl.obolibrary.org/obo/BFO_0000050", "http://purl.obolibrary.org/obo/part_of", "BFO_0000050", "part:of", "part of", "part_of"],
    "color": "#add8e6"
  },
  "BFO:0000051": {
    "readable": "has part",
    "priority": 4,
    "aliases": ["http://purl.obolibrary.org/obo/BFO_0000051", "has:part", "has part", "has_part"],
    "color": "#6495ED"
  },
  "BFO:0000066": {
    "readable": "occurs in",
    "priority": 12,
    "aliases": ["http://purl.obolibrary.org/obo/BFO_0000066", "BFO_0000066", "occurs:in", "occurs in", "occurs_in"],
    "color": "#66CDAA"
  },
  "RO:0002202": {
    "readable": "develops from",
    "priority": 0,
    "aliases": ["develops:from", "develops from", "develops_from"],
    "color": "#A52A2A"
  },
  "RO:0002211": {
    "readable": "regulates",
    "priority": 16,
    "aliases": ["http://purl.obolibrary.org/obo/RO_0002211", "regulates"],
    "color": "#2F4F4F"
  },
  "RO:0002212": {
    "readable": "negatively regulates",
    "priority": 16,
    "aliases": ["http://purl.obolibrary.org/obo/RO_0002212", "negatively:regulates", "negatively regulates", "negatively_regulates"],
    "glyph": "bar",
    "color": "#FF0000"
  },
  "RO:0002630": {
    "readable": "directly negatively regulates",
    "priority": 15,
    "aliases": ["http://purl.obolibrary.org/obo/RO_0002630", "directly:negatively:regulates", "directly negatively regulates", "directly_negatively_regulates"],
    "glyph": "bar",
    "color": "#FF0000"
  },
  "RO:0002213": {
    "readable": "positively regulates",
    "priority": 18,
    "aliases": ["http://purl.obolibrary.org/obo/RO_0002213", "positively:regulates", "positively regulates", "positively_regulates"],
    "glyph": "arrow",
    "color": "#008000"
  },
  "RO:0002629": {
    "readable": "directly positively regulates",
    "priority": 17,
    "aliases": ["http://purl.obolibrary.org/obo/RO_0002629", "directly:positively:regulates", "directly positively regulates", "directly_positively_regulates"],
    "glyph": "arrow",
    "color": "#008000"
  },
  "RO:0002233": {
    "readable": "has input",
    "priority": 14,
    "aliases": ["has:input", "has input", "has_input"],
    "color": "#6495ED"
  },
  "RO:0002234": {
    "readable": "has output",
    "priority": 0,
    "aliases": ["has:output", "has output", "has_output"],
    "color": "#ED6495"
  },
  "RO:0002330": {
    "readable": "genomically related to",
    "priority": 0,
    "aliases": ["genomically related to", "genomically_related_to"],
    "color": "#9932CC"
  },
  "RO:0002331": {
    "readable": "involved in",
    "priority": 3,
    "aliases": ["involved:in", "involved in", "involved_in"],
    "color": "#E9967A"
  },
  "RO:0002332": {
    "readable": "regulates level of",
    "priority": 0,
    "aliases": ["regulates level of", "regulates_level_of"],
    "color": "#556B2F"
  },
  "RO:0002333": {
    "readable": "enabled by",
    "priority": 13,
    "aliases": ["RO_0002333", "enabled:by", "enabled by", "enabled_by"],
    "color": "#B8860B"
  },
  "RO:0002334": {
    "readable": "regulated by",
    "priority": 0,
    "aliases": ["RO_0002334", "regulated by", "regulated_by"],
    "color": "#86B80B"
  },
  "RO:0002335": {
    "readable": "negatively regulated by",
    "priority": 0,
    "aliases": ["RO_0002335", "negatively regulated by", "negatively_regulated_by"],
    "color": "#0B86BB"
  },
  "RO:0002336": {
    "readable": "positively regulated by",
    "priority": 0,
    "aliases": ["RO_0002336", "positively regulated by", "positively_regulated_by"],
    "color": "#BB0B86"
  },
  "activates": {
    "readable": "activates",
    "priority": 0,
    "aliases": ["http://purl.obolibrary.org/obo/activates"],
    "color": "#8FBC8F"
  },
  "RO:0002404": {
    "readable": "causally downstream of",
    "priority": 2,
    "aliases": ["causally_downstream_of"],
    "color": "#FF1493"
  },
  "RO:0002406": {
    "readable": "directly activates",
    "priority": 2,
    "aliases": ["http://purl.obolibrary.org/obo/directly_activates", "directly:activates", "directly activates", "directly_activates"],
    "glyph": "arrow",
    "color": "#008000"
  },
  "RO:0002407": {
    "readable": "indirectly positively regulates",
    "priority": 1,
    "aliases": ["http://purl.obolibrary.org/obo/indirectly_activates", "indirectly:activates", "indirectly activates", "indirectly_activates"],
    "glyph": "arrow",
    "color": "#008000"
  },
  "upstream_of": {
    "readable": "upstream of",
    "priority": 2,
    "aliases": ["http://purl.obolibrary.org/obo/upstream_of", "upstream:of", "upstream of", "upstream_of"],
    "color": "#FF1493"
  },
  "RO:0002408": {
    "readable": "directly inhibits",
    "priority": 2,
    "aliases": ["http://purl.obolibrary.org/obo/directly_inhibits", "directly:inhibits", "directly inhibits", "directly_inhibits"],
    "glyph": "bar",
    "color": "#FF0000"
  },
  "RO:0002409": {
    "readable": "indirectly negatively regulates",
    "priority": 1,
    "aliases": ["http://purl.obolibrary.org/obo/indirectly_inhibits", "indirectly:inhibits", "indirectly inhibits", "indirectly_inhibits"],
    "glyph": "bar",
    "color": "#FF0000"
  },
  "RO:0002411": {
    "readable": "causally upstream of",
    "priority": 2,
    "aliases": ["causally_upstream_of"],
    "color": "#483D8B"
  },
  "indirectly_disables_action_of": {
    "readable": "indirectly disables action of",
    "priority": 0,
    "aliases": ["http://purl.obolibrary.org/obo/indirectly_disables_action_of", "indirectly disables action of", "indirectly_disables_action_of"],
    "color": "#483D8B"
  },
  "provides_input_for": {
    "readable": "provides input for",
    "priority": 0,
    "aliases": ["GOREL_provides_input_for", "http://purl.obolibrary.org/obo/GOREL_provides_input_for"],
    "color": "#483D8B"
  },
  "RO:0002413": {
    "readable": "directly provides input for",
    "priority": 1,
    "aliases": ["directly_provides_input_for", "GOREL_directly_provides_input_for", "http://purl.obolibrary.org/obo/GOREL_directly_provides_input_for"],
    "glyph": "diamond",
    "color": "#483D8B"
  },
  "subclass_of": {
    "readable": "subclass of",
    "priority": 100,
    "aliases": ["SUBCLASS_OF"],
    "glyph": "diamond",
    "color": "#E9967A"
  },
  "superclass_of": {
    "readable": "superclass of",
    "priority": 100,
    "aliases": ["SUPERCLASS_OF"],
    "glyph": "diamond",
    "color": "#556B2F"
  },
  "annotation": {
    "readable": "annotation",
    "priority": 100,
    "aliases": ["ANNOTATION"],
    "glyph": "diamond",
    "color": "#483D8B"
  },
  "RO:0002215": {
    "readable": "capable of",
    "priority": 9,
    "aliases": ["capable_of", "capable of"],
    "glyph": "diamond",
    "color": "#483D8B"
  },
  "RO:0002216": {
    "readable": "capable of part of",
    "priority": 8,
    "aliases": ["capable_of_part_of", "capable_of part_of", "capable of part of"],
    "glyph": "diamond",
    "color": "#483D8B"
  },
  "GO:0008150": {
    "readable": "biological process",
    "aliases": ["GO_0008150", "P", "biological_process"],
    "color": "#00ee76"
  },
  "GO:0005575": {
    "readable": "cellular component",
    "aliases": ["GO_0005575", "C", "cellular_component"],
    "color": "#a020f0"
  },
  "GO:0003674": {
    "readable": "molecular function",
    "aliases": ["GO_0003674", "F", "molecular_function"],
    "color": "#ffd700"
  }
};

///
/// Exportable body.
///

module.exports = data_context;

},{}],3:[function(require,module,exports){
/*
 * Package: definitions.js
 * 
 * Namespace: amigo.data.definitions
 * 
 * Purpose: Useful information about common GO datatypes and
 * structures, as well as some constants.
 */

/*
 * Constructor: definitions
 * 
 * Encapsulate common structures and constants.
 * 
 * Arguments:
 *  n/a
 */
var definitions = {
  /*
   * Function: gaf_from_golr_fields
   * 
   * A list of fields to generate a GAF from using golr fields.
   * 
   * Parameters:
   *  n/a
   * 
   * Returns:
   *  list of strings
   */
  gaf_from_golr_fields: ['source',
  // c1
  'bioentity_internal_id',
  // c2; not bioentity
  'bioentity_label',
  // c3
  'qualifier',
  // c4
  'annotation_class',
  // c5
  'reference',
  // c6
  'evidence_type',
  // c7
  'evidence_with',
  // c8
  'aspect',
  // c9
  'bioentity_name',
  // c10
  'synonym',
  // c11
  'type',
  // c12
  'taxon',
  // c13
  'date',
  // c14
  'assigned_by',
  // c15
  'annotation_extension_class',
  // c16
  'bioentity_isoform' // c17
  ],
  /*
   * Function: download_limit
   * 
   * The maximum allowed number of items to download for out server.
   * 
   * Parameters:
   *  n/a
   * 
   * Returns:
   *  integer
   */
  download_limit: 100000
};

///
/// Exportable body.
///

module.exports = definitions;

},{}],4:[function(require,module,exports){
/* 
 * Package: dispatch.js
 * 
 * Namespace: amigo.data.dispatch
 * 
 * This package was automatically created during an AmiGO 2 installation
 * from the YAML configuration files that AmiGO pulls in.
 *
 * The mapping file for data fields and contexts to functions, often
 * used for displays. See the package <handler.js> for the API to interact
 * with this data file.
 *
 * NOTE: This file is generated dynamically at installation time.
 * Hard to work with unit tests--hope it's not too bad. You have to
 * occasionally copy back to keep the unit tests sane.
 *
 * NOTE: This file has a slightly different latout from the YAML
 * configuration file.
 */

var us = require('underscore');
var bbop = require('bbop-core');
var linker = null;

/*
 * Function: echo
 * 
 * Applies bbop.dump to whatever comes in.
 * Static function handler for echoing inputs--really used for
 * teaching and testing.
 *
 * Parameters:
 *  thing
 * 
 * Returns:
 *  a string; it /will/ be a string
 * 
 * Also See: <bbop.handler>
 */
var echo = function echo(thing, name, context) {
  // Force a return string into existence.
  var retstr = null;
  try {
    retstr = bbop.dump(thing);
  } catch (x) {
    retstr = '';
  }

  // // Append any optional stuff.
  // if( is_def(name) && what_is(name) === 'string' ){
  // 	retstr += ' (' + name + ')';
  // }
  // if( is_def(context) && what_is(context) === 'string' ){
  // 	retstr += ' (' + context + ')';
  // }

  return retstr;
};

/*
 * Function: owl_class_expression
 *
 * Static function handler for displaying OWL class expression
 * results. To be used for GAF column 16 stuff.
 *
 * Example incoming data (as a string or object):
 * 
 * : { relationship: {
 * :     relation: [{id: "RO:001234", label: "regulates"},
 * :                {id:"BFO:0003456", label: "hp"}], 
 * :     id: "MGI:MGI:185963",
 * :     label: "kidney"
 * :   }
 * : }
 * 
 * Parameters:
 *  JSON object as *[string or object]*; see above
 * 
 * Returns:
 *  HTML string
 * 
 * Also See: <bbop.handler>
 */
var owl_class_expression = function owl_class_expression(in_owlo) {
  var retstr = "";

  // // Add logging.
  // var logger = new bbop.logger();
  // logger.DEBUG = true;
  // //logger.DEBUG = false;
  // function ll(str){ logger.kvetch(str); }

  var owlo = in_owlo;
  if (bbop.what_is(owlo) === 'string') {
    // This should be an unnecessary robustness check as
    // everything /should/ be a legit JSON string...but things
    // happen in testing. We'll check to make sure that it looks
    // like what it should be as well.
    if (in_owlo.charAt(0) === '{' && in_owlo.charAt(in_owlo.length - 1) === '}') {
      owlo = JSON.parse(in_owlo) || {};
    } else {
      // Looks like a normal string string.
      // Do nothing for now, but catch in the next section.
    }
  }

  // Check to make sure that it looks right.
  if (bbop.what_is(owlo) === 'string') {
    // Still a string means bad happened--we want to see that.
    retstr = owlo + '?';
  } else if (typeof owlo === 'undefined' || typeof owlo['relationship'] === 'undefined' || bbop.what_is(owlo['relationship']) !== 'object' || bbop.what_is(owlo['relationship']['relation']) !== 'array' || typeof owlo['relationship']['id'] === 'undefined' || typeof owlo['relationship']['label'] === 'undefined') {
    // 'Twas an error--ignore.
    //throw new Error('sproing!');
  } else {
    // Okay, right structure--first assemble the relationships,
    // then tag onto end.
    var rel_buff = [];
    us.each(owlo['relationship']['relation'], function (rel) {
      // Check to make sure that these are
      // structured correctly as well.
      var rel_id = rel['id'];
      var rel_lbl = rel['label'];
      if (typeof rel_id !== 'undefined' && typeof rel_lbl !== 'undefined') {
        var an = linker.anchor({
          id: rel_id,
          label: rel_lbl
        });
        // Final check: if we didn't get
        // anything reasonable, just a label.
        if (!an) {
          an = rel_lbl;
        }
        rel_buff.push(an);
        // ll('in ' + rel_id + ' + ' + rel_lbl + ': ' + an);
      }
    });
    var ranc = linker.anchor({
      id: owlo['relationship']['id'],
      label: owlo['relationship']['label']
    });
    // Again, a final check
    if (!ranc) {
      ranc = owlo['relationship']['label'];
    }
    retstr = rel_buff.join(' &rarr; ') + ' ' + ranc;
  }
  return retstr;
};

/*
 * Function: qualifiers
 * 
 * Essentially catch certain strings and hightlight them.
 * 
 * Example incoming data as string:
 * 
 * : "not"
 * 
 * Parameters:
 *  string or null
 * 
 * Returns:
 *  HTML string
 * 
 * Also See: <bbop.handler>
 */
var qualifiers = function qualifiers(in_qual) {
  var retstr = in_qual;
  if (typeof in_qual !== 'undefined') {
    if (bbop.what_is(in_qual) === 'string') {
      if (in_qual === 'not' || in_qual === 'NOT') {
        retstr = '<span class="qualifier-not">NOT</span>';
      }
    }
  }
  return retstr;
};

/*
 * Function: alternate_id
 * 
 * Essentially do /nothing/ to alternate ids--ignore them.
 * 
 * Parameters:
 *  string or null
 * 
 * Returns:
 *  same
 * 
 * Also See: <bbop.handler>
 */
var alternate_id = function alternate_id(id) {
  var retstr = id;
  return retstr;
};

/*
 * Variable: dispatch
 * 
 * The configuration for the data.
 * Essentially a JSONification of the YAML file.
 * This should be consumed directly by <amigo.handler>.
 */
var dispatch_table = {
  "example_field": {
    "context": {
      "example_context": echo
    }
  },
  "annotation_extension_json": {
    "context": {
      "bbop-widget-set.live_results": owl_class_expression
    }
  },
  "qualifier": {
    "context": {
      "bbop-widget-set.live_results": qualifiers
    }
  },
  "alternate_id": {
    "context": {
      "bbop-widget-set.live_results": alternate_id
    }
  }
};
var dispatch_table_generator = function dispatch_table_generator(required_linker) {
  linker = required_linker;
  return dispatch_table;
};

///
/// Exportable body.
///

module.exports = dispatch_table_generator;

},{"bbop-core":10,"underscore":11}],5:[function(require,module,exports){
/* 
 * Package: golr.js
 * 
 * Namespace: amigo.data.golr
 * 
 * This package was automatically created during an AmiGO 2 installation
 * from the YAML configuration files that AmiGO pulls in.
 *
 * Useful information about GOlr. See the package <golr_conf.js>
 * for the API to interact with this data file.
 *
 * NOTE: This file is generated dynamically at installation time.
 * Hard to work with unit tests--hope it's not too bad. You have to
 * occasionally copy back to keep the unit tests sane.
 *
 * NOTE: This file has a slightly different latout from the YAML
 * configurations files--in addition instead of the fields
 * being in lists (fields), they are in hashes keyed by the
 * field id (fields_hash).
 */

/*
 * Variable: golr
 * 
 * The configuration for the data.
 * Essentially a JSONification of the OWLTools YAML files.
 * This should be consumed directly by <bbop.golr.conf>.
 */
var golr = {
  "bbop_ann_ev_agg": {
    "_strict": 0,
    "filter_weights": "evidence_type_closure^4.0 evidence_with^3.0 taxon_closure_label^2.0",
    "_outfile": "/home/bbop/local/src/git/amigo/metadata/ann_ev_agg-config.yaml",
    "description": "A description of annotation evidence aggregate for GOlr and AmiGO.",
    "weight": "-10",
    "result_weights": "bioentity^4.0 annotation_class^3.0 taxon^2.0",
    "display_name": "Advanced",
    "id": "bbop_ann_ev_agg",
    "schema_generating": "true",
    "_infile": "/home/bbop/local/src/git/amigo/metadata/ann_ev_agg-config.yaml",
    "searchable_extension": "_searchable",
    "boost_weights": "annotation_class^2.0 annotation_class_label^1.0 bioentity^2.0 bioentity_label^1.0 panther_family^1.0 panther_family_label^1.0 taxon_closure_label^1.0",
    "document_category": "annotation_evidence_aggregate",
    "fields": [{
      "searchable": "false",
      "cardinality": "single",
      "indexed": "true",
      "type": "string",
      "property": [],
      "transform": [],
      "required": "false",
      "id": "id",
      "display_name": "Acc",
      "description": "Gene/product ID."
    }, {
      "searchable": "false",
      "cardinality": "single",
      "type": "string",
      "indexed": "true",
      "transform": [],
      "property": [],
      "required": "false",
      "description": "Column 1 + columns 2.",
      "display_name": "Gene/product ID",
      "id": "bioentity"
    }, {
      "searchable": "true",
      "cardinality": "single",
      "indexed": "true",
      "type": "string",
      "property": [],
      "transform": [],
      "required": "false",
      "description": "Column 3.",
      "id": "bioentity_label",
      "display_name": "Gene/product label"
    }, {
      "type": "string",
      "indexed": "true",
      "property": [],
      "transform": [],
      "searchable": "false",
      "cardinality": "single",
      "description": "Column 5.",
      "id": "annotation_class",
      "display_name": "Annotation class",
      "required": "false"
    }, {
      "type": "string",
      "indexed": "true",
      "property": [],
      "transform": [],
      "searchable": "true",
      "cardinality": "single",
      "description": "Column 5 + ontology.",
      "display_name": "Annotation class label",
      "id": "annotation_class_label",
      "required": "false"
    }, {
      "indexed": "true",
      "type": "string",
      "transform": [],
      "property": [],
      "searchable": "false",
      "cardinality": "multi",
      "description": "All evidence for this term/gene product pair",
      "id": "evidence_type_closure",
      "display_name": "Evidence type",
      "required": "false"
    }, {
      "id": "evidence_with",
      "display_name": "Evidence with",
      "description": "All column 8s for this term/gene product pair",
      "required": "false",
      "transform": [],
      "property": [],
      "type": "string",
      "indexed": "true",
      "cardinality": "multi",
      "searchable": "false"
    }, {
      "searchable": "false",
      "cardinality": "single",
      "type": "string",
      "indexed": "true",
      "transform": [],
      "property": [],
      "required": "false",
      "description": "Column 13: taxon.",
      "id": "taxon",
      "display_name": "Taxon"
    }, {
      "cardinality": "single",
      "searchable": "true",
      "property": [],
      "transform": [],
      "indexed": "true",
      "type": "string",
      "required": "false",
      "description": "Derived from C13 + ncbi_taxonomy.obo.",
      "display_name": "Taxon",
      "id": "taxon_label"
    }, {
      "display_name": "Taxon (IDs)",
      "id": "taxon_closure",
      "description": "IDs derived from C13 + ncbi_taxonomy.obo.",
      "required": "false",
      "transform": [],
      "property": [],
      "type": "string",
      "indexed": "true",
      "cardinality": "multi",
      "searchable": "false"
    }, {
      "transform": [],
      "property": [],
      "type": "string",
      "indexed": "true",
      "cardinality": "multi",
      "searchable": "true",
      "description": "Labels derived from C13 + ncbi_taxonomy.obo.",
      "display_name": "Taxon",
      "id": "taxon_closure_label",
      "required": "false"
    }, {
      "id": "panther_family",
      "display_name": "Protein family",
      "description": "Family IDs that are associated with this entity.",
      "required": "false",
      "indexed": "true",
      "type": "string",
      "property": [],
      "transform": [],
      "searchable": "true",
      "cardinality": "single"
    }, {
      "required": "false",
      "description": "Families that are associated with this entity.",
      "id": "panther_family_label",
      "display_name": "Family",
      "searchable": "true",
      "cardinality": "single",
      "type": "string",
      "indexed": "true",
      "property": [],
      "transform": []
    }],
    "fields_hash": {
      "taxon_closure_label": {
        "transform": [],
        "property": [],
        "type": "string",
        "indexed": "true",
        "cardinality": "multi",
        "searchable": "true",
        "description": "Labels derived from C13 + ncbi_taxonomy.obo.",
        "display_name": "Taxon",
        "id": "taxon_closure_label",
        "required": "false"
      },
      "id": {
        "searchable": "false",
        "cardinality": "single",
        "indexed": "true",
        "type": "string",
        "property": [],
        "transform": [],
        "required": "false",
        "id": "id",
        "display_name": "Acc",
        "description": "Gene/product ID."
      },
      "annotation_class_label": {
        "type": "string",
        "indexed": "true",
        "property": [],
        "transform": [],
        "searchable": "true",
        "cardinality": "single",
        "description": "Column 5 + ontology.",
        "display_name": "Annotation class label",
        "id": "annotation_class_label",
        "required": "false"
      },
      "taxon_label": {
        "cardinality": "single",
        "searchable": "true",
        "property": [],
        "transform": [],
        "indexed": "true",
        "type": "string",
        "required": "false",
        "description": "Derived from C13 + ncbi_taxonomy.obo.",
        "display_name": "Taxon",
        "id": "taxon_label"
      },
      "taxon": {
        "searchable": "false",
        "cardinality": "single",
        "type": "string",
        "indexed": "true",
        "transform": [],
        "property": [],
        "required": "false",
        "description": "Column 13: taxon.",
        "id": "taxon",
        "display_name": "Taxon"
      },
      "taxon_closure": {
        "display_name": "Taxon (IDs)",
        "id": "taxon_closure",
        "description": "IDs derived from C13 + ncbi_taxonomy.obo.",
        "required": "false",
        "transform": [],
        "property": [],
        "type": "string",
        "indexed": "true",
        "cardinality": "multi",
        "searchable": "false"
      },
      "evidence_with": {
        "id": "evidence_with",
        "display_name": "Evidence with",
        "description": "All column 8s for this term/gene product pair",
        "required": "false",
        "transform": [],
        "property": [],
        "type": "string",
        "indexed": "true",
        "cardinality": "multi",
        "searchable": "false"
      },
      "panther_family": {
        "id": "panther_family",
        "display_name": "Protein family",
        "description": "Family IDs that are associated with this entity.",
        "required": "false",
        "indexed": "true",
        "type": "string",
        "property": [],
        "transform": [],
        "searchable": "true",
        "cardinality": "single"
      },
      "bioentity": {
        "searchable": "false",
        "cardinality": "single",
        "type": "string",
        "indexed": "true",
        "transform": [],
        "property": [],
        "required": "false",
        "description": "Column 1 + columns 2.",
        "display_name": "Gene/product ID",
        "id": "bioentity"
      },
      "evidence_type_closure": {
        "indexed": "true",
        "type": "string",
        "transform": [],
        "property": [],
        "searchable": "false",
        "cardinality": "multi",
        "description": "All evidence for this term/gene product pair",
        "id": "evidence_type_closure",
        "display_name": "Evidence type",
        "required": "false"
      },
      "annotation_class": {
        "type": "string",
        "indexed": "true",
        "property": [],
        "transform": [],
        "searchable": "false",
        "cardinality": "single",
        "description": "Column 5.",
        "id": "annotation_class",
        "display_name": "Annotation class",
        "required": "false"
      },
      "bioentity_label": {
        "searchable": "true",
        "cardinality": "single",
        "indexed": "true",
        "type": "string",
        "property": [],
        "transform": [],
        "required": "false",
        "description": "Column 3.",
        "id": "bioentity_label",
        "display_name": "Gene/product label"
      },
      "panther_family_label": {
        "required": "false",
        "description": "Families that are associated with this entity.",
        "id": "panther_family_label",
        "display_name": "Family",
        "searchable": "true",
        "cardinality": "single",
        "type": "string",
        "indexed": "true",
        "property": [],
        "transform": []
      }
    }
  },
  "annotation": {
    "_strict": 0,
    "_outfile": "/home/bbop/local/src/git/amigo/metadata/ann-config.yaml",
    "filter_weights": "aspect^10.0 taxon_subset_closure_label^9.0 type^8.5 evidence_subset_closure_label^8.0 regulates_closure_label^7.5 isa_partof_closure_label^7.0 annotation_class_label^6.0 qualifier^5.0 annotation_extension_class_closure_label^4.0 assigned_by^3.0 panther_family_label^2.0",
    "description": "Associations between GO terms and genes or gene products.",
    "result_weights": "bioentity^7.0 bioentity_name^6.0 qualifier^5.0 annotation_class^4.7 annotation_extension_json^4.5 assigned_by^4.0 taxon^3.0 evidence_type^2.5 evidence_with^2.0 panther_family^1.5 type^1.0 bioentity_isoform^0.5 reference^0.25 date^0.10",
    "weight": "20",
    "id": "annotation",
    "display_name": "Annotations",
    "schema_generating": "true",
    "_infile": "/home/bbop/local/src/git/amigo/metadata/ann-config.yaml",
    "searchable_extension": "_searchable",
    "boost_weights": "annotation_class^2.0 annotation_class_label^1.0 bioentity^2.0 bioentity_label^1.0 bioentity_name^1.0 annotation_extension_class^2.0 annotation_extension_class_label^1.0 reference^1.0 panther_family^1.0 panther_family_label^1.0 bioentity_isoform^1.0 isa_partof_closure^1.0 isa_partof_closure_label^1.0",
    "document_category": "annotation",
    "fields": [{
      "transform": [],
      "property": [],
      "type": "string",
      "indexed": "true",
      "cardinality": "single",
      "searchable": "false",
      "description": "A unique (and internal) combination of bioentity and ontology class.",
      "id": "id",
      "display_name": "Acc",
      "required": "false"
    }, {
      "searchable": "false",
      "cardinality": "single",
      "type": "string",
      "indexed": "true",
      "property": [],
      "transform": [],
      "required": "false",
      "id": "source",
      "display_name": "Source",
      "description": "Database source."
    }, {
      "cardinality": "single",
      "searchable": "false",
      "property": [],
      "transform": [],
      "type": "string",
      "indexed": "true",
      "required": "false",
      "description": "Type class.",
      "id": "type",
      "display_name": "Type"
    }, {
      "required": "false",
      "id": "date",
      "display_name": "Date",
      "description": "Date of assignment.",
      "cardinality": "single",
      "searchable": "false",
      "transform": [],
      "property": [],
      "indexed": "true",
      "type": "string"
    }, {
      "required": "false",
      "description": "Annotations assigned by group.",
      "id": "assigned_by",
      "display_name": "Contributor",
      "searchable": "false",
      "cardinality": "single",
      "type": "string",
      "indexed": "true",
      "property": [],
      "transform": []
    }, {
      "description": "Rational for redundancy of annotation.",
      "display_name": "Redundant for",
      "id": "is_redundant_for",
      "required": "false",
      "property": [],
      "transform": [],
      "indexed": "true",
      "type": "string",
      "cardinality": "single",
      "searchable": "false"
    }, {
      "searchable": "false",
      "cardinality": "single",
      "indexed": "true",
      "type": "string",
      "property": [],
      "transform": [],
      "required": "false",
      "description": "Taxonomic group.",
      "display_name": "Organism",
      "id": "taxon"
    }, {
      "required": "false",
      "description": "Taxonomic group and ancestral groups.",
      "id": "taxon_label",
      "display_name": "Organism",
      "searchable": "true",
      "cardinality": "single",
      "indexed": "true",
      "type": "string",
      "transform": [],
      "property": []
    }, {
      "description": "Taxonomic group and ancestral groups.",
      "display_name": "Organism",
      "id": "taxon_closure",
      "required": "false",
      "transform": [],
      "property": [],
      "indexed": "true",
      "type": "string",
      "cardinality": "multi",
      "searchable": "false"
    }, {
      "searchable": "true",
      "cardinality": "multi",
      "indexed": "true",
      "type": "string",
      "transform": [],
      "property": [],
      "required": "false",
      "id": "taxon_closure_label",
      "display_name": "Organism",
      "description": "Taxonomic group and ancestral groups."
    }, {
      "description": "Taxonomic group (direct) and ancestral groups that are within the specified subset (e.g mammalia, eukaryota).",
      "display_name": "Organism",
      "id": "taxon_subset_closure",
      "required": "false",
      "type": "string",
      "indexed": "true",
      "transform": [],
      "property": [],
      "searchable": "false",
      "cardinality": "multi"
    }, {
      "type": "string",
      "indexed": "true",
      "transform": [],
      "property": [],
      "searchable": "true",
      "cardinality": "multi",
      "description": "Taxonomic group (direct) and ancestral groups that are within the specified subset (e.g mammalia, eukaryota).",
      "id": "taxon_subset_closure_label",
      "display_name": "Organism",
      "required": "false"
    }, {
      "cardinality": "single",
      "searchable": "false",
      "property": [],
      "transform": [],
      "type": "string",
      "indexed": "true",
      "required": "false",
      "description": "Secondary taxon.",
      "display_name": "Secondary taxon",
      "id": "secondary_taxon"
    }, {
      "type": "string",
      "indexed": "true",
      "property": [],
      "transform": [],
      "searchable": "true",
      "cardinality": "single",
      "id": "secondary_taxon_label",
      "display_name": "Secondary taxon",
      "description": "Secondary taxon.",
      "required": "false"
    }, {
      "description": "Secondary taxon closure.",
      "display_name": "Secondary taxon",
      "id": "secondary_taxon_closure",
      "required": "false",
      "indexed": "true",
      "type": "string",
      "transform": [],
      "property": [],
      "searchable": "false",
      "cardinality": "multi"
    }, {
      "required": "false",
      "description": "Secondary taxon closure.",
      "display_name": "Secondary taxon",
      "id": "secondary_taxon_closure_label",
      "cardinality": "multi",
      "searchable": "true",
      "property": [],
      "transform": [],
      "type": "string",
      "indexed": "true"
    }, {
      "id": "regulates_closure",
      "display_name": "GO class (including \"regulates\")",
      "description": "Annotations for this term or its children (over regulates).",
      "required": "false",
      "indexed": "true",
      "type": "string",
      "property": [],
      "transform": [],
      "searchable": "false",
      "cardinality": "multi"
    }, {
      "type": "string",
      "indexed": "true",
      "transform": [],
      "property": [],
      "searchable": "true",
      "cardinality": "multi",
      "display_name": "GO class (including \"regulates\")",
      "id": "regulates_closure_label",
      "description": "Annotations for this term or its children (over regulates).",
      "required": "false"
    }, {
      "description": "Annotations for this term or its children (over is_a/part_of).",
      "id": "isa_partof_closure",
      "display_name": "GO class (excluding \"regulates\")",
      "required": "false",
      "type": "string",
      "indexed": "true",
      "property": [],
      "transform": [],
      "searchable": "false",
      "cardinality": "multi"
    }, {
      "transform": [],
      "property": [],
      "indexed": "true",
      "type": "string",
      "cardinality": "multi",
      "searchable": "true",
      "description": "Annotations for this term or its children (over is_a/part_of).",
      "id": "isa_partof_closure_label",
      "display_name": "GO class (excluding \"regulates\")",
      "required": "false"
    }, {
      "cardinality": "multi",
      "searchable": "false",
      "property": [],
      "transform": [],
      "type": "string",
      "indexed": "true",
      "required": "false",
      "description": "Closure of ids/accs over has_participant.",
      "display_name": "Has participant (IDs)",
      "id": "has_participant_closure"
    }, {
      "required": "false",
      "display_name": "Has participant",
      "id": "has_participant_closure_label",
      "description": "Closure of labels over has_participant.",
      "searchable": "true",
      "cardinality": "multi",
      "type": "string",
      "indexed": "true",
      "transform": [],
      "property": []
    }, {
      "required": "false",
      "id": "synonym",
      "display_name": "Synonym",
      "description": "Gene or gene product synonyms.",
      "cardinality": "multi",
      "searchable": "true",
      "transform": [],
      "property": [],
      "indexed": "true",
      "type": "string"
    }, {
      "description": "Gene or gene product identifiers.",
      "display_name": "Gene/product",
      "id": "bioentity",
      "required": "false",
      "transform": [],
      "property": [],
      "type": "string",
      "indexed": "true",
      "cardinality": "single",
      "searchable": "false"
    }, {
      "cardinality": "single",
      "searchable": "true",
      "transform": [],
      "property": [],
      "type": "string",
      "indexed": "true",
      "required": "false",
      "description": "Gene or gene product identifiers.",
      "id": "bioentity_label",
      "display_name": "Gene/product"
    }, {
      "cardinality": "single",
      "searchable": "true",
      "transform": [],
      "property": [],
      "indexed": "true",
      "type": "string",
      "required": "false",
      "description": "The full name of the gene or gene product.",
      "id": "bioentity_name",
      "display_name": "Gene/product name"
    }, {
      "id": "bioentity_internal_id",
      "display_name": "This should not be displayed",
      "description": "The bioentity ID used at the database of origin.",
      "required": "false",
      "transform": [],
      "property": [],
      "type": "string",
      "indexed": "false",
      "cardinality": "single",
      "searchable": "false"
    }, {
      "cardinality": "multi",
      "searchable": "false",
      "property": [],
      "transform": [],
      "indexed": "true",
      "type": "string",
      "required": "false",
      "display_name": "Annotation qualifier",
      "id": "qualifier",
      "description": "Annotation qualifier."
    }, {
      "id": "annotation_class",
      "display_name": "GO class (direct)",
      "description": "Direct annotations.",
      "required": "false",
      "transform": [],
      "property": [],
      "indexed": "true",
      "type": "string",
      "cardinality": "single",
      "searchable": "false"
    }, {
      "searchable": "true",
      "cardinality": "single",
      "indexed": "true",
      "type": "string",
      "transform": [],
      "property": [],
      "required": "false",
      "id": "annotation_class_label",
      "display_name": "GO class (direct)",
      "description": "Direct annotations."
    }, {
      "required": "false",
      "id": "aspect",
      "display_name": "Ontology (aspect)",
      "description": "Ontology aspect.",
      "searchable": "false",
      "cardinality": "single",
      "type": "string",
      "indexed": "true",
      "property": [],
      "transform": []
    }, {
      "property": [],
      "transform": [],
      "indexed": "true",
      "type": "string",
      "cardinality": "single",
      "searchable": "false",
      "description": "Biological isoform.",
      "display_name": "Isoform",
      "id": "bioentity_isoform",
      "required": "false"
    }, {
      "display_name": "Evidence",
      "id": "evidence_type",
      "description": "Evidence type. (legacy)",
      "required": "false",
      "indexed": "true",
      "type": "string",
      "property": [],
      "transform": [],
      "searchable": "false",
      "cardinality": "single"
    }, {
      "required": "false",
      "id": "evidence_type_closure",
      "display_name": "Evidence type",
      "description": "All evidence (evidence closure) for this annotation. (legacy)",
      "searchable": "false",
      "cardinality": "multi",
      "indexed": "true",
      "type": "string",
      "property": [],
      "transform": []
    }, {
      "indexed": "true",
      "type": "string",
      "property": [],
      "transform": [],
      "searchable": "true",
      "cardinality": "multi",
      "description": "Evidence with/from.",
      "id": "evidence_with",
      "display_name": "Evidence with",
      "required": "false"
    }, {
      "searchable": "false",
      "cardinality": "single",
      "type": "string",
      "indexed": "true",
      "property": [],
      "transform": [],
      "required": "false",
      "id": "evidence",
      "display_name": "Evidence",
      "description": "Evidence."
    }, {
      "required": "false",
      "display_name": "Evidence",
      "id": "evidence_label",
      "description": "Evidence.",
      "searchable": "true",
      "cardinality": "single",
      "type": "string",
      "indexed": "true",
      "property": [],
      "transform": []
    }, {
      "type": "string",
      "indexed": "true",
      "property": [],
      "transform": [],
      "searchable": "false",
      "cardinality": "multi",
      "display_name": "Evidence",
      "id": "evidence_closure",
      "description": "All evidence for this annotation.",
      "required": "false"
    }, {
      "required": "false",
      "description": "All evidence for this annotation.",
      "id": "evidence_closure_label",
      "display_name": "Evidence",
      "cardinality": "multi",
      "searchable": "true",
      "property": [],
      "transform": [],
      "indexed": "true",
      "type": "string"
    }, {
      "searchable": "false",
      "cardinality": "multi",
      "type": "string",
      "indexed": "true",
      "transform": [],
      "property": [],
      "required": "false",
      "id": "evidence_subset_closure",
      "display_name": "Evidence",
      "description": "All evidence for this annotation reduced to a usable subset."
    }, {
      "property": [],
      "transform": [],
      "type": "string",
      "indexed": "true",
      "cardinality": "multi",
      "searchable": "true",
      "id": "evidence_subset_closure_label",
      "display_name": "Evidence",
      "description": "All evidence for this annotation reduced to a usable subset.",
      "required": "false"
    }, {
      "id": "reference",
      "display_name": "Reference",
      "description": "Database reference.",
      "required": "false",
      "type": "string",
      "indexed": "true",
      "transform": [],
      "property": [],
      "searchable": "true",
      "cardinality": "multi"
    }, {
      "indexed": "true",
      "type": "string",
      "transform": [],
      "property": [],
      "searchable": "false",
      "cardinality": "multi",
      "description": "Extension class for the annotation.",
      "display_name": "Annotation extension",
      "id": "annotation_extension_class",
      "required": "false"
    }, {
      "cardinality": "multi",
      "searchable": "true",
      "transform": [],
      "property": [],
      "indexed": "true",
      "type": "string",
      "required": "false",
      "display_name": "Annotation extension",
      "id": "annotation_extension_class_label",
      "description": "Extension class for the annotation."
    }, {
      "display_name": "Annotation extension",
      "id": "annotation_extension_class_closure",
      "description": "Extension class for the annotation.",
      "required": "false",
      "property": [],
      "transform": [],
      "indexed": "true",
      "type": "string",
      "cardinality": "multi",
      "searchable": "false"
    }, {
      "indexed": "true",
      "type": "string",
      "transform": [],
      "property": [],
      "searchable": "true",
      "cardinality": "multi",
      "display_name": "Annotation extension",
      "id": "annotation_extension_class_closure_label",
      "description": "Extension class for the annotation.",
      "required": "false"
    }, {
      "id": "annotation_extension_json",
      "display_name": "Annotation extension",
      "description": "Extension class for the annotation (JSON).",
      "required": "false",
      "indexed": "true",
      "type": "string",
      "transform": [],
      "property": [],
      "searchable": "false",
      "cardinality": "multi"
    }, {
      "required": "false",
      "description": "PANTHER families that are associated with this entity.",
      "id": "panther_family",
      "display_name": "PANTHER family",
      "searchable": "true",
      "cardinality": "single",
      "indexed": "true",
      "type": "string",
      "property": [],
      "transform": []
    }, {
      "required": "false",
      "id": "panther_family_label",
      "display_name": "PANTHER family",
      "description": "PANTHER families that are associated with this entity.",
      "cardinality": "single",
      "searchable": "true",
      "property": [],
      "transform": [],
      "indexed": "true",
      "type": "string"
    }, {
      "required": "false",
      "description": "Experimental numeric type (X).",
      "display_name": "X",
      "id": "geospatial_x",
      "cardinality": "multi",
      "searchable": "false",
      "property": [],
      "transform": [],
      "indexed": "true",
      "type": "integer"
    }, {
      "required": "false",
      "id": "geospatial_y",
      "display_name": "Y",
      "description": "Experimental numeric type (Y).",
      "searchable": "false",
      "cardinality": "multi",
      "type": "integer",
      "indexed": "true",
      "transform": [],
      "property": []
    }, {
      "type": "integer",
      "indexed": "true",
      "property": [],
      "transform": [],
      "searchable": "false",
      "cardinality": "multi",
      "id": "geospatial_z",
      "display_name": "Z",
      "description": "Experimental numeric type (Z).",
      "required": "false"
    }],
    "fields_hash": {
      "evidence_closure_label": {
        "required": "false",
        "description": "All evidence for this annotation.",
        "id": "evidence_closure_label",
        "display_name": "Evidence",
        "cardinality": "multi",
        "searchable": "true",
        "property": [],
        "transform": [],
        "indexed": "true",
        "type": "string"
      },
      "evidence_type": {
        "display_name": "Evidence",
        "id": "evidence_type",
        "description": "Evidence type. (legacy)",
        "required": "false",
        "indexed": "true",
        "type": "string",
        "property": [],
        "transform": [],
        "searchable": "false",
        "cardinality": "single"
      },
      "has_participant_closure_label": {
        "required": "false",
        "display_name": "Has participant",
        "id": "has_participant_closure_label",
        "description": "Closure of labels over has_participant.",
        "searchable": "true",
        "cardinality": "multi",
        "type": "string",
        "indexed": "true",
        "transform": [],
        "property": []
      },
      "annotation_extension_json": {
        "id": "annotation_extension_json",
        "display_name": "Annotation extension",
        "description": "Extension class for the annotation (JSON).",
        "required": "false",
        "indexed": "true",
        "type": "string",
        "transform": [],
        "property": [],
        "searchable": "false",
        "cardinality": "multi"
      },
      "annotation_class_label": {
        "searchable": "true",
        "cardinality": "single",
        "indexed": "true",
        "type": "string",
        "transform": [],
        "property": [],
        "required": "false",
        "id": "annotation_class_label",
        "display_name": "GO class (direct)",
        "description": "Direct annotations."
      },
      "regulates_closure": {
        "id": "regulates_closure",
        "display_name": "GO class (including \"regulates\")",
        "description": "Annotations for this term or its children (over regulates).",
        "required": "false",
        "indexed": "true",
        "type": "string",
        "property": [],
        "transform": [],
        "searchable": "false",
        "cardinality": "multi"
      },
      "geospatial_z": {
        "type": "integer",
        "indexed": "true",
        "property": [],
        "transform": [],
        "searchable": "false",
        "cardinality": "multi",
        "id": "geospatial_z",
        "display_name": "Z",
        "description": "Experimental numeric type (Z).",
        "required": "false"
      },
      "annotation_extension_class": {
        "indexed": "true",
        "type": "string",
        "transform": [],
        "property": [],
        "searchable": "false",
        "cardinality": "multi",
        "description": "Extension class for the annotation.",
        "display_name": "Annotation extension",
        "id": "annotation_extension_class",
        "required": "false"
      },
      "isa_partof_closure_label": {
        "transform": [],
        "property": [],
        "indexed": "true",
        "type": "string",
        "cardinality": "multi",
        "searchable": "true",
        "description": "Annotations for this term or its children (over is_a/part_of).",
        "id": "isa_partof_closure_label",
        "display_name": "GO class (excluding \"regulates\")",
        "required": "false"
      },
      "panther_family_label": {
        "required": "false",
        "id": "panther_family_label",
        "display_name": "PANTHER family",
        "description": "PANTHER families that are associated with this entity.",
        "cardinality": "single",
        "searchable": "true",
        "property": [],
        "transform": [],
        "indexed": "true",
        "type": "string"
      },
      "bioentity_name": {
        "cardinality": "single",
        "searchable": "true",
        "transform": [],
        "property": [],
        "indexed": "true",
        "type": "string",
        "required": "false",
        "description": "The full name of the gene or gene product.",
        "id": "bioentity_name",
        "display_name": "Gene/product name"
      },
      "secondary_taxon_label": {
        "type": "string",
        "indexed": "true",
        "property": [],
        "transform": [],
        "searchable": "true",
        "cardinality": "single",
        "id": "secondary_taxon_label",
        "display_name": "Secondary taxon",
        "description": "Secondary taxon.",
        "required": "false"
      },
      "annotation_extension_class_closure": {
        "display_name": "Annotation extension",
        "id": "annotation_extension_class_closure",
        "description": "Extension class for the annotation.",
        "required": "false",
        "property": [],
        "transform": [],
        "indexed": "true",
        "type": "string",
        "cardinality": "multi",
        "searchable": "false"
      },
      "assigned_by": {
        "required": "false",
        "description": "Annotations assigned by group.",
        "id": "assigned_by",
        "display_name": "Contributor",
        "searchable": "false",
        "cardinality": "single",
        "type": "string",
        "indexed": "true",
        "property": [],
        "transform": []
      },
      "bioentity_isoform": {
        "property": [],
        "transform": [],
        "indexed": "true",
        "type": "string",
        "cardinality": "single",
        "searchable": "false",
        "description": "Biological isoform.",
        "display_name": "Isoform",
        "id": "bioentity_isoform",
        "required": "false"
      },
      "taxon_subset_closure": {
        "description": "Taxonomic group (direct) and ancestral groups that are within the specified subset (e.g mammalia, eukaryota).",
        "display_name": "Organism",
        "id": "taxon_subset_closure",
        "required": "false",
        "type": "string",
        "indexed": "true",
        "transform": [],
        "property": [],
        "searchable": "false",
        "cardinality": "multi"
      },
      "evidence": {
        "searchable": "false",
        "cardinality": "single",
        "type": "string",
        "indexed": "true",
        "property": [],
        "transform": [],
        "required": "false",
        "id": "evidence",
        "display_name": "Evidence",
        "description": "Evidence."
      },
      "taxon_closure": {
        "description": "Taxonomic group and ancestral groups.",
        "display_name": "Organism",
        "id": "taxon_closure",
        "required": "false",
        "transform": [],
        "property": [],
        "indexed": "true",
        "type": "string",
        "cardinality": "multi",
        "searchable": "false"
      },
      "evidence_subset_closure": {
        "searchable": "false",
        "cardinality": "multi",
        "type": "string",
        "indexed": "true",
        "transform": [],
        "property": [],
        "required": "false",
        "id": "evidence_subset_closure",
        "display_name": "Evidence",
        "description": "All evidence for this annotation reduced to a usable subset."
      },
      "bioentity": {
        "description": "Gene or gene product identifiers.",
        "display_name": "Gene/product",
        "id": "bioentity",
        "required": "false",
        "transform": [],
        "property": [],
        "type": "string",
        "indexed": "true",
        "cardinality": "single",
        "searchable": "false"
      },
      "geospatial_x": {
        "required": "false",
        "description": "Experimental numeric type (X).",
        "display_name": "X",
        "id": "geospatial_x",
        "cardinality": "multi",
        "searchable": "false",
        "property": [],
        "transform": [],
        "indexed": "true",
        "type": "integer"
      },
      "geospatial_y": {
        "required": "false",
        "id": "geospatial_y",
        "display_name": "Y",
        "description": "Experimental numeric type (Y).",
        "searchable": "false",
        "cardinality": "multi",
        "type": "integer",
        "indexed": "true",
        "transform": [],
        "property": []
      },
      "secondary_taxon": {
        "cardinality": "single",
        "searchable": "false",
        "property": [],
        "transform": [],
        "type": "string",
        "indexed": "true",
        "required": "false",
        "description": "Secondary taxon.",
        "display_name": "Secondary taxon",
        "id": "secondary_taxon"
      },
      "bioentity_label": {
        "cardinality": "single",
        "searchable": "true",
        "transform": [],
        "property": [],
        "type": "string",
        "indexed": "true",
        "required": "false",
        "description": "Gene or gene product identifiers.",
        "id": "bioentity_label",
        "display_name": "Gene/product"
      },
      "annotation_extension_class_closure_label": {
        "indexed": "true",
        "type": "string",
        "transform": [],
        "property": [],
        "searchable": "true",
        "cardinality": "multi",
        "display_name": "Annotation extension",
        "id": "annotation_extension_class_closure_label",
        "description": "Extension class for the annotation.",
        "required": "false"
      },
      "has_participant_closure": {
        "cardinality": "multi",
        "searchable": "false",
        "property": [],
        "transform": [],
        "type": "string",
        "indexed": "true",
        "required": "false",
        "description": "Closure of ids/accs over has_participant.",
        "display_name": "Has participant (IDs)",
        "id": "has_participant_closure"
      },
      "secondary_taxon_closure_label": {
        "required": "false",
        "description": "Secondary taxon closure.",
        "display_name": "Secondary taxon",
        "id": "secondary_taxon_closure_label",
        "cardinality": "multi",
        "searchable": "true",
        "property": [],
        "transform": [],
        "type": "string",
        "indexed": "true"
      },
      "date": {
        "required": "false",
        "id": "date",
        "display_name": "Date",
        "description": "Date of assignment.",
        "cardinality": "single",
        "searchable": "false",
        "transform": [],
        "property": [],
        "indexed": "true",
        "type": "string"
      },
      "evidence_with": {
        "indexed": "true",
        "type": "string",
        "property": [],
        "transform": [],
        "searchable": "true",
        "cardinality": "multi",
        "description": "Evidence with/from.",
        "id": "evidence_with",
        "display_name": "Evidence with",
        "required": "false"
      },
      "panther_family": {
        "required": "false",
        "description": "PANTHER families that are associated with this entity.",
        "id": "panther_family",
        "display_name": "PANTHER family",
        "searchable": "true",
        "cardinality": "single",
        "indexed": "true",
        "type": "string",
        "property": [],
        "transform": []
      },
      "id": {
        "transform": [],
        "property": [],
        "type": "string",
        "indexed": "true",
        "cardinality": "single",
        "searchable": "false",
        "description": "A unique (and internal) combination of bioentity and ontology class.",
        "id": "id",
        "display_name": "Acc",
        "required": "false"
      },
      "regulates_closure_label": {
        "type": "string",
        "indexed": "true",
        "transform": [],
        "property": [],
        "searchable": "true",
        "cardinality": "multi",
        "display_name": "GO class (including \"regulates\")",
        "id": "regulates_closure_label",
        "description": "Annotations for this term or its children (over regulates).",
        "required": "false"
      },
      "evidence_label": {
        "required": "false",
        "display_name": "Evidence",
        "id": "evidence_label",
        "description": "Evidence.",
        "searchable": "true",
        "cardinality": "single",
        "type": "string",
        "indexed": "true",
        "property": [],
        "transform": []
      },
      "secondary_taxon_closure": {
        "description": "Secondary taxon closure.",
        "display_name": "Secondary taxon",
        "id": "secondary_taxon_closure",
        "required": "false",
        "indexed": "true",
        "type": "string",
        "transform": [],
        "property": [],
        "searchable": "false",
        "cardinality": "multi"
      },
      "taxon_label": {
        "required": "false",
        "description": "Taxonomic group and ancestral groups.",
        "id": "taxon_label",
        "display_name": "Organism",
        "searchable": "true",
        "cardinality": "single",
        "indexed": "true",
        "type": "string",
        "transform": [],
        "property": []
      },
      "annotation_extension_class_label": {
        "cardinality": "multi",
        "searchable": "true",
        "transform": [],
        "property": [],
        "indexed": "true",
        "type": "string",
        "required": "false",
        "display_name": "Annotation extension",
        "id": "annotation_extension_class_label",
        "description": "Extension class for the annotation."
      },
      "bioentity_internal_id": {
        "id": "bioentity_internal_id",
        "display_name": "This should not be displayed",
        "description": "The bioentity ID used at the database of origin.",
        "required": "false",
        "transform": [],
        "property": [],
        "type": "string",
        "indexed": "false",
        "cardinality": "single",
        "searchable": "false"
      },
      "isa_partof_closure": {
        "description": "Annotations for this term or its children (over is_a/part_of).",
        "id": "isa_partof_closure",
        "display_name": "GO class (excluding \"regulates\")",
        "required": "false",
        "type": "string",
        "indexed": "true",
        "property": [],
        "transform": [],
        "searchable": "false",
        "cardinality": "multi"
      },
      "qualifier": {
        "cardinality": "multi",
        "searchable": "false",
        "property": [],
        "transform": [],
        "indexed": "true",
        "type": "string",
        "required": "false",
        "display_name": "Annotation qualifier",
        "id": "qualifier",
        "description": "Annotation qualifier."
      },
      "type": {
        "cardinality": "single",
        "searchable": "false",
        "property": [],
        "transform": [],
        "type": "string",
        "indexed": "true",
        "required": "false",
        "description": "Type class.",
        "id": "type",
        "display_name": "Type"
      },
      "evidence_type_closure": {
        "required": "false",
        "id": "evidence_type_closure",
        "display_name": "Evidence type",
        "description": "All evidence (evidence closure) for this annotation. (legacy)",
        "searchable": "false",
        "cardinality": "multi",
        "indexed": "true",
        "type": "string",
        "property": [],
        "transform": []
      },
      "taxon_subset_closure_label": {
        "type": "string",
        "indexed": "true",
        "transform": [],
        "property": [],
        "searchable": "true",
        "cardinality": "multi",
        "description": "Taxonomic group (direct) and ancestral groups that are within the specified subset (e.g mammalia, eukaryota).",
        "id": "taxon_subset_closure_label",
        "display_name": "Organism",
        "required": "false"
      },
      "annotation_class": {
        "id": "annotation_class",
        "display_name": "GO class (direct)",
        "description": "Direct annotations.",
        "required": "false",
        "transform": [],
        "property": [],
        "indexed": "true",
        "type": "string",
        "cardinality": "single",
        "searchable": "false"
      },
      "source": {
        "searchable": "false",
        "cardinality": "single",
        "type": "string",
        "indexed": "true",
        "property": [],
        "transform": [],
        "required": "false",
        "id": "source",
        "display_name": "Source",
        "description": "Database source."
      },
      "synonym": {
        "required": "false",
        "id": "synonym",
        "display_name": "Synonym",
        "description": "Gene or gene product synonyms.",
        "cardinality": "multi",
        "searchable": "true",
        "transform": [],
        "property": [],
        "indexed": "true",
        "type": "string"
      },
      "taxon_closure_label": {
        "searchable": "true",
        "cardinality": "multi",
        "indexed": "true",
        "type": "string",
        "transform": [],
        "property": [],
        "required": "false",
        "id": "taxon_closure_label",
        "display_name": "Organism",
        "description": "Taxonomic group and ancestral groups."
      },
      "taxon": {
        "searchable": "false",
        "cardinality": "single",
        "indexed": "true",
        "type": "string",
        "property": [],
        "transform": [],
        "required": "false",
        "description": "Taxonomic group.",
        "display_name": "Organism",
        "id": "taxon"
      },
      "reference": {
        "id": "reference",
        "display_name": "Reference",
        "description": "Database reference.",
        "required": "false",
        "type": "string",
        "indexed": "true",
        "transform": [],
        "property": [],
        "searchable": "true",
        "cardinality": "multi"
      },
      "evidence_subset_closure_label": {
        "property": [],
        "transform": [],
        "type": "string",
        "indexed": "true",
        "cardinality": "multi",
        "searchable": "true",
        "id": "evidence_subset_closure_label",
        "display_name": "Evidence",
        "description": "All evidence for this annotation reduced to a usable subset.",
        "required": "false"
      },
      "is_redundant_for": {
        "description": "Rational for redundancy of annotation.",
        "display_name": "Redundant for",
        "id": "is_redundant_for",
        "required": "false",
        "property": [],
        "transform": [],
        "indexed": "true",
        "type": "string",
        "cardinality": "single",
        "searchable": "false"
      },
      "aspect": {
        "required": "false",
        "id": "aspect",
        "display_name": "Ontology (aspect)",
        "description": "Ontology aspect.",
        "searchable": "false",
        "cardinality": "single",
        "type": "string",
        "indexed": "true",
        "property": [],
        "transform": []
      },
      "evidence_closure": {
        "type": "string",
        "indexed": "true",
        "property": [],
        "transform": [],
        "searchable": "false",
        "cardinality": "multi",
        "display_name": "Evidence",
        "id": "evidence_closure",
        "description": "All evidence for this annotation.",
        "required": "false"
      }
    }
  },
  "bioentity": {
    "_infile": "/home/bbop/local/src/git/amigo/metadata/bio-config.yaml",
    "_strict": 0,
    "filter_weights": "source^7.0 taxon_subset_closure_label^6.0 type^5.0 panther_family_label^4.0 annotation_class_list_label^3.0 isa_partof_closure_label^2.0",
    "_outfile": "/home/bbop/local/src/git/amigo/metadata/bio-config.yaml",
    "result_weights": "bioentity^8.0 bioentity_name^7.0 taxon^6.0 panther_family^5.0 type^4.0 source^3.0 synonym^1.0",
    "description": "Genes and gene products associated with GO terms.",
    "weight": "30",
    "id": "bioentity",
    "schema_generating": "true",
    "display_name": "Genes and gene products",
    "boost_weights": "bioentity^2.0 bioentity_label^2.0 bioentity_name^1.0 bioentity_internal_id^1.0 synonym^1.0 isa_partof_closure^1.0 isa_partof_closure_label^1.0 panther_family^1.0 panther_family_label^1.0 taxon_label^1.0",
    "document_category": "bioentity",
    "fields": [{
      "required": "false",
      "description": "Gene of gene product ID.",
      "id": "id",
      "display_name": "Acc",
      "searchable": "false",
      "cardinality": "single",
      "indexed": "true",
      "type": "string",
      "property": [],
      "transform": []
    }, {
      "property": [],
      "transform": [],
      "indexed": "true",
      "type": "string",
      "cardinality": "single",
      "searchable": "false",
      "id": "bioentity",
      "display_name": "Gene/product",
      "description": "Gene or gene product identifiers.",
      "required": "false"
    }, {
      "required": "false",
      "display_name": "Gene/product",
      "id": "bioentity_label",
      "description": "Gene or gene product identifiers.",
      "searchable": "true",
      "cardinality": "single",
      "type": "string",
      "indexed": "true",
      "transform": [],
      "property": []
    }, {
      "cardinality": "single",
      "searchable": "true",
      "property": [],
      "transform": [],
      "indexed": "true",
      "type": "string",
      "required": "false",
      "description": "The full name of the gene or gene product.",
      "display_name": "Gene/product name",
      "id": "bioentity_name"
    }, {
      "required": "false",
      "description": "The bioentity ID used at the database of origin.",
      "display_name": "This should not be displayed",
      "id": "bioentity_internal_id",
      "cardinality": "single",
      "searchable": "false",
      "transform": [],
      "property": [],
      "indexed": "false",
      "type": "string"
    }, {
      "description": "Type class.",
      "display_name": "Type",
      "id": "type",
      "required": "false",
      "property": [],
      "transform": [],
      "indexed": "true",
      "type": "string",
      "cardinality": "single",
      "searchable": "false"
    }, {
      "type": "string",
      "indexed": "true",
      "property": [],
      "transform": [],
      "searchable": "false",
      "cardinality": "single",
      "description": "Taxonomic group",
      "id": "taxon",
      "display_name": "Organism",
      "required": "false"
    }, {
      "indexed": "true",
      "type": "string",
      "transform": [],
      "property": [],
      "searchable": "true",
      "cardinality": "single",
      "id": "taxon_label",
      "display_name": "Organism",
      "description": "Taxonomic group",
      "required": "false"
    }, {
      "cardinality": "multi",
      "searchable": "false",
      "transform": [],
      "property": [],
      "indexed": "true",
      "type": "string",
      "required": "false",
      "id": "taxon_closure",
      "display_name": "Organism",
      "description": "Taxonomic group and ancestral groups."
    }, {
      "required": "false",
      "description": "Taxonomic group and ancestral groups.",
      "id": "taxon_closure_label",
      "display_name": "Organism",
      "searchable": "true",
      "cardinality": "multi",
      "indexed": "true",
      "type": "string",
      "property": [],
      "transform": []
    }, {
      "property": [],
      "transform": [],
      "indexed": "true",
      "type": "string",
      "cardinality": "multi",
      "searchable": "false",
      "description": "Taxonomic group (direct) and ancestral groups that are within the specified subset (e.g mammalia, eukaryota).",
      "id": "taxon_subset_closure",
      "display_name": "Organism",
      "required": "false"
    }, {
      "cardinality": "multi",
      "searchable": "true",
      "transform": [],
      "property": [],
      "indexed": "true",
      "type": "string",
      "required": "false",
      "id": "taxon_subset_closure_label",
      "display_name": "Organism",
      "description": "Labels for taxonomic group (direct) and ancestral groups that are within the specified subset."
    }, {
      "required": "false",
      "display_name": "Involved in",
      "id": "isa_partof_closure",
      "description": "Closure of ids/accs over isa and partof.",
      "searchable": "false",
      "cardinality": "multi",
      "type": "string",
      "indexed": "true",
      "transform": [],
      "property": []
    }, {
      "required": "false",
      "display_name": "Involved in",
      "id": "isa_partof_closure_label",
      "description": "Closure of labels over isa and partof.",
      "cardinality": "multi",
      "searchable": "true",
      "transform": [],
      "property": [],
      "indexed": "true",
      "type": "string"
    }, {
      "cardinality": "multi",
      "searchable": "false",
      "property": [],
      "transform": [],
      "type": "string",
      "indexed": "true",
      "required": "false",
      "display_name": "Inferred annotation",
      "id": "regulates_closure",
      "description": "Bioentities associated with this term or its children (over regulates)."
    }, {
      "required": "false",
      "description": "Bioentities associated with this term or its children (over regulates).",
      "display_name": "Inferred annotation",
      "id": "regulates_closure_label",
      "searchable": "true",
      "cardinality": "multi",
      "indexed": "true",
      "type": "string",
      "transform": [],
      "property": []
    }, {
      "searchable": "false",
      "cardinality": "single",
      "type": "string",
      "indexed": "true",
      "property": [],
      "transform": [],
      "required": "false",
      "description": "Database source.",
      "display_name": "Source",
      "id": "source"
    }, {
      "description": "Direct annotations.",
      "id": "annotation_class_list",
      "display_name": "Direct annotation",
      "required": "false",
      "transform": [],
      "property": [],
      "type": "string",
      "indexed": "true",
      "cardinality": "multi",
      "searchable": "false"
    }, {
      "id": "annotation_class_list_label",
      "display_name": "Direct annotation",
      "description": "Direct annotations.",
      "required": "false",
      "type": "string",
      "indexed": "true",
      "transform": [],
      "property": [],
      "searchable": "false",
      "cardinality": "multi"
    }, {
      "property": [],
      "transform": [],
      "indexed": "true",
      "type": "string",
      "cardinality": "multi",
      "searchable": "true",
      "description": "Gene product synonyms.",
      "display_name": "Synonyms",
      "id": "synonym",
      "required": "false"
    }, {
      "searchable": "true",
      "cardinality": "single",
      "indexed": "true",
      "type": "string",
      "property": [],
      "transform": [],
      "required": "false",
      "description": "PANTHER families that are associated with this entity.",
      "id": "panther_family",
      "display_name": "PANTHER family"
    }, {
      "type": "string",
      "indexed": "true",
      "transform": [],
      "property": [],
      "searchable": "true",
      "cardinality": "single",
      "id": "panther_family_label",
      "display_name": "PANTHER family",
      "description": "PANTHER families that are associated with this entity.",
      "required": "false"
    }, {
      "required": "false",
      "description": "JSON blob form of the phylogenic tree.",
      "display_name": "This should not be displayed",
      "id": "phylo_graph_json",
      "cardinality": "single",
      "searchable": "false",
      "transform": [],
      "property": [],
      "type": "string",
      "indexed": "false"
    }, {
      "cardinality": "multi",
      "searchable": "false",
      "property": [],
      "transform": [],
      "type": "string",
      "indexed": "true",
      "required": "false",
      "description": "Database cross-reference.",
      "id": "database_xref",
      "display_name": "DB xref"
    }],
    "fields_hash": {
      "taxon_closure_label": {
        "required": "false",
        "description": "Taxonomic group and ancestral groups.",
        "id": "taxon_closure_label",
        "display_name": "Organism",
        "searchable": "true",
        "cardinality": "multi",
        "indexed": "true",
        "type": "string",
        "property": [],
        "transform": []
      },
      "taxon": {
        "type": "string",
        "indexed": "true",
        "property": [],
        "transform": [],
        "searchable": "false",
        "cardinality": "single",
        "description": "Taxonomic group",
        "id": "taxon",
        "display_name": "Organism",
        "required": "false"
      },
      "phylo_graph_json": {
        "required": "false",
        "description": "JSON blob form of the phylogenic tree.",
        "display_name": "This should not be displayed",
        "id": "phylo_graph_json",
        "cardinality": "single",
        "searchable": "false",
        "transform": [],
        "property": [],
        "type": "string",
        "indexed": "false"
      },
      "database_xref": {
        "cardinality": "multi",
        "searchable": "false",
        "property": [],
        "transform": [],
        "type": "string",
        "indexed": "true",
        "required": "false",
        "description": "Database cross-reference.",
        "id": "database_xref",
        "display_name": "DB xref"
      },
      "taxon_closure": {
        "cardinality": "multi",
        "searchable": "false",
        "transform": [],
        "property": [],
        "indexed": "true",
        "type": "string",
        "required": "false",
        "id": "taxon_closure",
        "display_name": "Organism",
        "description": "Taxonomic group and ancestral groups."
      },
      "bioentity": {
        "property": [],
        "transform": [],
        "indexed": "true",
        "type": "string",
        "cardinality": "single",
        "searchable": "false",
        "id": "bioentity",
        "display_name": "Gene/product",
        "description": "Gene or gene product identifiers.",
        "required": "false"
      },
      "synonym": {
        "property": [],
        "transform": [],
        "indexed": "true",
        "type": "string",
        "cardinality": "multi",
        "searchable": "true",
        "description": "Gene product synonyms.",
        "display_name": "Synonyms",
        "id": "synonym",
        "required": "false"
      },
      "annotation_class_list": {
        "description": "Direct annotations.",
        "id": "annotation_class_list",
        "display_name": "Direct annotation",
        "required": "false",
        "transform": [],
        "property": [],
        "type": "string",
        "indexed": "true",
        "cardinality": "multi",
        "searchable": "false"
      },
      "source": {
        "searchable": "false",
        "cardinality": "single",
        "type": "string",
        "indexed": "true",
        "property": [],
        "transform": [],
        "required": "false",
        "description": "Database source.",
        "display_name": "Source",
        "id": "source"
      },
      "annotation_class_list_label": {
        "id": "annotation_class_list_label",
        "display_name": "Direct annotation",
        "description": "Direct annotations.",
        "required": "false",
        "type": "string",
        "indexed": "true",
        "transform": [],
        "property": [],
        "searchable": "false",
        "cardinality": "multi"
      },
      "bioentity_label": {
        "required": "false",
        "display_name": "Gene/product",
        "id": "bioentity_label",
        "description": "Gene or gene product identifiers.",
        "searchable": "true",
        "cardinality": "single",
        "type": "string",
        "indexed": "true",
        "transform": [],
        "property": []
      },
      "regulates_closure_label": {
        "required": "false",
        "description": "Bioentities associated with this term or its children (over regulates).",
        "display_name": "Inferred annotation",
        "id": "regulates_closure_label",
        "searchable": "true",
        "cardinality": "multi",
        "indexed": "true",
        "type": "string",
        "transform": [],
        "property": []
      },
      "id": {
        "required": "false",
        "description": "Gene of gene product ID.",
        "id": "id",
        "display_name": "Acc",
        "searchable": "false",
        "cardinality": "single",
        "indexed": "true",
        "type": "string",
        "property": [],
        "transform": []
      },
      "taxon_label": {
        "indexed": "true",
        "type": "string",
        "transform": [],
        "property": [],
        "searchable": "true",
        "cardinality": "single",
        "id": "taxon_label",
        "display_name": "Organism",
        "description": "Taxonomic group",
        "required": "false"
      },
      "regulates_closure": {
        "cardinality": "multi",
        "searchable": "false",
        "property": [],
        "transform": [],
        "type": "string",
        "indexed": "true",
        "required": "false",
        "display_name": "Inferred annotation",
        "id": "regulates_closure",
        "description": "Bioentities associated with this term or its children (over regulates)."
      },
      "panther_family": {
        "searchable": "true",
        "cardinality": "single",
        "indexed": "true",
        "type": "string",
        "property": [],
        "transform": [],
        "required": "false",
        "description": "PANTHER families that are associated with this entity.",
        "id": "panther_family",
        "display_name": "PANTHER family"
      },
      "type": {
        "description": "Type class.",
        "display_name": "Type",
        "id": "type",
        "required": "false",
        "property": [],
        "transform": [],
        "indexed": "true",
        "type": "string",
        "cardinality": "single",
        "searchable": "false"
      },
      "taxon_subset_closure": {
        "property": [],
        "transform": [],
        "indexed": "true",
        "type": "string",
        "cardinality": "multi",
        "searchable": "false",
        "description": "Taxonomic group (direct) and ancestral groups that are within the specified subset (e.g mammalia, eukaryota).",
        "id": "taxon_subset_closure",
        "display_name": "Organism",
        "required": "false"
      },
      "taxon_subset_closure_label": {
        "cardinality": "multi",
        "searchable": "true",
        "transform": [],
        "property": [],
        "indexed": "true",
        "type": "string",
        "required": "false",
        "id": "taxon_subset_closure_label",
        "display_name": "Organism",
        "description": "Labels for taxonomic group (direct) and ancestral groups that are within the specified subset."
      },
      "isa_partof_closure_label": {
        "required": "false",
        "display_name": "Involved in",
        "id": "isa_partof_closure_label",
        "description": "Closure of labels over isa and partof.",
        "cardinality": "multi",
        "searchable": "true",
        "transform": [],
        "property": [],
        "indexed": "true",
        "type": "string"
      },
      "isa_partof_closure": {
        "required": "false",
        "display_name": "Involved in",
        "id": "isa_partof_closure",
        "description": "Closure of ids/accs over isa and partof.",
        "searchable": "false",
        "cardinality": "multi",
        "type": "string",
        "indexed": "true",
        "transform": [],
        "property": []
      },
      "bioentity_internal_id": {
        "required": "false",
        "description": "The bioentity ID used at the database of origin.",
        "display_name": "This should not be displayed",
        "id": "bioentity_internal_id",
        "cardinality": "single",
        "searchable": "false",
        "transform": [],
        "property": [],
        "indexed": "false",
        "type": "string"
      },
      "panther_family_label": {
        "type": "string",
        "indexed": "true",
        "transform": [],
        "property": [],
        "searchable": "true",
        "cardinality": "single",
        "id": "panther_family_label",
        "display_name": "PANTHER family",
        "description": "PANTHER families that are associated with this entity.",
        "required": "false"
      },
      "bioentity_name": {
        "cardinality": "single",
        "searchable": "true",
        "property": [],
        "transform": [],
        "indexed": "true",
        "type": "string",
        "required": "false",
        "description": "The full name of the gene or gene product.",
        "display_name": "Gene/product name",
        "id": "bioentity_name"
      }
    },
    "searchable_extension": "_searchable"
  },
  "ontology": {
    "_infile": "/home/bbop/local/src/git/amigo/metadata/ont-config.yaml",
    "_strict": 0,
    "_outfile": "/home/bbop/local/src/git/amigo/metadata/ont-config.yaml",
    "filter_weights": "source^4.0 idspace^3.5 subset^3.0 is_obsolete^0.0",
    "weight": "40",
    "description": "Gene Ontology Term, Synonym, or Definition.",
    "result_weights": "annotation_class^8.0 description^6.0 source^4.0 idspace^3.5 synonym^3.0 alternate_id^2.0",
    "id": "ontology",
    "schema_generating": "true",
    "display_name": "Ontology",
    "boost_weights": "annotation_class^3.0 annotation_class_label^5.5 description^1.0 synonym^1.0 alternate_id^1.0",
    "document_category": "ontology_class",
    "fields": [{
      "searchable": "false",
      "cardinality": "single",
      "type": "string",
      "indexed": "true",
      "transform": [],
      "property": ["getIdentifier"],
      "required": "false",
      "display_name": "Acc",
      "id": "id",
      "description": "Term identifier."
    }, {
      "id": "annotation_class",
      "display_name": "Term",
      "description": "Term identifier.",
      "required": "false",
      "transform": [],
      "property": ["getIdentifier"],
      "indexed": "true",
      "type": "string",
      "cardinality": "single",
      "searchable": "false"
    }, {
      "required": "false",
      "description": "Identifier.",
      "display_name": "Term",
      "id": "annotation_class_label",
      "searchable": "true",
      "cardinality": "single",
      "indexed": "true",
      "type": "string",
      "transform": [],
      "property": ["getLabel"]
    }, {
      "display_name": "Definition",
      "id": "description",
      "description": "Term definition.",
      "required": "false",
      "indexed": "true",
      "type": "string",
      "property": ["getDef"],
      "transform": [],
      "searchable": "true",
      "cardinality": "single"
    }, {
      "required": "false",
      "display_name": "Ontology source",
      "id": "source",
      "description": "Term namespace. In GO, this is one of: biological_process, molecular_function, cellular_component. In other ontologies it is not guaranteed to be populated. Consider using idspace instead for general queries.",
      "cardinality": "single",
      "searchable": "false",
      "property": ["getNamespace"],
      "transform": [],
      "type": "string",
      "indexed": "true"
    }, {
      "required": "false",
      "display_name": "Ontology ID space",
      "id": "idspace",
      "description": "Term ID space.",
      "searchable": "false",
      "cardinality": "single",
      "indexed": "true",
      "type": "string",
      "property": ["getIdSpace"],
      "transform": []
    }, {
      "description": "Is the term obsolete?",
      "display_name": "Obsoletion",
      "id": "is_obsolete",
      "required": "false",
      "property": ["getIsObsoleteBinaryString"],
      "transform": [],
      "type": "boolean",
      "indexed": "true",
      "cardinality": "single",
      "searchable": "false"
    }, {
      "description": "Term comments.",
      "id": "comment",
      "display_name": "Comments",
      "required": "false",
      "property": ["getComments"],
      "transform": [],
      "type": "string",
      "indexed": "true",
      "cardinality": "multi",
      "searchable": "true"
    }, {
      "display_name": "Synonyms",
      "id": "synonym",
      "description": "Term synonyms.",
      "required": "false",
      "transform": [],
      "property": ["getOBOSynonymStrings"],
      "indexed": "true",
      "type": "string",
      "cardinality": "multi",
      "searchable": "true"
    }, {
      "id": "alternate_id",
      "display_name": "Alt ID",
      "description": "Alternate term identifier.",
      "required": "false",
      "transform": [],
      "property": ["getAnnotationPropertyValues", "alt_id"],
      "indexed": "true",
      "type": "string",
      "cardinality": "multi",
      "searchable": "false"
    }, {
      "transform": [],
      "property": ["getAnnotationPropertyValues", "replaced_by"],
      "indexed": "true",
      "type": "string",
      "cardinality": "multi",
      "searchable": "false",
      "description": "Term that replaces this term.",
      "display_name": "Replaced By",
      "id": "replaced_by",
      "required": "false"
    }, {
      "id": "consider",
      "display_name": "Consider",
      "description": "Others terms you might want to look at.",
      "required": "false",
      "type": "string",
      "indexed": "true",
      "transform": [],
      "property": ["getAnnotationPropertyValues", "consider"],
      "searchable": "false",
      "cardinality": "multi"
    }, {
      "required": "false",
      "description": "Special use collections of terms.",
      "display_name": "Subset",
      "id": "subset",
      "cardinality": "multi",
      "searchable": "false",
      "property": ["getSubsets"],
      "transform": [],
      "indexed": "true",
      "type": "string"
    }, {
      "description": "Definition cross-reference.",
      "id": "definition_xref",
      "display_name": "Def xref",
      "required": "false",
      "type": "string",
      "indexed": "true",
      "transform": [],
      "property": ["getDefXref"],
      "searchable": "false",
      "cardinality": "multi"
    }, {
      "description": "Database cross-reference.",
      "display_name": "DB xref",
      "id": "database_xref",
      "required": "false",
      "indexed": "true",
      "type": "string",
      "property": ["getXref"],
      "transform": [],
      "searchable": "false",
      "cardinality": "multi"
    }, {
      "display_name": "Is-a/part-of",
      "id": "isa_partof_closure",
      "description": "Ancestral terms (is_a/part_of).",
      "required": "false",
      "transform": [],
      "property": ["getRelationIDClosure", "BFO:0000050"],
      "type": "string",
      "indexed": "true",
      "cardinality": "multi",
      "searchable": "false"
    }, {
      "property": ["getRelationLabelClosure", "BFO:0000050"],
      "transform": [],
      "indexed": "true",
      "type": "string",
      "cardinality": "multi",
      "searchable": "true",
      "id": "isa_partof_closure_label",
      "display_name": "Is-a/part-of",
      "description": "Ancestral terms (is_a/part_of).",
      "required": "false"
    }, {
      "transform": [],
      "property": ["getRelationIDClosure"],
      "type": "string",
      "indexed": "true",
      "cardinality": "multi",
      "searchable": "false",
      "display_name": "Is-a",
      "id": "isa_closure",
      "description": "Ancestral terms (is_a).",
      "required": "false"
    }, {
      "cardinality": "multi",
      "searchable": "true",
      "transform": [],
      "property": ["getRelationLabelClosure"],
      "indexed": "true",
      "type": "string",
      "required": "false",
      "id": "isa_closure_label",
      "display_name": "Is-a",
      "description": "Ancestral terms (is_a) labels."
    }, {
      "required": "false",
      "display_name": "Ancestor",
      "id": "regulates_closure",
      "description": "Ancestral terms (regulates, occurs in, capable_of).",
      "searchable": "false",
      "cardinality": "multi",
      "indexed": "true",
      "type": "string",
      "property": ["getRelationIDClosure", "BFO:0000050", "BFO:0000066", "RO:0002211", "RO:0002212", "RO:0002213", "RO:0002215", "RO:0002216"],
      "transform": []
    }, {
      "required": "false",
      "display_name": "Ancestor",
      "id": "regulates_closure_label",
      "description": "Ancestral terms (regulates, occurs in, capable_of).",
      "cardinality": "multi",
      "searchable": "true",
      "property": ["getRelationLabelClosure", "BFO:0000050", "BFO:0000066", "RO:0002211", "RO:0002212", "RO:0002213", "RO:0002215", "RO:0002216"],
      "transform": [],
      "type": "string",
      "indexed": "true"
    }, {
      "display_name": "Topology graph (JSON)",
      "id": "topology_graph_json",
      "description": "JSON blob form of the local stepwise topology graph. Uses various relations (including regulates, occurs in, capable_of).",
      "required": "false",
      "property": ["getSegmentShuntGraphJSON", "BFO:0000050", "BFO:0000066", "RO:0002211", "RO:0002212", "RO:0002213", "RO:0002215", "RO:0002216"],
      "transform": [],
      "indexed": "false",
      "type": "string",
      "cardinality": "single",
      "searchable": "false"
    }, {
      "property": ["getLineageShuntGraphJSON", "BFO:0000050", "BFO:0000066", "RO:0002211", "RO:0002212", "RO:0002213", "RO:0002215", "RO:0002216"],
      "transform": [],
      "indexed": "false",
      "type": "string",
      "cardinality": "single",
      "searchable": "false",
      "display_name": "Regulates transitivity graph (JSON)",
      "id": "regulates_transitivity_graph_json",
      "description": "JSON blob form of the local relation transitivity graph. Uses various relations (including regulates, occurs in, capable_of).",
      "required": "false"
    }, {
      "cardinality": "single",
      "searchable": "false",
      "property": ["getLineageShuntGraphJSON", "BFO:0000050"],
      "transform": [],
      "type": "string",
      "indexed": "false",
      "required": "false",
      "display_name": "Isa-partof transitivity graph (JSON)",
      "id": "isa_partof_transitivity_graph_json",
      "description": "JSON blob form of the local relation transitivity graph."
    }, {
      "property": ["getNeighborsJSON"],
      "transform": [],
      "type": "string",
      "indexed": "false",
      "cardinality": "single",
      "searchable": "false",
      "display_name": "Term neighborhood graph (JSON)",
      "id": "neighborhood_graph_json",
      "description": "JSON blob form of all immediate neighbors of the term.",
      "required": "false"
    }, {
      "description": "JSON blob form of all immediate neighbors of the term; in the case that there are too many neighbors to transport, the number will be artificially reduced.",
      "id": "neighborhood_limited_graph_json",
      "display_name": "Term neighborhood limited graph (JSON)",
      "required": "false",
      "indexed": "false",
      "type": "string",
      "property": ["getNeighborsLimitedJSON"],
      "transform": [],
      "searchable": "false",
      "cardinality": "single"
    }, {
      "display_name": "Only in taxon",
      "id": "only_in_taxon",
      "description": "Only in taxon.",
      "required": "false",
      "property": ["getDummyString"],
      "transform": [],
      "indexed": "true",
      "type": "string",
      "cardinality": "single",
      "searchable": "true"
    }, {
      "required": "false",
      "id": "only_in_taxon_label",
      "display_name": "Only in taxon",
      "description": "Only in taxon label.",
      "searchable": "true",
      "cardinality": "single",
      "indexed": "true",
      "type": "string",
      "transform": [],
      "property": ["getDummyString"]
    }, {
      "required": "false",
      "id": "only_in_taxon_closure",
      "display_name": "Only in taxon (IDs)",
      "description": "Only in taxon closure.",
      "cardinality": "multi",
      "searchable": "false",
      "transform": [],
      "property": ["getDummyStrings"],
      "indexed": "true",
      "type": "string"
    }, {
      "description": "Only in taxon label closure.",
      "id": "only_in_taxon_closure_label",
      "display_name": "Only in taxon",
      "required": "false",
      "type": "string",
      "indexed": "true",
      "transform": [],
      "property": ["getDummyStrings"],
      "searchable": "true",
      "cardinality": "multi"
    }, {
      "transform": [],
      "property": ["getDummyString"],
      "indexed": "true",
      "type": "string",
      "cardinality": "single",
      "searchable": "false",
      "display_name": "Annotation extension",
      "id": "annotation_extension_owl_json",
      "description": "A non-lossy representation of conjunctions and disjunctions in c16 (JSON).",
      "required": "false"
    }, {
      "searchable": "false",
      "cardinality": "single",
      "type": "string",
      "indexed": "true",
      "transform": [],
      "property": ["getDummyString"],
      "required": "false",
      "id": "annotation_relation",
      "display_name": "Annotation relation",
      "description": "This is equivalent to the relation field in GPAD."
    }, {
      "description": "This is equivalent to the relation field in GPAD.",
      "display_name": "Annotation relation",
      "id": "annotation_relation_label",
      "required": "false",
      "property": ["getDummyString"],
      "transform": [],
      "indexed": "true",
      "type": "string",
      "cardinality": "single",
      "searchable": "true"
    }, {
      "required": "false",
      "display_name": "Eq class expressions",
      "id": "equivalent_class_expressions_json",
      "description": "For any class document C, this will contain json(CE) for all axioms of form EquivalentClasses(C ... CE ....).",
      "cardinality": "single",
      "searchable": "false",
      "transform": [],
      "property": ["getDummyString"],
      "indexed": "true",
      "type": "string"
    }, {
      "required": "false",
      "description": "Disjoint classes.",
      "display_name": "Disjoint classes",
      "id": "disjoint_class_list",
      "cardinality": "multi",
      "searchable": "false",
      "transform": [],
      "property": ["getDummyStrings"],
      "indexed": "true",
      "type": "string"
    }, {
      "description": "Disjoint classes.",
      "id": "disjoint_class_list_label",
      "display_name": "Disjoint classes",
      "required": "false",
      "indexed": "true",
      "type": "string",
      "property": ["getDummyStrings"],
      "transform": [],
      "searchable": "true",
      "cardinality": "multi"
    }],
    "fields_hash": {
      "description": {
        "display_name": "Definition",
        "id": "description",
        "description": "Term definition.",
        "required": "false",
        "indexed": "true",
        "type": "string",
        "property": ["getDef"],
        "transform": [],
        "searchable": "true",
        "cardinality": "single"
      },
      "database_xref": {
        "description": "Database cross-reference.",
        "display_name": "DB xref",
        "id": "database_xref",
        "required": "false",
        "indexed": "true",
        "type": "string",
        "property": ["getXref"],
        "transform": [],
        "searchable": "false",
        "cardinality": "multi"
      },
      "source": {
        "required": "false",
        "display_name": "Ontology source",
        "id": "source",
        "description": "Term namespace. In GO, this is one of: biological_process, molecular_function, cellular_component. In other ontologies it is not guaranteed to be populated. Consider using idspace instead for general queries.",
        "cardinality": "single",
        "searchable": "false",
        "property": ["getNamespace"],
        "transform": [],
        "type": "string",
        "indexed": "true"
      },
      "idspace": {
        "required": "false",
        "display_name": "Ontology ID space",
        "id": "idspace",
        "description": "Term ID space.",
        "searchable": "false",
        "cardinality": "single",
        "indexed": "true",
        "type": "string",
        "property": ["getIdSpace"],
        "transform": []
      },
      "comment": {
        "description": "Term comments.",
        "id": "comment",
        "display_name": "Comments",
        "required": "false",
        "property": ["getComments"],
        "transform": [],
        "type": "string",
        "indexed": "true",
        "cardinality": "multi",
        "searchable": "true"
      },
      "disjoint_class_list_label": {
        "description": "Disjoint classes.",
        "id": "disjoint_class_list_label",
        "display_name": "Disjoint classes",
        "required": "false",
        "indexed": "true",
        "type": "string",
        "property": ["getDummyStrings"],
        "transform": [],
        "searchable": "true",
        "cardinality": "multi"
      },
      "synonym": {
        "display_name": "Synonyms",
        "id": "synonym",
        "description": "Term synonyms.",
        "required": "false",
        "transform": [],
        "property": ["getOBOSynonymStrings"],
        "indexed": "true",
        "type": "string",
        "cardinality": "multi",
        "searchable": "true"
      },
      "equivalent_class_expressions_json": {
        "required": "false",
        "display_name": "Eq class expressions",
        "id": "equivalent_class_expressions_json",
        "description": "For any class document C, this will contain json(CE) for all axioms of form EquivalentClasses(C ... CE ....).",
        "cardinality": "single",
        "searchable": "false",
        "transform": [],
        "property": ["getDummyString"],
        "indexed": "true",
        "type": "string"
      },
      "is_obsolete": {
        "description": "Is the term obsolete?",
        "display_name": "Obsoletion",
        "id": "is_obsolete",
        "required": "false",
        "property": ["getIsObsoleteBinaryString"],
        "transform": [],
        "type": "boolean",
        "indexed": "true",
        "cardinality": "single",
        "searchable": "false"
      },
      "regulates_closure_label": {
        "required": "false",
        "display_name": "Ancestor",
        "id": "regulates_closure_label",
        "description": "Ancestral terms (regulates, occurs in, capable_of).",
        "cardinality": "multi",
        "searchable": "true",
        "property": ["getRelationLabelClosure", "BFO:0000050", "BFO:0000066", "RO:0002211", "RO:0002212", "RO:0002213", "RO:0002215", "RO:0002216"],
        "transform": [],
        "type": "string",
        "indexed": "true"
      },
      "id": {
        "searchable": "false",
        "cardinality": "single",
        "type": "string",
        "indexed": "true",
        "transform": [],
        "property": ["getIdentifier"],
        "required": "false",
        "display_name": "Acc",
        "id": "id",
        "description": "Term identifier."
      },
      "annotation_extension_owl_json": {
        "transform": [],
        "property": ["getDummyString"],
        "indexed": "true",
        "type": "string",
        "cardinality": "single",
        "searchable": "false",
        "display_name": "Annotation extension",
        "id": "annotation_extension_owl_json",
        "description": "A non-lossy representation of conjunctions and disjunctions in c16 (JSON).",
        "required": "false"
      },
      "only_in_taxon_closure": {
        "required": "false",
        "id": "only_in_taxon_closure",
        "display_name": "Only in taxon (IDs)",
        "description": "Only in taxon closure.",
        "cardinality": "multi",
        "searchable": "false",
        "transform": [],
        "property": ["getDummyStrings"],
        "indexed": "true",
        "type": "string"
      },
      "annotation_class": {
        "id": "annotation_class",
        "display_name": "Term",
        "description": "Term identifier.",
        "required": "false",
        "transform": [],
        "property": ["getIdentifier"],
        "indexed": "true",
        "type": "string",
        "cardinality": "single",
        "searchable": "false"
      },
      "isa_partof_closure": {
        "display_name": "Is-a/part-of",
        "id": "isa_partof_closure",
        "description": "Ancestral terms (is_a/part_of).",
        "required": "false",
        "transform": [],
        "property": ["getRelationIDClosure", "BFO:0000050"],
        "type": "string",
        "indexed": "true",
        "cardinality": "multi",
        "searchable": "false"
      },
      "annotation_relation_label": {
        "description": "This is equivalent to the relation field in GPAD.",
        "display_name": "Annotation relation",
        "id": "annotation_relation_label",
        "required": "false",
        "property": ["getDummyString"],
        "transform": [],
        "indexed": "true",
        "type": "string",
        "cardinality": "single",
        "searchable": "true"
      },
      "isa_partof_transitivity_graph_json": {
        "cardinality": "single",
        "searchable": "false",
        "property": ["getLineageShuntGraphJSON", "BFO:0000050"],
        "transform": [],
        "type": "string",
        "indexed": "false",
        "required": "false",
        "display_name": "Isa-partof transitivity graph (JSON)",
        "id": "isa_partof_transitivity_graph_json",
        "description": "JSON blob form of the local relation transitivity graph."
      },
      "topology_graph_json": {
        "display_name": "Topology graph (JSON)",
        "id": "topology_graph_json",
        "description": "JSON blob form of the local stepwise topology graph. Uses various relations (including regulates, occurs in, capable_of).",
        "required": "false",
        "property": ["getSegmentShuntGraphJSON", "BFO:0000050", "BFO:0000066", "RO:0002211", "RO:0002212", "RO:0002213", "RO:0002215", "RO:0002216"],
        "transform": [],
        "indexed": "false",
        "type": "string",
        "cardinality": "single",
        "searchable": "false"
      },
      "definition_xref": {
        "description": "Definition cross-reference.",
        "id": "definition_xref",
        "display_name": "Def xref",
        "required": "false",
        "type": "string",
        "indexed": "true",
        "transform": [],
        "property": ["getDefXref"],
        "searchable": "false",
        "cardinality": "multi"
      },
      "only_in_taxon_label": {
        "required": "false",
        "id": "only_in_taxon_label",
        "display_name": "Only in taxon",
        "description": "Only in taxon label.",
        "searchable": "true",
        "cardinality": "single",
        "indexed": "true",
        "type": "string",
        "transform": [],
        "property": ["getDummyString"]
      },
      "isa_closure_label": {
        "cardinality": "multi",
        "searchable": "true",
        "transform": [],
        "property": ["getRelationLabelClosure"],
        "indexed": "true",
        "type": "string",
        "required": "false",
        "id": "isa_closure_label",
        "display_name": "Is-a",
        "description": "Ancestral terms (is_a) labels."
      },
      "subset": {
        "required": "false",
        "description": "Special use collections of terms.",
        "display_name": "Subset",
        "id": "subset",
        "cardinality": "multi",
        "searchable": "false",
        "property": ["getSubsets"],
        "transform": [],
        "indexed": "true",
        "type": "string"
      },
      "only_in_taxon_closure_label": {
        "description": "Only in taxon label closure.",
        "id": "only_in_taxon_closure_label",
        "display_name": "Only in taxon",
        "required": "false",
        "type": "string",
        "indexed": "true",
        "transform": [],
        "property": ["getDummyStrings"],
        "searchable": "true",
        "cardinality": "multi"
      },
      "neighborhood_limited_graph_json": {
        "description": "JSON blob form of all immediate neighbors of the term; in the case that there are too many neighbors to transport, the number will be artificially reduced.",
        "id": "neighborhood_limited_graph_json",
        "display_name": "Term neighborhood limited graph (JSON)",
        "required": "false",
        "indexed": "false",
        "type": "string",
        "property": ["getNeighborsLimitedJSON"],
        "transform": [],
        "searchable": "false",
        "cardinality": "single"
      },
      "annotation_class_label": {
        "required": "false",
        "description": "Identifier.",
        "display_name": "Term",
        "id": "annotation_class_label",
        "searchable": "true",
        "cardinality": "single",
        "indexed": "true",
        "type": "string",
        "transform": [],
        "property": ["getLabel"]
      },
      "isa_closure": {
        "transform": [],
        "property": ["getRelationIDClosure"],
        "type": "string",
        "indexed": "true",
        "cardinality": "multi",
        "searchable": "false",
        "display_name": "Is-a",
        "id": "isa_closure",
        "description": "Ancestral terms (is_a).",
        "required": "false"
      },
      "regulates_closure": {
        "required": "false",
        "display_name": "Ancestor",
        "id": "regulates_closure",
        "description": "Ancestral terms (regulates, occurs in, capable_of).",
        "searchable": "false",
        "cardinality": "multi",
        "indexed": "true",
        "type": "string",
        "property": ["getRelationIDClosure", "BFO:0000050", "BFO:0000066", "RO:0002211", "RO:0002212", "RO:0002213", "RO:0002215", "RO:0002216"],
        "transform": []
      },
      "replaced_by": {
        "transform": [],
        "property": ["getAnnotationPropertyValues", "replaced_by"],
        "indexed": "true",
        "type": "string",
        "cardinality": "multi",
        "searchable": "false",
        "description": "Term that replaces this term.",
        "display_name": "Replaced By",
        "id": "replaced_by",
        "required": "false"
      },
      "regulates_transitivity_graph_json": {
        "property": ["getLineageShuntGraphJSON", "BFO:0000050", "BFO:0000066", "RO:0002211", "RO:0002212", "RO:0002213", "RO:0002215", "RO:0002216"],
        "transform": [],
        "indexed": "false",
        "type": "string",
        "cardinality": "single",
        "searchable": "false",
        "display_name": "Regulates transitivity graph (JSON)",
        "id": "regulates_transitivity_graph_json",
        "description": "JSON blob form of the local relation transitivity graph. Uses various relations (including regulates, occurs in, capable_of).",
        "required": "false"
      },
      "disjoint_class_list": {
        "required": "false",
        "description": "Disjoint classes.",
        "display_name": "Disjoint classes",
        "id": "disjoint_class_list",
        "cardinality": "multi",
        "searchable": "false",
        "transform": [],
        "property": ["getDummyStrings"],
        "indexed": "true",
        "type": "string"
      },
      "neighborhood_graph_json": {
        "property": ["getNeighborsJSON"],
        "transform": [],
        "type": "string",
        "indexed": "false",
        "cardinality": "single",
        "searchable": "false",
        "display_name": "Term neighborhood graph (JSON)",
        "id": "neighborhood_graph_json",
        "description": "JSON blob form of all immediate neighbors of the term.",
        "required": "false"
      },
      "annotation_relation": {
        "searchable": "false",
        "cardinality": "single",
        "type": "string",
        "indexed": "true",
        "transform": [],
        "property": ["getDummyString"],
        "required": "false",
        "id": "annotation_relation",
        "display_name": "Annotation relation",
        "description": "This is equivalent to the relation field in GPAD."
      },
      "alternate_id": {
        "id": "alternate_id",
        "display_name": "Alt ID",
        "description": "Alternate term identifier.",
        "required": "false",
        "transform": [],
        "property": ["getAnnotationPropertyValues", "alt_id"],
        "indexed": "true",
        "type": "string",
        "cardinality": "multi",
        "searchable": "false"
      },
      "only_in_taxon": {
        "display_name": "Only in taxon",
        "id": "only_in_taxon",
        "description": "Only in taxon.",
        "required": "false",
        "property": ["getDummyString"],
        "transform": [],
        "indexed": "true",
        "type": "string",
        "cardinality": "single",
        "searchable": "true"
      },
      "consider": {
        "id": "consider",
        "display_name": "Consider",
        "description": "Others terms you might want to look at.",
        "required": "false",
        "type": "string",
        "indexed": "true",
        "transform": [],
        "property": ["getAnnotationPropertyValues", "consider"],
        "searchable": "false",
        "cardinality": "multi"
      },
      "isa_partof_closure_label": {
        "property": ["getRelationLabelClosure", "BFO:0000050"],
        "transform": [],
        "indexed": "true",
        "type": "string",
        "cardinality": "multi",
        "searchable": "true",
        "id": "isa_partof_closure_label",
        "display_name": "Is-a/part-of",
        "description": "Ancestral terms (is_a/part_of).",
        "required": "false"
      }
    },
    "searchable_extension": "_searchable"
  },
  "noctua_model_meta": {
    "id": "noctua_model_meta",
    "schema_generating": "true",
    "display_name": "Noctua meta",
    "description": "A generic capture of light Noctua metadata in realtime.",
    "weight": "0",
    "result_weights": "annotation_unit^3.0 contributor^2.0 model_state^1.0 model_date^1.0 comment^1.0",
    "filter_weights": "contributor^3.0 model_state^2.0 model_date^1.0",
    "_outfile": "/home/bbop/local/src/git/amigo/metadata/noctua-model-meta-config.yaml",
    "_strict": 0,
    "_infile": "/home/bbop/local/src/git/amigo/metadata/noctua-model-meta-config.yaml",
    "searchable_extension": "_searchable",
    "fields_hash": {
      "annotation_unit_label": {
        "property": [],
        "transform": [],
        "indexed": "true",
        "type": "string",
        "cardinality": "single",
        "searchable": "true",
        "id": "annotation_unit_label",
        "display_name": "Model identifier",
        "description": "The title(s) associated with the model.",
        "required": "false"
      },
      "model_date": {
        "description": "Model last modification dates.",
        "id": "model_date",
        "display_name": "Last modified",
        "required": "false",
        "indexed": "true",
        "type": "string",
        "transform": [],
        "property": [],
        "searchable": "true",
        "cardinality": "single"
      },
      "id": {
        "searchable": "false",
        "cardinality": "single",
        "indexed": "true",
        "type": "string",
        "property": [],
        "transform": [],
        "required": "false",
        "id": "id",
        "display_name": "Internal ID",
        "description": "The mangled internal ID for this entity."
      },
      "owl_blob_json": {
        "description": "???",
        "display_name": "???",
        "id": "owl_blob_json",
        "required": "false",
        "property": [],
        "transform": [],
        "indexed": "false",
        "type": "string",
        "cardinality": "single",
        "searchable": "false"
      },
      "model_state": {
        "description": "The editorial state of the model.",
        "id": "model_state",
        "display_name": "State",
        "required": "false",
        "property": [],
        "transform": [],
        "type": "string",
        "indexed": "true",
        "cardinality": "single",
        "searchable": "false"
      },
      "contributor": {
        "type": "string",
        "indexed": "true",
        "transform": [],
        "property": [],
        "searchable": "true",
        "cardinality": "multi",
        "description": "Contributor identity.",
        "id": "contributor",
        "display_name": "Contributor",
        "required": "false"
      },
      "comment": {
        "searchable": "true",
        "cardinality": "single",
        "type": "string",
        "indexed": "true",
        "property": [],
        "transform": [],
        "required": "false",
        "description": "The comments associated with a model.",
        "display_name": "Comment",
        "id": "comment"
      },
      "annotation_unit": {
        "indexed": "true",
        "type": "string",
        "transform": [],
        "property": [],
        "searchable": "false",
        "cardinality": "single",
        "display_name": "Model identifier",
        "id": "annotation_unit",
        "description": "The title(s) associated with the model.",
        "required": "false"
      }
    },
    "fields": [{
      "searchable": "false",
      "cardinality": "single",
      "indexed": "true",
      "type": "string",
      "property": [],
      "transform": [],
      "required": "false",
      "id": "id",
      "display_name": "Internal ID",
      "description": "The mangled internal ID for this entity."
    }, {
      "indexed": "true",
      "type": "string",
      "transform": [],
      "property": [],
      "searchable": "false",
      "cardinality": "single",
      "display_name": "Model identifier",
      "id": "annotation_unit",
      "description": "The title(s) associated with the model.",
      "required": "false"
    }, {
      "property": [],
      "transform": [],
      "indexed": "true",
      "type": "string",
      "cardinality": "single",
      "searchable": "true",
      "id": "annotation_unit_label",
      "display_name": "Model identifier",
      "description": "The title(s) associated with the model.",
      "required": "false"
    }, {
      "type": "string",
      "indexed": "true",
      "transform": [],
      "property": [],
      "searchable": "true",
      "cardinality": "multi",
      "description": "Contributor identity.",
      "id": "contributor",
      "display_name": "Contributor",
      "required": "false"
    }, {
      "description": "Model last modification dates.",
      "id": "model_date",
      "display_name": "Last modified",
      "required": "false",
      "indexed": "true",
      "type": "string",
      "transform": [],
      "property": [],
      "searchable": "true",
      "cardinality": "single"
    }, {
      "description": "The editorial state of the model.",
      "id": "model_state",
      "display_name": "State",
      "required": "false",
      "property": [],
      "transform": [],
      "type": "string",
      "indexed": "true",
      "cardinality": "single",
      "searchable": "false"
    }, {
      "searchable": "true",
      "cardinality": "single",
      "type": "string",
      "indexed": "true",
      "property": [],
      "transform": [],
      "required": "false",
      "description": "The comments associated with a model.",
      "display_name": "Comment",
      "id": "comment"
    }, {
      "description": "???",
      "display_name": "???",
      "id": "owl_blob_json",
      "required": "false",
      "property": [],
      "transform": [],
      "indexed": "false",
      "type": "string",
      "cardinality": "single",
      "searchable": "false"
    }],
    "document_category": "noctua_model_meta",
    "boost_weights": "annotation_unit_label^3.0 contributor^2.0 model_date^1.0 comment^1.0"
  },
  "family": {
    "_infile": "/home/bbop/local/src/git/amigo/metadata/protein-family-config.yaml",
    "_strict": 0,
    "_outfile": "/home/bbop/local/src/git/amigo/metadata/protein-family-config.yaml",
    "filter_weights": "bioentity_list_label^1.0",
    "result_weights": "panther_family^5.0 bioentity_list^4.0",
    "description": "Information about protein (PANTHER) families.",
    "weight": "5",
    "display_name": "Protein families",
    "schema_generating": "true",
    "id": "family",
    "boost_weights": "panther_family^2.0 panther_family_label^2.0 bioentity_list^1.0 bioentity_list_label^1.0",
    "document_category": "family",
    "fields": [{
      "transform": [],
      "property": [],
      "indexed": "true",
      "type": "string",
      "cardinality": "single",
      "searchable": "false",
      "description": "Family ID.",
      "id": "id",
      "display_name": "Acc",
      "required": "false"
    }, {
      "required": "false",
      "id": "panther_family",
      "display_name": "PANTHER family",
      "description": "PANTHER family IDs that are associated with this entity.",
      "cardinality": "single",
      "searchable": "true",
      "property": [],
      "transform": [],
      "type": "string",
      "indexed": "true"
    }, {
      "cardinality": "single",
      "searchable": "true",
      "transform": [],
      "property": [],
      "indexed": "true",
      "type": "string",
      "required": "false",
      "id": "panther_family_label",
      "display_name": "PANTHER family",
      "description": "PANTHER families that are associated with this entity."
    }, {
      "required": "false",
      "id": "phylo_graph_json",
      "display_name": "This should not be displayed",
      "description": "JSON blob form of the phylogenic tree.",
      "cardinality": "single",
      "searchable": "false",
      "transform": [],
      "property": [],
      "type": "string",
      "indexed": "false"
    }, {
      "type": "string",
      "indexed": "true",
      "transform": [],
      "property": [],
      "searchable": "false",
      "cardinality": "multi",
      "display_name": "Gene/products",
      "id": "bioentity_list",
      "description": "Gene/products annotated with this protein family.",
      "required": "false"
    }, {
      "indexed": "true",
      "type": "string",
      "transform": [],
      "property": [],
      "searchable": "false",
      "cardinality": "multi",
      "description": "Gene/products annotated with this protein family.",
      "display_name": "Gene/products",
      "id": "bioentity_list_label",
      "required": "false"
    }],
    "fields_hash": {
      "phylo_graph_json": {
        "required": "false",
        "id": "phylo_graph_json",
        "display_name": "This should not be displayed",
        "description": "JSON blob form of the phylogenic tree.",
        "cardinality": "single",
        "searchable": "false",
        "transform": [],
        "property": [],
        "type": "string",
        "indexed": "false"
      },
      "bioentity_list_label": {
        "indexed": "true",
        "type": "string",
        "transform": [],
        "property": [],
        "searchable": "false",
        "cardinality": "multi",
        "description": "Gene/products annotated with this protein family.",
        "display_name": "Gene/products",
        "id": "bioentity_list_label",
        "required": "false"
      },
      "id": {
        "transform": [],
        "property": [],
        "indexed": "true",
        "type": "string",
        "cardinality": "single",
        "searchable": "false",
        "description": "Family ID.",
        "id": "id",
        "display_name": "Acc",
        "required": "false"
      },
      "bioentity_list": {
        "type": "string",
        "indexed": "true",
        "transform": [],
        "property": [],
        "searchable": "false",
        "cardinality": "multi",
        "display_name": "Gene/products",
        "id": "bioentity_list",
        "description": "Gene/products annotated with this protein family.",
        "required": "false"
      },
      "panther_family_label": {
        "cardinality": "single",
        "searchable": "true",
        "transform": [],
        "property": [],
        "indexed": "true",
        "type": "string",
        "required": "false",
        "id": "panther_family_label",
        "display_name": "PANTHER family",
        "description": "PANTHER families that are associated with this entity."
      },
      "panther_family": {
        "required": "false",
        "id": "panther_family",
        "display_name": "PANTHER family",
        "description": "PANTHER family IDs that are associated with this entity.",
        "cardinality": "single",
        "searchable": "true",
        "property": [],
        "transform": [],
        "type": "string",
        "indexed": "true"
      }
    },
    "searchable_extension": "_searchable"
  },
  "annotation_for_browser": {
    "_infile": "/home/bbop/local/src/git/amigo/metadata/ann-config.browse.yaml",
    "schema_generating": "false",
    "display_name": "Annotations (BROWSER)",
    "id": "annotation_for_browser",
    "description": "Special schema for certain ontology browser widget\\'s filters.",
    "result_weights": "taxon_subset_closure_label^9.0 evidence_type_closure^8.0",
    "weight": "-120",
    "filter_weights": "taxon_subset_closure_label^9.0 evidence_type_closure^8.0",
    "_outfile": "/home/bbop/local/src/git/amigo/metadata/ann-config.browse.yaml",
    "_strict": 0,
    "fields_hash": {
      "taxon": {
        "transform": [],
        "property": [],
        "type": "string",
        "indexed": "true",
        "cardinality": "single",
        "searchable": "false",
        "description": "Taxonomic group.",
        "id": "taxon",
        "display_name": "Organism",
        "required": "false"
      },
      "taxon_label": {
        "description": "Taxonomic group and ancestral groups.",
        "id": "taxon_label",
        "display_name": "Organism",
        "required": "false",
        "type": "string",
        "indexed": "true",
        "property": [],
        "transform": [],
        "searchable": "true",
        "cardinality": "single"
      },
      "taxon_closure_label": {
        "required": "false",
        "display_name": "Organism",
        "id": "taxon_closure_label",
        "description": "Taxonomic group and ancestral groups.",
        "searchable": "true",
        "cardinality": "multi",
        "indexed": "true",
        "type": "string",
        "transform": [],
        "property": []
      },
      "evidence_type": {
        "property": [],
        "transform": [],
        "type": "string",
        "indexed": "true",
        "cardinality": "single",
        "searchable": "false",
        "display_name": "Evidence",
        "id": "evidence_type",
        "description": "Evidence type.",
        "required": "false"
      },
      "taxon_closure": {
        "description": "Taxonomic group and ancestral groups.",
        "display_name": "Organism",
        "id": "taxon_closure",
        "required": "false",
        "type": "string",
        "indexed": "true",
        "property": [],
        "transform": [],
        "searchable": "false",
        "cardinality": "multi"
      },
      "taxon_subset_closure": {
        "cardinality": "multi",
        "searchable": "false",
        "property": [],
        "transform": [],
        "indexed": "true",
        "type": "string",
        "required": "false",
        "id": "taxon_subset_closure",
        "display_name": "Organism",
        "description": "Taxonomic group (direct) and ancestral groups that are within the specified subset (e.g mammalia, eukaryota)."
      },
      "evidence_type_closure": {
        "required": "false",
        "display_name": "Evidence type",
        "id": "evidence_type_closure",
        "description": "All evidence (evidence closure) for this annotation",
        "searchable": "false",
        "cardinality": "multi",
        "indexed": "true",
        "type": "string",
        "property": [],
        "transform": []
      },
      "taxon_subset_closure_label": {
        "searchable": "true",
        "cardinality": "multi",
        "indexed": "true",
        "type": "string",
        "property": [],
        "transform": [],
        "required": "false",
        "display_name": "Organism",
        "id": "taxon_subset_closure_label",
        "description": "Labels for taxonomic group (direct) and ancestral groups that are within the specified subset."
      }
    },
    "fields": [{
      "transform": [],
      "property": [],
      "type": "string",
      "indexed": "true",
      "cardinality": "single",
      "searchable": "false",
      "description": "Taxonomic group.",
      "id": "taxon",
      "display_name": "Organism",
      "required": "false"
    }, {
      "description": "Taxonomic group and ancestral groups.",
      "id": "taxon_label",
      "display_name": "Organism",
      "required": "false",
      "type": "string",
      "indexed": "true",
      "property": [],
      "transform": [],
      "searchable": "true",
      "cardinality": "single"
    }, {
      "description": "Taxonomic group and ancestral groups.",
      "display_name": "Organism",
      "id": "taxon_closure",
      "required": "false",
      "type": "string",
      "indexed": "true",
      "property": [],
      "transform": [],
      "searchable": "false",
      "cardinality": "multi"
    }, {
      "required": "false",
      "display_name": "Organism",
      "id": "taxon_closure_label",
      "description": "Taxonomic group and ancestral groups.",
      "searchable": "true",
      "cardinality": "multi",
      "indexed": "true",
      "type": "string",
      "transform": [],
      "property": []
    }, {
      "cardinality": "multi",
      "searchable": "false",
      "property": [],
      "transform": [],
      "indexed": "true",
      "type": "string",
      "required": "false",
      "id": "taxon_subset_closure",
      "display_name": "Organism",
      "description": "Taxonomic group (direct) and ancestral groups that are within the specified subset (e.g mammalia, eukaryota)."
    }, {
      "searchable": "true",
      "cardinality": "multi",
      "indexed": "true",
      "type": "string",
      "property": [],
      "transform": [],
      "required": "false",
      "display_name": "Organism",
      "id": "taxon_subset_closure_label",
      "description": "Labels for taxonomic group (direct) and ancestral groups that are within the specified subset."
    }, {
      "property": [],
      "transform": [],
      "type": "string",
      "indexed": "true",
      "cardinality": "single",
      "searchable": "false",
      "display_name": "Evidence",
      "id": "evidence_type",
      "description": "Evidence type.",
      "required": "false"
    }, {
      "required": "false",
      "display_name": "Evidence type",
      "id": "evidence_type_closure",
      "description": "All evidence (evidence closure) for this annotation",
      "searchable": "false",
      "cardinality": "multi",
      "indexed": "true",
      "type": "string",
      "property": [],
      "transform": []
    }],
    "document_category": "annotation",
    "boost_weights": "taxon_subset_closure_label^1.0 evidence_type_closure^1.0",
    "searchable_extension": "_searchable"
  },
  "bioentity_for_browser": {
    "fields_hash": {
      "source": {
        "cardinality": "single",
        "searchable": "false",
        "transform": [],
        "property": [],
        "type": "string",
        "indexed": "true",
        "required": "false",
        "id": "source",
        "display_name": "Source",
        "description": "Database source."
      },
      "taxon_closure": {
        "required": "false",
        "description": "Taxonomic group and ancestral groups.",
        "display_name": "Taxon",
        "id": "taxon_closure",
        "cardinality": "multi",
        "searchable": "false",
        "property": [],
        "transform": [],
        "indexed": "true",
        "type": "string"
      },
      "taxon_label": {
        "indexed": "true",
        "type": "string",
        "transform": [],
        "property": [],
        "searchable": "true",
        "cardinality": "single",
        "display_name": "Taxon",
        "id": "taxon_label",
        "description": "Taxonomic group",
        "required": "false"
      },
      "taxon": {
        "cardinality": "single",
        "searchable": "false",
        "property": [],
        "transform": [],
        "indexed": "true",
        "type": "string",
        "required": "false",
        "display_name": "Taxon",
        "id": "taxon",
        "description": "Taxonomic group"
      },
      "taxon_closure_label": {
        "description": "Taxonomic group and ancestral groups.",
        "display_name": "Taxon",
        "id": "taxon_closure_label",
        "required": "false",
        "indexed": "true",
        "type": "string",
        "property": [],
        "transform": [],
        "searchable": "true",
        "cardinality": "multi"
      },
      "taxon_subset_closure_label": {
        "cardinality": "multi",
        "searchable": "true",
        "transform": [],
        "property": [],
        "type": "string",
        "indexed": "true",
        "required": "false",
        "id": "taxon_subset_closure_label",
        "display_name": "Organism",
        "description": "Labels for taxonomic group (direct) and ancestral groups that are within the specified subset."
      },
      "taxon_subset_closure": {
        "type": "string",
        "indexed": "true",
        "transform": [],
        "property": [],
        "searchable": "false",
        "cardinality": "multi",
        "display_name": "Organism",
        "id": "taxon_subset_closure",
        "description": "Taxonomic group (direct) and ancestral groups that are within the specified subset (e.g mammalia, eukaryota).",
        "required": "false"
      },
      "type": {
        "description": "Type class.",
        "id": "type",
        "display_name": "Type",
        "required": "false",
        "property": [],
        "transform": [],
        "indexed": "true",
        "type": "string",
        "cardinality": "single",
        "searchable": "false"
      }
    },
    "boost_weights": "taxon_subset_closure_label^1.0 type^1.0",
    "document_category": "bioentity",
    "fields": [{
      "description": "Type class.",
      "id": "type",
      "display_name": "Type",
      "required": "false",
      "property": [],
      "transform": [],
      "indexed": "true",
      "type": "string",
      "cardinality": "single",
      "searchable": "false"
    }, {
      "cardinality": "single",
      "searchable": "false",
      "property": [],
      "transform": [],
      "indexed": "true",
      "type": "string",
      "required": "false",
      "display_name": "Taxon",
      "id": "taxon",
      "description": "Taxonomic group"
    }, {
      "indexed": "true",
      "type": "string",
      "transform": [],
      "property": [],
      "searchable": "true",
      "cardinality": "single",
      "display_name": "Taxon",
      "id": "taxon_label",
      "description": "Taxonomic group",
      "required": "false"
    }, {
      "required": "false",
      "description": "Taxonomic group and ancestral groups.",
      "display_name": "Taxon",
      "id": "taxon_closure",
      "cardinality": "multi",
      "searchable": "false",
      "property": [],
      "transform": [],
      "indexed": "true",
      "type": "string"
    }, {
      "description": "Taxonomic group and ancestral groups.",
      "display_name": "Taxon",
      "id": "taxon_closure_label",
      "required": "false",
      "indexed": "true",
      "type": "string",
      "property": [],
      "transform": [],
      "searchable": "true",
      "cardinality": "multi"
    }, {
      "type": "string",
      "indexed": "true",
      "transform": [],
      "property": [],
      "searchable": "false",
      "cardinality": "multi",
      "display_name": "Organism",
      "id": "taxon_subset_closure",
      "description": "Taxonomic group (direct) and ancestral groups that are within the specified subset (e.g mammalia, eukaryota).",
      "required": "false"
    }, {
      "cardinality": "multi",
      "searchable": "true",
      "transform": [],
      "property": [],
      "type": "string",
      "indexed": "true",
      "required": "false",
      "id": "taxon_subset_closure_label",
      "display_name": "Organism",
      "description": "Labels for taxonomic group (direct) and ancestral groups that are within the specified subset."
    }, {
      "cardinality": "single",
      "searchable": "false",
      "transform": [],
      "property": [],
      "type": "string",
      "indexed": "true",
      "required": "false",
      "id": "source",
      "display_name": "Source",
      "description": "Database source."
    }],
    "searchable_extension": "_searchable",
    "_infile": "/home/bbop/local/src/git/amigo/metadata/bio-config.browse.yaml",
    "description": "Special schema for certain ontology browser widget\\'s filters.",
    "weight": "-130",
    "result_weights": "taxon_subset_closure_label^8.0 type^6.0",
    "schema_generating": "false",
    "display_name": "Genes and gene products (BROWSER)",
    "id": "bioentity_for_browser",
    "_strict": 0,
    "filter_weights": "taxon_subset_closure_label^8.0 type^6.0",
    "_outfile": "/home/bbop/local/src/git/amigo/metadata/bio-config.browse.yaml"
  },
  "general": {
    "filter_weights": "category^4.0",
    "_outfile": "/home/bbop/local/src/git/amigo/metadata/general-config.yaml",
    "_strict": 0,
    "display_name": "General",
    "schema_generating": "true",
    "id": "general",
    "description": "A generic search document to get a general overview of everything.",
    "weight": "0",
    "result_weights": "entity^3.0 category^1.0",
    "_infile": "/home/bbop/local/src/git/amigo/metadata/general-config.yaml",
    "searchable_extension": "_searchable",
    "fields": [{
      "required": "false",
      "display_name": "Internal ID",
      "id": "id",
      "description": "The mangled internal ID for this entity.",
      "searchable": "false",
      "cardinality": "single",
      "type": "string",
      "indexed": "true",
      "transform": [],
      "property": []
    }, {
      "required": "false",
      "display_name": "Entity",
      "id": "entity",
      "description": "The ID/label for this entity.",
      "cardinality": "single",
      "searchable": "false",
      "property": [],
      "transform": [],
      "type": "string",
      "indexed": "true"
    }, {
      "searchable": "true",
      "cardinality": "single",
      "type": "string",
      "indexed": "true",
      "property": [],
      "transform": [],
      "required": "false",
      "description": "The label for this entity.",
      "display_name": "Enity label",
      "id": "entity_label"
    }, {
      "type": "string",
      "indexed": "true",
      "property": [],
      "transform": [],
      "searchable": "false",
      "cardinality": "single",
      "description": "The document category that this enitity belongs to.",
      "id": "category",
      "display_name": "Document category",
      "required": "false"
    }, {
      "searchable": "true",
      "cardinality": "single",
      "indexed": "true",
      "type": "string",
      "property": [],
      "transform": [],
      "required": "false",
      "id": "general_blob",
      "display_name": "Generic blob",
      "description": "A hidden searchable blob document to access this item. It should contain all the goodies that we want to search for, like species(?), synonyms, etc."
    }],
    "document_category": "general",
    "boost_weights": "entity^3.0 entity_label^3.0 general_blob^3.0",
    "fields_hash": {
      "entity_label": {
        "searchable": "true",
        "cardinality": "single",
        "type": "string",
        "indexed": "true",
        "property": [],
        "transform": [],
        "required": "false",
        "description": "The label for this entity.",
        "display_name": "Enity label",
        "id": "entity_label"
      },
      "entity": {
        "required": "false",
        "display_name": "Entity",
        "id": "entity",
        "description": "The ID/label for this entity.",
        "cardinality": "single",
        "searchable": "false",
        "property": [],
        "transform": [],
        "type": "string",
        "indexed": "true"
      },
      "general_blob": {
        "searchable": "true",
        "cardinality": "single",
        "indexed": "true",
        "type": "string",
        "property": [],
        "transform": [],
        "required": "false",
        "id": "general_blob",
        "display_name": "Generic blob",
        "description": "A hidden searchable blob document to access this item. It should contain all the goodies that we want to search for, like species(?), synonyms, etc."
      },
      "id": {
        "required": "false",
        "display_name": "Internal ID",
        "id": "id",
        "description": "The mangled internal ID for this entity.",
        "searchable": "false",
        "cardinality": "single",
        "type": "string",
        "indexed": "true",
        "transform": [],
        "property": []
      },
      "category": {
        "type": "string",
        "indexed": "true",
        "property": [],
        "transform": [],
        "searchable": "false",
        "cardinality": "single",
        "description": "The document category that this enitity belongs to.",
        "id": "category",
        "display_name": "Document category",
        "required": "false"
      }
    }
  },
  "model_annotation": {
    "fields_hash": {
      "model_state": {
        "property": [],
        "transform": [],
        "indexed": "true",
        "type": "string",
        "cardinality": "single",
        "searchable": "false",
        "display_name": "State",
        "id": "model_state",
        "description": "Curation status",
        "required": "false"
      },
      "location_list_closure_label": {
        "indexed": "true",
        "type": "string",
        "transform": [],
        "property": [],
        "searchable": "false",
        "cardinality": "multi",
        "description": "",
        "display_name": "Location",
        "id": "location_list_closure_label",
        "required": "false"
      },
      "topology_graph_json": {
        "searchable": "false",
        "cardinality": "single",
        "type": "string",
        "indexed": "false",
        "transform": [],
        "property": [],
        "required": "false",
        "display_name": "Topology graph (JSON)",
        "id": "topology_graph_json",
        "description": "JSON blob form of the local stepwise topology graph."
      },
      "taxon_closure": {
        "searchable": "false",
        "cardinality": "multi",
        "type": "string",
        "indexed": "true",
        "transform": [],
        "property": [],
        "required": "false",
        "id": "taxon_closure",
        "display_name": "Taxon (IDs)",
        "description": "is_a closure of taxon"
      },
      "contributor": {
        "cardinality": "multi",
        "searchable": "true",
        "property": [],
        "transform": [],
        "type": "string",
        "indexed": "true",
        "required": "false",
        "description": "Value of dc:contributor fields for the annoton",
        "id": "contributor",
        "display_name": "Contributor"
      },
      "annotation_value": {
        "searchable": "false",
        "cardinality": "multi",
        "type": "string",
        "indexed": "true",
        "property": [],
        "transform": [],
        "required": "false",
        "description": "set of all literal values of all annotation assertions in model",
        "display_name": "Text",
        "id": "annotation_value"
      },
      "model": {
        "required": "false",
        "display_name": "Model title",
        "id": "model",
        "description": "The CURIE of the model to which the annoton belongs",
        "searchable": "false",
        "cardinality": "single",
        "indexed": "true",
        "type": "string",
        "transform": [],
        "property": []
      },
      "enabled_by_label": {
        "required": "false",
        "description": "Searchable label version of the gene product",
        "id": "enabled_by_label",
        "display_name": "Enabled by label",
        "cardinality": "single",
        "searchable": "true",
        "transform": [],
        "property": [],
        "type": "string",
        "indexed": "true"
      },
      "evidence_type_closure_label": {
        "description": "All evidence (evidence closure) for this annotation",
        "id": "evidence_type_closure_label",
        "display_name": "Evidence type",
        "required": "false",
        "type": "string",
        "indexed": "true",
        "transform": [],
        "property": [],
        "searchable": "true",
        "cardinality": "multi"
      },
      "evidence_type": {
        "required": "false",
        "description": "Evidence type.",
        "display_name": "Evidence",
        "id": "evidence_type",
        "cardinality": "single",
        "searchable": "false",
        "transform": [],
        "property": [],
        "indexed": "true",
        "type": "string"
      },
      "process_class_label": {
        "required": "false",
        "description": "Common process name.",
        "id": "process_class_label",
        "display_name": "Process",
        "searchable": "true",
        "cardinality": "single",
        "type": "string",
        "indexed": "true",
        "property": [],
        "transform": []
      },
      "annotation_unit_label": {
        "required": "false",
        "description": "Generally not display but for debug purpose can be concatenation of gene product label, function, process etc",
        "id": "annotation_unit_label",
        "display_name": "Annotation unit",
        "cardinality": "single",
        "searchable": "true",
        "property": [],
        "transform": [],
        "type": "string",
        "indexed": "true"
      },
      "location_list": {
        "indexed": "true",
        "type": "string",
        "transform": [],
        "property": [],
        "searchable": "false",
        "cardinality": "multi",
        "display_name": "Location",
        "id": "location_list",
        "description": "",
        "required": "false"
      },
      "location_list_label": {
        "indexed": "true",
        "type": "string",
        "transform": [],
        "property": [],
        "searchable": "false",
        "cardinality": "multi",
        "id": "location_list_label",
        "display_name": "Location",
        "description": "",
        "required": "false"
      },
      "process_class": {
        "description": "Process acc/ID.",
        "display_name": "Process",
        "id": "process_class",
        "required": "false",
        "transform": [],
        "property": [],
        "indexed": "true",
        "type": "string",
        "cardinality": "single",
        "searchable": "false"
      },
      "evidence_type_label": {
        "cardinality": "single",
        "searchable": "true",
        "property": [],
        "transform": [],
        "type": "string",
        "indexed": "true",
        "required": "false",
        "description": "Evidence type.",
        "display_name": "Evidence",
        "id": "evidence_type_label"
      },
      "function_class_closure": {
        "property": [],
        "transform": [],
        "indexed": "true",
        "type": "string",
        "cardinality": "multi",
        "searchable": "false",
        "id": "function_class_closure",
        "display_name": "Function",
        "description": "???",
        "required": "false"
      },
      "panther_family_label": {
        "required": "false",
        "display_name": "PANTHER family",
        "id": "panther_family_label",
        "description": "PANTHER families that are associated with this entity.",
        "searchable": "true",
        "cardinality": "single",
        "type": "string",
        "indexed": "true",
        "property": [],
        "transform": []
      },
      "function_class_closure_label": {
        "cardinality": "multi",
        "searchable": "true",
        "transform": [],
        "property": [],
        "type": "string",
        "indexed": "true",
        "required": "false",
        "display_name": "Function",
        "id": "function_class_closure_label",
        "description": "???"
      },
      "taxon_closure_label": {
        "transform": [],
        "property": [],
        "type": "string",
        "indexed": "true",
        "cardinality": "multi",
        "searchable": "true",
        "description": "labels of is_a closure.",
        "id": "taxon_closure_label",
        "display_name": "Taxon",
        "required": "false"
      },
      "taxon": {
        "display_name": "Taxon",
        "id": "taxon",
        "description": "taxon of the entity in enabled_by",
        "required": "false",
        "type": "string",
        "indexed": "true",
        "transform": [],
        "property": [],
        "searchable": "false",
        "cardinality": "single"
      },
      "function_class_label": {
        "cardinality": "single",
        "searchable": "true",
        "property": [],
        "transform": [],
        "type": "string",
        "indexed": "true",
        "required": "false",
        "description": "Common function name.",
        "display_name": "Function",
        "id": "function_class_label"
      },
      "model_label": {
        "description": "The dc:title of the model to which the annoton belongs",
        "id": "model_label",
        "display_name": "Model title",
        "required": "false",
        "property": [],
        "transform": [],
        "type": "string",
        "indexed": "true",
        "cardinality": "single",
        "searchable": "true"
      },
      "model_url": {
        "description": "The URI of the model to which the annoton belongs",
        "id": "model_url",
        "display_name": "Model URL",
        "required": "false",
        "type": "string",
        "indexed": "true",
        "property": [],
        "transform": [],
        "searchable": "false",
        "cardinality": "single"
      },
      "process_class_closure_label": {
        "required": "false",
        "description": "???",
        "id": "process_class_closure_label",
        "display_name": "Process",
        "cardinality": "multi",
        "searchable": "true",
        "property": [],
        "transform": [],
        "type": "string",
        "indexed": "true"
      },
      "annotation_unit": {
        "required": "false",
        "description": "Same as id",
        "display_name": "Annotation unit",
        "id": "annotation_unit",
        "cardinality": "single",
        "searchable": "false",
        "transform": [],
        "property": [],
        "indexed": "true",
        "type": "string"
      },
      "comment": {
        "id": "comment",
        "display_name": "Comments",
        "description": "Comments",
        "required": "false",
        "property": [],
        "transform": [],
        "type": "string",
        "indexed": "true",
        "cardinality": "single",
        "searchable": "true"
      },
      "function_class": {
        "property": [],
        "transform": [],
        "type": "string",
        "indexed": "true",
        "cardinality": "single",
        "searchable": "false",
        "id": "function_class",
        "display_name": "Function",
        "description": "This is the value of rdf:type for the annoton/MF instance",
        "required": "false"
      },
      "model_date": {
        "display_name": "Modified",
        "id": "model_date",
        "description": "Value of dc:date field for the annoton",
        "required": "false",
        "property": [],
        "transform": [],
        "indexed": "true",
        "type": "string",
        "cardinality": "single",
        "searchable": "true"
      },
      "location_list_closure": {
        "required": "false",
        "description": "",
        "id": "location_list_closure",
        "display_name": "Location",
        "searchable": "false",
        "cardinality": "multi",
        "indexed": "true",
        "type": "string",
        "transform": [],
        "property": []
      },
      "reference": {
        "required": "false",
        "description": "Database reference.",
        "display_name": "Reference",
        "id": "reference",
        "searchable": "true",
        "cardinality": "multi",
        "type": "string",
        "indexed": "true",
        "transform": [],
        "property": []
      },
      "process_class_closure": {
        "required": "false",
        "description": "???",
        "display_name": "Process",
        "id": "process_class_closure",
        "searchable": "false",
        "cardinality": "multi",
        "type": "string",
        "indexed": "true",
        "property": [],
        "transform": []
      },
      "id": {
        "description": "CURIE form of annoton (molecular function individual)",
        "id": "id",
        "display_name": "ID",
        "required": "false",
        "transform": [],
        "property": [],
        "indexed": "true",
        "type": "string",
        "cardinality": "single",
        "searchable": "false"
      },
      "owl_blob_json": {
        "searchable": "false",
        "cardinality": "single",
        "type": "string",
        "indexed": "false",
        "transform": [],
        "property": [],
        "required": "false",
        "display_name": "???",
        "id": "owl_blob_json",
        "description": "???"
      },
      "taxon_label": {
        "description": "label for taxon",
        "id": "taxon_label",
        "display_name": "Taxon",
        "required": "false",
        "property": [],
        "transform": [],
        "type": "string",
        "indexed": "true",
        "cardinality": "single",
        "searchable": "true"
      },
      "evidence_with": {
        "required": "false",
        "display_name": "Evidence with",
        "id": "evidence_with",
        "description": "Evidence with/from.",
        "searchable": "true",
        "cardinality": "multi",
        "indexed": "true",
        "type": "string",
        "property": [],
        "transform": []
      },
      "panther_family": {
        "searchable": "true",
        "cardinality": "single",
        "type": "string",
        "indexed": "true",
        "property": [],
        "transform": [],
        "required": "false",
        "description": "PANTHER family IDs that are associated with this entity, not yet populated.",
        "display_name": "PANTHER family",
        "id": "panther_family"
      },
      "evidence_type_closure": {
        "display_name": "Evidence type",
        "id": "evidence_type_closure",
        "description": "All evidence (evidence closure) for this annotation",
        "required": "false",
        "indexed": "true",
        "type": "string",
        "transform": [],
        "property": [],
        "searchable": "false",
        "cardinality": "multi"
      },
      "enabled_by": {
        "cardinality": "single",
        "searchable": "true",
        "property": [],
        "transform": [],
        "type": "string",
        "indexed": "true",
        "required": "false",
        "description": "The CURIE for the ro:enabled_by.rdf:type value of the annoton/MF individual",
        "display_name": "Enabled by",
        "id": "enabled_by"
      }
    },
    "boost_weights": "model_label^1.0 annotation_unit_label^1.0 enabled_by^1.0 enabled_by_label^1.0 location_list_closure^1.0 location_list_closure_label^1.0 process_class_closure_label^1.0 function_class_closure_label^1.0 comment^0.5",
    "fields": [{
      "description": "CURIE form of annoton (molecular function individual)",
      "id": "id",
      "display_name": "ID",
      "required": "false",
      "transform": [],
      "property": [],
      "indexed": "true",
      "type": "string",
      "cardinality": "single",
      "searchable": "false"
    }, {
      "required": "false",
      "description": "Same as id",
      "display_name": "Annotation unit",
      "id": "annotation_unit",
      "cardinality": "single",
      "searchable": "false",
      "transform": [],
      "property": [],
      "indexed": "true",
      "type": "string"
    }, {
      "required": "false",
      "description": "Generally not display but for debug purpose can be concatenation of gene product label, function, process etc",
      "id": "annotation_unit_label",
      "display_name": "Annotation unit",
      "cardinality": "single",
      "searchable": "true",
      "property": [],
      "transform": [],
      "type": "string",
      "indexed": "true"
    }, {
      "required": "false",
      "display_name": "Model title",
      "id": "model",
      "description": "The CURIE of the model to which the annoton belongs",
      "searchable": "false",
      "cardinality": "single",
      "indexed": "true",
      "type": "string",
      "transform": [],
      "property": []
    }, {
      "description": "The dc:title of the model to which the annoton belongs",
      "id": "model_label",
      "display_name": "Model title",
      "required": "false",
      "property": [],
      "transform": [],
      "type": "string",
      "indexed": "true",
      "cardinality": "single",
      "searchable": "true"
    }, {
      "description": "The URI of the model to which the annoton belongs",
      "id": "model_url",
      "display_name": "Model URL",
      "required": "false",
      "type": "string",
      "indexed": "true",
      "property": [],
      "transform": [],
      "searchable": "false",
      "cardinality": "single"
    }, {
      "property": [],
      "transform": [],
      "indexed": "true",
      "type": "string",
      "cardinality": "single",
      "searchable": "false",
      "display_name": "State",
      "id": "model_state",
      "description": "Curation status",
      "required": "false"
    }, {
      "searchable": "false",
      "cardinality": "multi",
      "type": "string",
      "indexed": "true",
      "property": [],
      "transform": [],
      "required": "false",
      "description": "set of all literal values of all annotation assertions in model",
      "display_name": "Text",
      "id": "annotation_value"
    }, {
      "cardinality": "multi",
      "searchable": "true",
      "property": [],
      "transform": [],
      "type": "string",
      "indexed": "true",
      "required": "false",
      "description": "Value of dc:contributor fields for the annoton",
      "id": "contributor",
      "display_name": "Contributor"
    }, {
      "display_name": "Modified",
      "id": "model_date",
      "description": "Value of dc:date field for the annoton",
      "required": "false",
      "property": [],
      "transform": [],
      "indexed": "true",
      "type": "string",
      "cardinality": "single",
      "searchable": "true"
    }, {
      "id": "comment",
      "display_name": "Comments",
      "description": "Comments",
      "required": "false",
      "property": [],
      "transform": [],
      "type": "string",
      "indexed": "true",
      "cardinality": "single",
      "searchable": "true"
    }, {
      "cardinality": "single",
      "searchable": "true",
      "property": [],
      "transform": [],
      "type": "string",
      "indexed": "true",
      "required": "false",
      "description": "The CURIE for the ro:enabled_by.rdf:type value of the annoton/MF individual",
      "display_name": "Enabled by",
      "id": "enabled_by"
    }, {
      "required": "false",
      "description": "Searchable label version of the gene product",
      "id": "enabled_by_label",
      "display_name": "Enabled by label",
      "cardinality": "single",
      "searchable": "true",
      "transform": [],
      "property": [],
      "type": "string",
      "indexed": "true"
    }, {
      "searchable": "true",
      "cardinality": "single",
      "type": "string",
      "indexed": "true",
      "property": [],
      "transform": [],
      "required": "false",
      "description": "PANTHER family IDs that are associated with this entity, not yet populated.",
      "display_name": "PANTHER family",
      "id": "panther_family"
    }, {
      "required": "false",
      "display_name": "PANTHER family",
      "id": "panther_family_label",
      "description": "PANTHER families that are associated with this entity.",
      "searchable": "true",
      "cardinality": "single",
      "type": "string",
      "indexed": "true",
      "property": [],
      "transform": []
    }, {
      "display_name": "Taxon",
      "id": "taxon",
      "description": "taxon of the entity in enabled_by",
      "required": "false",
      "type": "string",
      "indexed": "true",
      "transform": [],
      "property": [],
      "searchable": "false",
      "cardinality": "single"
    }, {
      "description": "label for taxon",
      "id": "taxon_label",
      "display_name": "Taxon",
      "required": "false",
      "property": [],
      "transform": [],
      "type": "string",
      "indexed": "true",
      "cardinality": "single",
      "searchable": "true"
    }, {
      "searchable": "false",
      "cardinality": "multi",
      "type": "string",
      "indexed": "true",
      "transform": [],
      "property": [],
      "required": "false",
      "id": "taxon_closure",
      "display_name": "Taxon (IDs)",
      "description": "is_a closure of taxon"
    }, {
      "transform": [],
      "property": [],
      "type": "string",
      "indexed": "true",
      "cardinality": "multi",
      "searchable": "true",
      "description": "labels of is_a closure.",
      "id": "taxon_closure_label",
      "display_name": "Taxon",
      "required": "false"
    }, {
      "property": [],
      "transform": [],
      "type": "string",
      "indexed": "true",
      "cardinality": "single",
      "searchable": "false",
      "id": "function_class",
      "display_name": "Function",
      "description": "This is the value of rdf:type for the annoton/MF instance",
      "required": "false"
    }, {
      "cardinality": "single",
      "searchable": "true",
      "property": [],
      "transform": [],
      "type": "string",
      "indexed": "true",
      "required": "false",
      "description": "Common function name.",
      "display_name": "Function",
      "id": "function_class_label"
    }, {
      "property": [],
      "transform": [],
      "indexed": "true",
      "type": "string",
      "cardinality": "multi",
      "searchable": "false",
      "id": "function_class_closure",
      "display_name": "Function",
      "description": "???",
      "required": "false"
    }, {
      "cardinality": "multi",
      "searchable": "true",
      "transform": [],
      "property": [],
      "type": "string",
      "indexed": "true",
      "required": "false",
      "display_name": "Function",
      "id": "function_class_closure_label",
      "description": "???"
    }, {
      "description": "Process acc/ID.",
      "display_name": "Process",
      "id": "process_class",
      "required": "false",
      "transform": [],
      "property": [],
      "indexed": "true",
      "type": "string",
      "cardinality": "single",
      "searchable": "false"
    }, {
      "required": "false",
      "description": "Common process name.",
      "id": "process_class_label",
      "display_name": "Process",
      "searchable": "true",
      "cardinality": "single",
      "type": "string",
      "indexed": "true",
      "property": [],
      "transform": []
    }, {
      "required": "false",
      "description": "???",
      "display_name": "Process",
      "id": "process_class_closure",
      "searchable": "false",
      "cardinality": "multi",
      "type": "string",
      "indexed": "true",
      "property": [],
      "transform": []
    }, {
      "required": "false",
      "description": "???",
      "id": "process_class_closure_label",
      "display_name": "Process",
      "cardinality": "multi",
      "searchable": "true",
      "property": [],
      "transform": [],
      "type": "string",
      "indexed": "true"
    }, {
      "indexed": "true",
      "type": "string",
      "transform": [],
      "property": [],
      "searchable": "false",
      "cardinality": "multi",
      "display_name": "Location",
      "id": "location_list",
      "description": "",
      "required": "false"
    }, {
      "indexed": "true",
      "type": "string",
      "transform": [],
      "property": [],
      "searchable": "false",
      "cardinality": "multi",
      "id": "location_list_label",
      "display_name": "Location",
      "description": "",
      "required": "false"
    }, {
      "required": "false",
      "description": "",
      "id": "location_list_closure",
      "display_name": "Location",
      "searchable": "false",
      "cardinality": "multi",
      "indexed": "true",
      "type": "string",
      "transform": [],
      "property": []
    }, {
      "indexed": "true",
      "type": "string",
      "transform": [],
      "property": [],
      "searchable": "false",
      "cardinality": "multi",
      "description": "",
      "display_name": "Location",
      "id": "location_list_closure_label",
      "required": "false"
    }, {
      "searchable": "false",
      "cardinality": "single",
      "type": "string",
      "indexed": "false",
      "transform": [],
      "property": [],
      "required": "false",
      "display_name": "???",
      "id": "owl_blob_json",
      "description": "???"
    }, {
      "searchable": "false",
      "cardinality": "single",
      "type": "string",
      "indexed": "false",
      "transform": [],
      "property": [],
      "required": "false",
      "display_name": "Topology graph (JSON)",
      "id": "topology_graph_json",
      "description": "JSON blob form of the local stepwise topology graph."
    }, {
      "required": "false",
      "description": "Evidence type.",
      "display_name": "Evidence",
      "id": "evidence_type",
      "cardinality": "single",
      "searchable": "false",
      "transform": [],
      "property": [],
      "indexed": "true",
      "type": "string"
    }, {
      "display_name": "Evidence type",
      "id": "evidence_type_closure",
      "description": "All evidence (evidence closure) for this annotation",
      "required": "false",
      "indexed": "true",
      "type": "string",
      "transform": [],
      "property": [],
      "searchable": "false",
      "cardinality": "multi"
    }, {
      "cardinality": "single",
      "searchable": "true",
      "property": [],
      "transform": [],
      "type": "string",
      "indexed": "true",
      "required": "false",
      "description": "Evidence type.",
      "display_name": "Evidence",
      "id": "evidence_type_label"
    }, {
      "description": "All evidence (evidence closure) for this annotation",
      "id": "evidence_type_closure_label",
      "display_name": "Evidence type",
      "required": "false",
      "type": "string",
      "indexed": "true",
      "transform": [],
      "property": [],
      "searchable": "true",
      "cardinality": "multi"
    }, {
      "required": "false",
      "display_name": "Evidence with",
      "id": "evidence_with",
      "description": "Evidence with/from.",
      "searchable": "true",
      "cardinality": "multi",
      "indexed": "true",
      "type": "string",
      "property": [],
      "transform": []
    }, {
      "required": "false",
      "description": "Database reference.",
      "display_name": "Reference",
      "id": "reference",
      "searchable": "true",
      "cardinality": "multi",
      "type": "string",
      "indexed": "true",
      "transform": [],
      "property": []
    }],
    "document_category": "model_annotation",
    "searchable_extension": "_searchable",
    "_infile": "/home/bbop/local/src/git/amigo/metadata/model-ann-config.yaml",
    "description": "An individual unit within a GO-CAM. This is <strong>ALPHA</strong> software.",
    "weight": "40",
    "result_weights": "function_class^9.0 enabled_by^8.0 location_list^7.0 process_class^6.0 model^5.0 taxon^4.5 contributor^4.0 model_date^3.0 reference^2.0",
    "id": "model_annotation",
    "display_name": "GO models (ALPHA)",
    "schema_generating": "true",
    "_strict": 0,
    "filter_weights": "model_label^5.0 enabled_by_label^4.5 reference^4.3 location_list_closure_label^4.0 process_class_closure_label^3.0 function_class_closure_label^2.0 contributor^1.0 evidence_type^0.5",
    "_outfile": "/home/bbop/local/src/git/amigo/metadata/model-ann-config.yaml"
  }
};

///
/// Exportable body.
///

module.exports = golr;

},{}],6:[function(require,module,exports){
/*
 * Package: amigo2-instance-server
 * 
 * This package was automatically created during AmiGO 2 installation.
 * 
 * Purpose: Useful information about GO and the AmiGO installation.
 *          Also serves as a repository and getter for web
 *          resources such as images.
 * 
 * NOTE: This file is generated dynamically at installation time.
 *       Hard to work with unit tests--hope it's not too bad.
 *       Want to keep this real simple.
 */

// All of the server/instance-specific meta-data.
var meta_data = {
  "evidence_codes": {},
  "noctua_base": "https://grill.lbl.gov:8910/",
  "term_regexp": "all|GO:[0-9]{7}",
  "app_base": "https://amigo.geneontology.org",
  "bbop_img_star": "https://amigo.geneontology.org/static/images/star.png",
  "html_base": "https://amigo.geneontology.org/static",
  "image_base": "https://amigo.geneontology.org/static/images",
  "sources": [],
  "species_map": {},
  "js_base": "https://amigo.geneontology.org/static/js",
  "ontologies": [],
  "galaxy_base": "https://galaxy.berkeleybop.org/",
  "golr_bulk_base": "https://golr-aux.geneontology.io/solr/",
  "browse_filter_idspace": "GO",
  "golr_base": "https://golr.geneontology.org/solr/",
  "gp_types": [],
  "root_terms": [{
    "id": "GO:0008150",
    "label": "biological process"
  }, {
    "id": "GO:0005575",
    "label": "cellular component"
  }, {
    "label": "molecular function",
    "id": "GO:0003674"
  }],
  "css_base": "https://amigo.geneontology.org/static/css",
  "beta": "0",
  "species": [],
  "js_dev_base": "https://amigo.geneontology.org/static/staging"
};

/*
 * Constructor: server
 * 
 * The configuration for the server settings.
 * Essentially a JSONification of the config.pl AmiGO 2 file.
 * 
 * Arguments:
 *  n/a
 */
var server = {
  ///
  /// Da chunk...
  ///

  meta_data: meta_data,
  ///
  /// Break out the data and various functions to access them...
  ///

  /*
   * Function: sources
   * 
   * Access to AmiGO variable sources.
   * 
   * Parameters:
   *  n/a
   * 
   * Returns:
   *  string
   */
  sources: meta_data.sources,
  /*
   * Function: app_base
   * 
   * Access to AmiGO variable app_base.
   * 
   * Parameters:
   *  n/a
   * 
   * Returns:
   *  string
   */
  app_base: meta_data.app_base,
  /*
   * Function: term_regexp
   * 
   * Access to AmiGO variable term_regexp.
   * 
   * Parameters:
   *  n/a
   * 
   * Returns:
   *  string
   */
  term_regexp: meta_data.term_regexp,
  /*
   * Function: noctua_base
   * 
   * Access to AmiGO variable noctua_base.
   * 
   * Parameters:
   *  n/a
   * 
   * Returns:
   *  string
   */
  noctua_base: meta_data.noctua_base,
  /*
   * Function: golr_base
   * 
   * Access to AmiGO variable golr_base.
   * 
   * Parameters:
   *  n/a
   * 
   * Returns:
   *  string
   */
  golr_base: meta_data.golr_base,
  /*
   * Function: golr_bulk_base
   * 
   * Access to AmiGO variable golr_bulk_base.
   * 
   * Parameters:
   *  n/a
   * 
   * Returns:
   *  string
   */
  golr_bulk_base: meta_data.golr_bulk_base,
  /*
   * Function: evidence_codes
   * 
   * Access to AmiGO variable evidence_codes.
   * 
   * Parameters:
   *  n/a
   * 
   * Returns:
   *  string
   */
  evidence_codes: meta_data.evidence_codes,
  /*
   * Function: root_terms
   * 
   * Access to AmiGO variable root_terms.
   * 
   * Parameters:
   *  n/a
   * 
   * Returns:
   *  object
   */
  root_terms: meta_data.root_terms,
  /*
   * Function: beta
   * 
   * Access to AmiGO variable beta.
   * 
   * Parameters:
   *  n/a
   * 
   * Returns:
   *  string
   */
  beta: meta_data.beta,
  /*
   * Function: html_base
   * 
   * Access to AmiGO variable html_base.
   * 
   * Parameters:
   *  n/a
   * 
   * Returns:
   *  string
   */
  html_base: meta_data.html_base,
  /*
   * Function: gp_types
   * 
   * Access to AmiGO variable gp_types.
   * 
   * Parameters:
   *  n/a
   * 
   * Returns:
   *  string
   */
  gp_types: meta_data.gp_types,
  /*
   * Function: browse_filter_idspace
   * 
   * Access to AmiGO variable browse_filter_idspace.
   * 
   * Parameters:
   *  n/a
   * 
   * Returns:
   *  string
   */
  browse_filter_idspace: meta_data.browse_filter_idspace,
  /*
   * Function: species_map
   * 
   * Access to AmiGO variable species_map.
   * 
   * Parameters:
   *  n/a
   * 
   * Returns:
   *  string
   */
  species_map: meta_data.species_map,
  /*
   * Function: js_base
   * 
   * Access to AmiGO variable js_base.
   * 
   * Parameters:
   *  n/a
   * 
   * Returns:
   *  string
   */
  js_base: meta_data.js_base,
  /*
   * Function: species
   * 
   * Access to AmiGO variable species.
   * 
   * Parameters:
   *  n/a
   * 
   * Returns:
   *  string
   */
  species: meta_data.species,
  /*
   * Function: js_dev_base
   * 
   * Access to AmiGO variable js_dev_base.
   * 
   * Parameters:
   *  n/a
   * 
   * Returns:
   *  string
   */
  js_dev_base: meta_data.js_dev_base,
  /*
   * Function: galaxy_base
   * 
   * Access to AmiGO variable galaxy_base.
   * 
   * Parameters:
   *  n/a
   * 
   * Returns:
   *  string
   */
  galaxy_base: meta_data.galaxy_base,
  /*
   * Function: css_base
   * 
   * Access to AmiGO variable css_base.
   * 
   * Parameters:
   *  n/a
   * 
   * Returns:
   *  string
   */
  css_base: meta_data.css_base,
  /*
   * Function: bbop_img_star
   * 
   * Access to AmiGO variable bbop_img_star.
   * 
   * Parameters:
   *  n/a
   * 
   * Returns:
   *  string
   */
  bbop_img_star: meta_data.bbop_img_star,
  /*
   * Function: ontologies
   * 
   * Access to AmiGO variable ontologies.
   * 
   * Parameters:
   *  n/a
   * 
   * Returns:
   *  string
   */
  ontologies: meta_data.ontologies,
  /*
   * Function: image_base
   * 
   * Access to AmiGO variable image_base.
   * 
   * Parameters:
   *  n/a
   * 
   * Returns:
   *  string
   */
  image_base: meta_data.image_base
};

///
/// Exportable body.
///

module.exports = server;

},{}],7:[function(require,module,exports){
/* 
 * Package: xrefs.js
 * 
 * Namespace: amigo.data.xrefs
 * 
 * This package was automatically created during an AmiGO 2 installation
 * from the GO.xrf_abbs file at: "https://raw.githubusercontent.com/geneontology/go-site/master/metadata/db-xrefs.yaml".
 *
 * NOTE: This file is generated dynamically at installation time.
 * Hard to work with unit tests--hope it's not too bad. You have to
 * occasionally copy back to keep the unit tests sane.
 */

/*
 * Variable: xrefs
 * 
 * All the external references that we know about.
 */
var xrefs = {
  "smart": {
    "generic_url": "http://smart.embl-heidelberg.de/",
    "uri_prefix": null,
    "fullname": null,
    "id": "SMART",
    "abbreviation": "SMART",
    "example_id": "SMART:SM00005",
    "name": "Simple Modular Architecture Research Tool",
    "database": "Simple Modular Architecture Research Tool",
    "url_syntax": "http://smart.embl-heidelberg.de/smart/do_annotation.pl?BLAST=DUMMY&DOMAIN=[example_id]",
    "datatype": "polypeptide region",
    "url_example": "http://smart.embl-heidelberg.de/smart/do_annotation.pl?BLAST=DUMMY&DOMAIN=SM00005",
    "object": "polypeptide region"
  },
  "kegg_ligand": {
    "datatype": "chemical entity",
    "url_syntax": "http://www.genome.jp/dbget-bin/www_bget?cpd:[example_id]",
    "database": "KEGG LIGAND Database",
    "object": "chemical entity",
    "url_example": "http://www.genome.jp/dbget-bin/www_bget?cpd:C00577",
    "uri_prefix": null,
    "generic_url": "http://www.genome.ad.jp/kegg/docs/upd_ligand.html",
    "fullname": null,
    "abbreviation": "KEGG_LIGAND",
    "id": "KEGG_LIGAND",
    "name": "KEGG LIGAND Database",
    "example_id": "KEGG_LIGAND:C00577"
  },
  "cgd": {
    "url_example": "http://www.candidagenome.org/cgi-bin/locus.pl?dbid=CAL0000179664",
    "object": "gene",
    "database": "Candida Genome Database",
    "datatype": "gene",
    "url_syntax": "http://www.candidagenome.org/cgi-bin/locus.pl?dbid=[example_id]",
    "example_id": "CGD:CAL0000179664",
    "name": "Candida Genome Database",
    "id": "CGD",
    "fullname": null,
    "abbreviation": "CGD",
    "generic_url": "http://www.candidagenome.org/",
    "uri_prefix": null
  },
  "gr_mut": {
    "abbreviation": "GR_MUT",
    "fullname": null,
    "id": "GR_MUT",
    "generic_url": "http://www.gramene.org/",
    "uri_prefix": null,
    "example_id": "GR_MUT:GR:0060198",
    "name": "A Comparative Mapping Resource for Grains",
    "database": "A Comparative Mapping Resource for Grains",
    "url_syntax": "http://www.gramene.org/db/genes/search_gene?acc=[example_id]",
    "datatype": "entity",
    "object": "entity",
    "url_example": "http://www.gramene.org/db/genes/search_gene?acc=GR:0060198"
  },
  "ensemblmetazoa": {
    "abbreviation": "EnsemblMetazoa",
    "fullname": null,
    "id": "EnsemblMetazoa",
    "uri_prefix": null,
    "generic_url": "http://metazoa.ensembl.org/",
    "name": "Ensembl Metazoa, the Ensembl database for accessing genome-scale data from non-vertebrate metazoa.",
    "example_id": "EnsemblMetazoa:FBgn0052693",
    "datatype": "gene",
    "url_syntax": "http://www.ensemblgenomes.org/id/[example_id]",
    "database": "Ensembl Metazoa, the Ensembl database for accessing genome-scale data from non-vertebrate metazoa.",
    "object": "gene",
    "url_example": "http://www.ensemblgenomes.org/id/FBgn0052693"
  },
  "agbase": {
    "url_example": null,
    "object": "entity",
    "url_syntax": "https://agbase.arizona.edu/cgi-bin/getEntry.pl?db_pick=all&database=Swiss-Prot&gb_acc=[example_id]",
    "datatype": "entity",
    "database": "AgBase resource for functional analysis of agricultural plant and animal gene products",
    "name": "AgBase resource for functional analysis of agricultural plant and animal gene products",
    "example_id": "P02264",
    "uri_prefix": null,
    "generic_url": "http://www.agbase.msstate.edu/",
    "abbreviation": "AgBase",
    "fullname": null,
    "id": "AgBase"
  },
  "pirsf": {
    "datatype": "entity",
    "url_syntax": "http://pir.georgetown.edu/cgi-bin/ipcSF?id=[example_id]",
    "database": "PIR Superfamily Classification System",
    "url_example": "http://pir.georgetown.edu/cgi-bin/ipcSF?id=SF002327",
    "object": "entity",
    "uri_prefix": null,
    "generic_url": "http://pir.georgetown.edu/pirsf/",
    "abbreviation": "PIRSF",
    "fullname": null,
    "id": "PIRSF",
    "name": "PIR Superfamily Classification System",
    "example_id": "PIRSF:SF002327"
  },
  "imgt_ligm": {
    "id": "IMGT_LIGM",
    "fullname": "Database of immunoglobulins and T cell receptors from human and other vertebrates, with translation for fully annotated sequences.",
    "abbreviation": "IMGT_LIGM",
    "generic_url": "http://www.imgt.org/",
    "uri_prefix": null,
    "example_id": "IMGT_LIGM:U03895",
    "name": "ImMunoGeneTics database covering immunoglobulins and T-cell receptors",
    "database": "ImMunoGeneTics database covering immunoglobulins and T-cell receptors",
    "url_syntax": null,
    "datatype": "entity",
    "object": "entity",
    "url_example": null
  },
  "ntnu_sb": {
    "database": "Norwegian University of Science and Technology, Systems Biology team",
    "url_syntax": null,
    "datatype": "entity",
    "object": "entity",
    "url_example": null,
    "id": "NTNU_SB",
    "fullname": null,
    "abbreviation": "NTNU_SB",
    "generic_url": "http://www.ntnu.edu/nt/systemsbiology",
    "uri_prefix": null,
    "example_id": null,
    "name": "Norwegian University of Science and Technology, Systems Biology team"
  },
  "mgcsc_genetic_stocks": {
    "url_syntax": "http://www.maizegdb.org/cgi-bin/displaystockrecord.cgi?id=[example_id]",
    "datatype": "entity",
    "database": "Maize Genetics and Genomics Database",
    "object": "entity",
    "url_example": "http://www.maizegdb.org/cgi-bin/displaytraitrecord.cgi?id=78112",
    "uri_prefix": null,
    "generic_url": "http://www.maizegdb.org",
    "id": "MGCSC_GENETIC_STOCKS",
    "fullname": null,
    "abbreviation": "MGCSC_GENETIC_STOCKS",
    "name": "Maize Genetics and Genomics Database",
    "example_id": "MGCSC_GENETIC_STOCKS:78112"
  },
  "locusid": {
    "name": "NCBI Gene",
    "example_id": "NCBI_Gene:4771",
    "uri_prefix": null,
    "generic_url": "http://www.ncbi.nlm.nih.gov/",
    "fullname": null,
    "id": "NCBIGene",
    "abbreviation": "LocusID",
    "url_example": "https://www.ncbi.nlm.nih.gov/gene/4771",
    "object": "gene",
    "url_syntax": "https://www.ncbi.nlm.nih.gov/gene/[example_id]",
    "datatype": "gene",
    "database": "NCBI Gene"
  },
  "wbls": {
    "object": "nematoda life stage",
    "url_example": "http://www.wormbase.org/get?name=WBls:0000010",
    "database": "C. elegans development",
    "datatype": "nematoda life stage",
    "url_syntax": "http://www.wormbase.org/get?name=[example_id]",
    "example_id": "WBls:0000010",
    "name": "C. elegans development",
    "generic_url": "http://www.wormbase.org/",
    "uri_prefix": null,
    "abbreviation": "WBls",
    "fullname": null,
    "id": "WBls"
  },
  "uniparc": {
    "database": "UniProt Archive",
    "datatype": "entity",
    "url_syntax": "https://www.uniprot.org/uniparc/[example_id]",
    "object": "entity",
    "url_example": "https://www.uniprot.org/uniparc/UPI000000000A",
    "generic_url": "https://www.uniprot.org/uniparc/",
    "uri_prefix": null,
    "fullname": "A non-redundant archive of protein sequences extracted from Swiss-Prot, TrEMBL, PIR-PSD, EMBL, Ensembl, IPI, PDB, RefSeq, FlyBase, WormBase, European Patent Office, United States Patent and Trademark Office, and Japanese Patent Office",
    "id": "UniParc",
    "abbreviation": "UniParc",
    "example_id": "UniParc:UPI000000000A",
    "name": "UniProt Archive"
  },
  "pubchem_compound": {
    "name": "NCBI PubChem database of chemical structures",
    "example_id": "PubChem_Compound:159296",
    "fullname": null,
    "abbreviation": "PubChem_Compound",
    "id": "PubChem_Compound",
    "uri_prefix": null,
    "generic_url": "https://pubchem.ncbi.nlm.nih.gov",
    "object": "chemical entity",
    "url_example": "https://pubchem.ncbi.nlm.nih.gov/compound/159296",
    "datatype": "chemical entity",
    "url_syntax": "https://pubchem.ncbi.nlm.nih.gov/compound/[example_id]",
    "database": "NCBI PubChem database of chemical structures"
  },
  "cafa": {
    "abbreviation": "CAFA",
    "fullname": null,
    "id": "CAFA",
    "uri_prefix": null,
    "generic_url": "http://biofunctionprediction.org/cafa/",
    "name": "Critical Assessment of Protein Function Annotation",
    "example_id": null,
    "datatype": "entity",
    "url_syntax": null,
    "database": "Critical Assessment of Protein Function Annotation",
    "object": "entity",
    "url_example": null
  },
  "ncbitaxon": {
    "fullname": null,
    "abbreviation": "NCBITaxon",
    "id": "NCBITaxon",
    "uri_prefix": null,
    "generic_url": "http://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/",
    "name": "NCBI Taxonomy",
    "example_id": "NCBITaxon:7227",
    "datatype": "entity",
    "url_syntax": "http://www.ncbi.nlm.nih.gov/Taxonomy/Browser/wwwtax.cgi?id=[example_id]",
    "database": "NCBI Taxonomy",
    "object": "entity",
    "url_example": "http://www.ncbi.nlm.nih.gov/Taxonomy/Browser/wwwtax.cgi?id=3702"
  },
  "kegg_enzyme": {
    "datatype": "entity",
    "url_syntax": "http://www.genome.jp/dbget-bin/www_bget?ec:[example_id]",
    "database": "KEGG Enzyme Database",
    "url_example": "http://www.genome.jp/dbget-bin/www_bget?ec:2.1.1.4",
    "object": "entity",
    "uri_prefix": null,
    "generic_url": "http://www.genome.jp/dbget-bin/www_bfind?enzyme",
    "id": "KEGG_ENZYME",
    "fullname": null,
    "abbreviation": "KEGG_ENZYME",
    "name": "KEGG Enzyme Database",
    "example_id": "KEGG_ENZYME:2.1.1.4"
  },
  "pmcid": {
    "url_example": "https://www.ncbi.nlm.nih.gov/pmc/articles/PMC201377/",
    "object": "entity",
    "database": "Pubmed Central",
    "datatype": "entity",
    "url_syntax": "https://www.ncbi.nlm.nih.gov/pmc/articles/[example_id]",
    "example_id": "PMCID:PMC201377",
    "name": "Pubmed Central",
    "fullname": null,
    "abbreviation": "PMCID",
    "id": "PMCID",
    "generic_url": "https://www.ncbi.nlm.nih.gov/pmc/",
    "uri_prefix": null
  },
  "ro": {
    "object": "entity",
    "url_example": "http://purl.obolibrary.org/obo/RO_0002211",
    "url_syntax": "http://purl.obolibrary.org/obo/RO_[example_id]",
    "datatype": "entity",
    "database": "OBO Relation Ontology Ontology",
    "name": "OBO Relation Ontology Ontology",
    "example_id": "RO:0002211",
    "uri_prefix": null,
    "generic_url": "http://purl.obolibrary.org/obo/ro",
    "id": "RO",
    "fullname": "A collection of relations used across OBO ontologies",
    "abbreviation": "RO"
  },
  "fma": {
    "fullname": null,
    "abbreviation": "FMA",
    "id": "FMA",
    "uri_prefix": null,
    "generic_url": "http://sig.biostr.washington.edu/projects/fm/index.html",
    "name": "Foundational Model of Anatomy",
    "example_id": "FMA:61905",
    "datatype": "entity",
    "url_syntax": null,
    "database": "Foundational Model of Anatomy",
    "object": "entity",
    "url_example": null
  },
  "aruk-ucl": {
    "object": "entity",
    "url_example": null,
    "database": "Alzheimers Research Gene Ontology Initiative",
    "datatype": "entity",
    "url_syntax": null,
    "example_id": null,
    "name": "Alzheimers Research Gene Ontology Initiative",
    "fullname": null,
    "id": "ARUK-UCL",
    "abbreviation": "ARUK-UCL",
    "generic_url": "https://www.ucl.ac.uk/cardiovascular/research/pre-clinical-and-fundamental-science/functional-gene-annotation/neurological-gene-0",
    "uri_prefix": null
  },
  "emapa": {
    "generic_url": "http://emouseatlas.org/",
    "uri_prefix": null,
    "fullname": "A time-independent Mouse Anatomical Dictionary; part of Gene Expression Database",
    "abbreviation": "EMAPA",
    "id": "EMAPA",
    "example_id": "EMAPA:16032",
    "name": "Mouse gross anatomy and development, abstract",
    "database": "Mouse gross anatomy and development, abstract",
    "url_syntax": "http://www.informatics.jax.org/vocab/gxd/anatomy/EMAPA:[example_id]",
    "datatype": "anatomical entity",
    "url_example": "http://www.informatics.jax.org/vocab/gxd/anatomy/EMAPA:16894",
    "object": "anatomical entity"
  },
  "h-invdb": {
    "url_example": null,
    "object": "entity",
    "database": "H-invitational Database",
    "url_syntax": null,
    "datatype": "entity",
    "example_id": null,
    "name": "H-invitational Database",
    "fullname": null,
    "id": "H-invDB",
    "abbreviation": "H-invDB",
    "generic_url": "http://www.h-invitational.jp/",
    "uri_prefix": null
  },
  "ncbi_taxid": {
    "database": "NCBI Taxonomy",
    "url_syntax": "http://www.ncbi.nlm.nih.gov/Taxonomy/Browser/wwwtax.cgi?id=[example_id]",
    "datatype": "entity",
    "url_example": "http://www.ncbi.nlm.nih.gov/Taxonomy/Browser/wwwtax.cgi?id=3702",
    "object": "entity",
    "fullname": null,
    "abbreviation": "ncbi_taxid",
    "id": "NCBITaxon",
    "generic_url": "http://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/",
    "uri_prefix": null,
    "example_id": "NCBITaxon:7227",
    "name": "NCBI Taxonomy"
  },
  "gr_protein": {
    "abbreviation": "GR_protein",
    "fullname": null,
    "id": "GR_PROTEIN",
    "generic_url": "http://www.gramene.org/",
    "uri_prefix": null,
    "example_id": "GR_PROTEIN:Q6VSV0",
    "name": "Gramene",
    "database": "Gramene",
    "datatype": "protein",
    "url_syntax": "http://www.gramene.org/db/protein/protein_search?acc=[example_id]",
    "object": "protein",
    "url_example": "http://www.gramene.org/db/protein/protein_search?acc=Q6VSV0"
  },
  "bhf-ucl": {
    "datatype": "entity",
    "url_syntax": null,
    "database": "Cardiovascular Gene Ontology Annotation Initiative",
    "object": "entity",
    "url_example": null,
    "uri_prefix": null,
    "generic_url": "https://www.ucl.ac.uk/cardiovascular/research/pre-clinical-and-fundamental-science/functional-gene-annotation/cardiovascular-gene",
    "fullname": "The Cardiovascular Gene Ontology Annotation Initiative is supported by the British Heart Foundation (BHF) and located at University College London (UCL).",
    "id": "BHF-UCL",
    "abbreviation": "BHF-UCL",
    "name": "Cardiovascular Gene Ontology Annotation Initiative",
    "example_id": null
  },
  "animal_corrdb": {
    "name": "CorrDB",
    "example_id": "Animal_CorrDB:37232",
    "fullname": "A database with curated publicly available trait correlation and inheritability data in livestock animal species. The link ID is called  The link ID is called Corr_ID on CorrDB data downloads.",
    "id": "Animal_CorrDB",
    "abbreviation": "Animal_CorrDB",
    "uri_prefix": null,
    "generic_url": "https://www.animalgenome.org/CorrDB",
    "object": "Correlation",
    "url_example": "https://www.animalgenome.org/CorrDB/q/?id=37232",
    "url_syntax": "https://www.animalgenome.org/CorrDB/q/?id=[example_id]",
    "datatype": "Correlation",
    "database": "CorrDB"
  },
  "um-bbd_enzymeid": {
    "database": "EAWAG Biocatalysis/Biodegradation Database",
    "datatype": "entity",
    "url_syntax": "http://eawag-bbd.ethz.ch/servlets/pageservlet?ptype=ep&enzymeID=[example_id]",
    "object": "entity",
    "url_example": "http://eawag-bbd.ethz.ch/servlets/pageservlet?ptype=ep&enzymeID=e0230",
    "generic_url": "http://eawag-bbd.ethz.ch/",
    "uri_prefix": null,
    "fullname": null,
    "id": "UM-BBD_enzymeID",
    "abbreviation": "UM-BBD_enzymeID",
    "example_id": "UM-BBD_enzymeID:e0413",
    "name": "EAWAG Biocatalysis/Biodegradation Database"
  },
  "reactome": {
    "object": "entity",
    "url_example": "https://www.reactome.org/content/detail/R-HSA-109582",
    "database": "Reactome - a curated knowledgebase of biological pathways",
    "datatype": "entity",
    "url_syntax": "https://www.reactome.org/content/detail/[example_id]",
    "example_id": "Reactome:R-HSA-109582",
    "name": "Reactome - a curated knowledgebase of biological pathways",
    "generic_url": "https://www.reactome.org/",
    "uri_prefix": null,
    "id": "Reactome",
    "fullname": null,
    "abbreviation": "REACTOME"
  },
  "sgd_pwy": {
    "fullname": null,
    "id": "SGD_PWY",
    "abbreviation": "SGD_PWY",
    "generic_url": "https://pathway.yeastgenome.org/",
    "uri_prefix": null,
    "example_id": "SGD_PWY:CYSTEINE-SYN2-PWY",
    "name": "Saccharomyces Genome Database YeastPathways",
    "database": "Saccharomyces Genome Database YeastPathways",
    "datatype": "entity",
    "url_syntax": "https://www.yeastgenome.org/locus/[example_id]",
    "object": "entity",
    "url_example": "https://pathway.yeastgenome.org/YEAST/NEW-IMAGE?type=NIL&object=SERSYN-PWY"
  },
  "eupathdb": {
    "fullname": null,
    "abbreviation": "EuPathDB",
    "id": "EuPathDB",
    "uri_prefix": null,
    "generic_url": "http://eupathdb.org",
    "name": "The Eukaryotic Pathogen Database",
    "example_id": "EuPathDB:LtaP17.1490",
    "datatype": "gene",
    "url_syntax": "http://eupathdb.org/gene/[example_id]",
    "database": "The Eukaryotic Pathogen Database",
    "object": "gene",
    "url_example": "http://eupathdb.org/gene/LtaP17.1490"
  },
  "jstor": {
    "name": "Digital archive of scholarly articles",
    "example_id": "JSTOR:3093870",
    "id": "JSTOR",
    "fullname": null,
    "abbreviation": "JSTOR",
    "uri_prefix": null,
    "generic_url": "https://www.jstor.org/",
    "url_example": "https://www.jstor.org/stable/3093870",
    "object": "entity",
    "datatype": "entity",
    "url_syntax": "https://www.jstor.org/stable/[example_id]",
    "database": "Digital archive of scholarly articles"
  },
  "cas_gen": {
    "url_example": "https://researcharchive.calacademy.org/research/ichthyology/catalog/fishcatget.asp?genid=1040",
    "object": "entity",
    "datatype": "entity",
    "url_syntax": "https://researcharchive.calacademy.org/research/ichthyology/catalog/fishcatget.asp?genid=[example_id]",
    "database": "Catalog of Fishes genus database",
    "name": "Catalog of Fishes genus database",
    "example_id": "CASGEN:1040",
    "uri_prefix": null,
    "generic_url": "https://researcharchive.calacademy.org/research/ichthyology/catalog/fishcatmain.asp",
    "fullname": null,
    "abbreviation": "CAS_GEN",
    "id": "CASGEN"
  },
  "isbn": {
    "example_id": "ISBN:0781702534",
    "name": "International Standard Book Number",
    "fullname": null,
    "id": "ISBN",
    "abbreviation": "ISBN",
    "generic_url": "https://www.worldcat.org",
    "uri_prefix": null,
    "url_example": "https://www.worldcat.org/search?q=bn%3A0781702534",
    "object": "entity",
    "database": "International Standard Book Number",
    "url_syntax": "https://www.worldcat.org/search?q=bn%3A[example_id]",
    "datatype": "entity"
  },
  "sabio-rk": {
    "fullname": "The SABIO-RK (System for the Analysis of Biochemical Pathways - Reaction Kinetics) is a web-based application based on the SABIO relational database that contains information about biochemical reactions, their kinetic equations with their parameters, and the experimental conditions under which these parameters were measured.",
    "abbreviation": "SABIO-RK",
    "id": "SABIO-RK",
    "generic_url": "http://sabio.villa-bosch.de/",
    "uri_prefix": null,
    "example_id": "SABIO-RK:1858",
    "name": "SABIO Reaction Kinetics",
    "database": "SABIO Reaction Kinetics",
    "url_syntax": "http://sabio.villa-bosch.de/reacdetails.jsp?reactid=[example_id]",
    "datatype": "entity",
    "url_example": "http://sabio.villa-bosch.de/reacdetails.jsp?reactid=1858",
    "object": "entity"
  },
  "animal_qtldb": {
    "abbreviation": "Animal_QTLdb",
    "fullname": "A database with curated publicly available trait mapping data (QTL and SNP associations) in livestock animal species. The link ID is called QTL_ID on QTLdb data dpownloads.",
    "id": "Animal_QTLdb",
    "generic_url": "https://www.animalgenome.org/QTLdb",
    "uri_prefix": null,
    "example_id": "Animal_QTLdb:23155",
    "name": "QTLdb",
    "database": "QTLdb",
    "url_syntax": "https://www.animalgenome.org/QTLdb/q?id=[example_id]",
    "datatype": "QTL",
    "object": "QTL",
    "url_example": "https://www.animalgenome.org/QTLdb/q?id=23155"
  },
  "mi": {
    "database": "Proteomic Standard Initiative for Molecular Interaction",
    "datatype": "entity",
    "url_syntax": "http://purl.obolibrary.org/obo/",
    "object": "entity",
    "url_example": "http://purl.obolibrary.org/obo/MI_0018",
    "abbreviation": "MI",
    "fullname": null,
    "id": "PSI-MI",
    "generic_url": "http://www.psidev.info/",
    "uri_prefix": null,
    "example_id": "MI_0018",
    "name": "Proteomic Standard Initiative for Molecular Interaction"
  },
  "macsc_ref": {
    "generic_url": "http://www.maizegdb.org/",
    "uri_prefix": null,
    "fullname": null,
    "abbreviation": "MACSC_REF",
    "id": "MACSC_REF",
    "example_id": "MACSC_REF:78112",
    "name": "Maize Genetics and Genomics Database",
    "database": "Maize Genetics and Genomics Database",
    "url_syntax": "http://www.maizegdb.org/cgi-bin/displaytraitrecord.cgi?id=[example_id]",
    "datatype": "entity",
    "object": "entity",
    "url_example": "http://www.maizegdb.org/cgi-bin/displaytraitrecord.cgi?id=78112"
  },
  "soy_qtl": {
    "abbreviation": "SOY_QTL",
    "fullname": null,
    "id": "SOY_QTL",
    "uri_prefix": null,
    "generic_url": "https://soybase.org/",
    "name": "SoyBase",
    "example_id": "Seedling, abnormal+1-1",
    "datatype": "entity",
    "url_syntax": "https://www.soybase.org/sbt/search/search_results.php?category=QTLName&search_term=[example_id]",
    "database": "SoyBase",
    "object": "entity",
    "url_example": "https://www.soybase.org/sbt/search/search_results.php?category=QTLName&search_term=Seedling,+abnormal+1-1"
  },
  "casref": {
    "name": "Catalog of Fishes publications database",
    "example_id": "CASREF:2031",
    "fullname": null,
    "id": "CASREF",
    "abbreviation": "CASREF",
    "uri_prefix": null,
    "generic_url": "https://researcharchive.calacademy.org/research/ichthyology/catalog/fishcatmain.asp",
    "object": "entity",
    "url_example": "https://researcharchive.calacademy.org/research/ichthyology/catalog/getref.asp?id=2031",
    "datatype": "entity",
    "url_syntax": "https://researcharchive.calacademy.org/research/ichthyology/catalog/getref.asp?id=[example_id]",
    "database": "Catalog of Fishes publications database"
  },
  "sgd": {
    "example_id": "SGD:S000006169",
    "name": "Saccharomyces Genome Database",
    "fullname": null,
    "abbreviation": "SGD",
    "id": "SGD",
    "generic_url": "http://www.yeastgenome.org/",
    "uri_prefix": null,
    "object": "gene",
    "url_example": "https://www.yeastgenome.org/search?q=S000006169&is_quick=true",
    "database": "Saccharomyces Genome Database",
    "url_syntax": "https://www.yeastgenome.org/search?q=[example_id]&is_quick=true",
    "datatype": "gene"
  },
  "irgc": {
    "url_example": "https://www.genesys-pgr.org/acn/search?q=IRGC+10013",
    "object": "entity",
    "url_syntax": "https://www.genesys-pgr.org/acn/search?q=IRGC+[example_id]",
    "datatype": "entity",
    "database": "International Rice Genebank Collection",
    "name": "International Rice Genebank Collection",
    "example_id": "IRGC:10012",
    "fullname": null,
    "id": "IRGC",
    "abbreviation": "IRGC",
    "uri_prefix": null,
    "generic_url": "https://www.genesys-pgr.org"
  },
  "fbdv": {
    "example_id": "FBdv:00007012",
    "name": "Drosophila development",
    "generic_url": "http://flybase.org/",
    "uri_prefix": null,
    "abbreviation": "FBdv",
    "fullname": null,
    "id": "FBdv",
    "object": "life cycle stage",
    "url_example": "http://flybase.org/cgi-bin/fbcvq.html?query=FBdv:00007012",
    "database": "Drosophila development",
    "datatype": "life cycle stage",
    "url_syntax": "http://flybase.org/cgi-bin/fbcvq.html?query=FBdv:[example_id]"
  },
  "eco": {
    "url_syntax": "http://www.evidenceontology.org/browse/#ECO_[example_id]",
    "datatype": "entity",
    "database": "Evidence Code Ontology",
    "url_example": "http://www.evidenceontology.org/browse/#ECO_0000315",
    "object": "entity",
    "uri_prefix": null,
    "generic_url": "http://www.evidenceontology.org/",
    "id": "ECO",
    "fullname": null,
    "abbreviation": "ECO",
    "name": "Evidence Code Ontology",
    "example_id": "ECO:0000315"
  },
  "omim": {
    "generic_url": "https://omim.org/",
    "uri_prefix": null,
    "id": "OMIM",
    "fullname": null,
    "abbreviation": "OMIM",
    "example_id": "OMIM:190198",
    "name": "Mendelian Inheritance in Man",
    "database": "Mendelian Inheritance in Man",
    "datatype": "entity",
    "url_syntax": "https://omim.org/entry/[example_id]",
    "url_example": "https://omim.org/entry/190198",
    "object": "entity"
  },
  "alphafold": {
    "name": "AlphaFold Protein Structure Database",
    "example_id": "AlphaFold:Q5VSL9",
    "uri_prefix": null,
    "generic_url": "https://alphafold.ebi.ac.uk/",
    "abbreviation": "AlphaFold",
    "fullname": null,
    "id": "AlphaFold",
    "object": "protein",
    "url_example": "https://alphafold.ebi.ac.uk/entry/Q5VSL9",
    "datatype": "protein",
    "url_syntax": "https://alphafold.ebi.ac.uk/entry/[example_id]",
    "database": "AlphaFold Protein Structure Database"
  },
  "gr": {
    "url_syntax": "http://www.gramene.org/db/searches/browser?search_type=All&RGN=on&query=[example_id]",
    "datatype": "protein",
    "database": "Gramene",
    "object": "protein",
    "url_example": "http://www.gramene.org/db/searches/browser?search_type=All&RGN=on&query=sd1",
    "uri_prefix": null,
    "generic_url": "http://www.gramene.org/",
    "abbreviation": "GR",
    "fullname": null,
    "id": "GR",
    "name": "Gramene",
    "example_id": "GR:sd1"
  },
  "syscilia_ccnet": {
    "url_syntax": null,
    "datatype": "entity",
    "database": "Syscilia",
    "object": "entity",
    "url_example": null,
    "id": "SYSCILIA_CCNET",
    "fullname": "A systems biology approach to dissect cilia function and its disruption in human genetic disease",
    "abbreviation": "SYSCILIA_CCNET",
    "uri_prefix": null,
    "generic_url": "http://syscilia.org/",
    "name": "Syscilia",
    "example_id": null
  },
  "treegenes": {
    "url_example": "http://dendrome.ucdavis.edu/treegenes/protein/view_protein.php?id=254",
    "object": "entity",
    "database": "Forest Tree Genome Database",
    "url_syntax": "http://dendrome.ucdavis.edu/treegenes/protein/view_protein.php?id=[example_id]",
    "datatype": "entity",
    "example_id": "TreeGenes:254",
    "name": "Forest Tree Genome Database",
    "generic_url": "http://dendrome.ucdavis.edu/treegenes/",
    "uri_prefix": null,
    "fullname": null,
    "abbreviation": "TreeGenes",
    "id": "TreeGenes"
  },
  "kegg_pathway": {
    "example_id": "KEGG_PATHWAY:ot00020",
    "name": "KEGG Pathways Database",
    "generic_url": "http://www.genome.jp/kegg/pathway.html",
    "uri_prefix": null,
    "fullname": null,
    "abbreviation": "KEGG_PATHWAY",
    "id": "KEGG_PATHWAY",
    "object": "entity",
    "url_example": "http://www.genome.jp/dbget-bin/www_bget?path:ot00020",
    "database": "KEGG Pathways Database",
    "datatype": "entity",
    "url_syntax": "http://www.genome.jp/dbget-bin/www_bget?path:[example_id]"
  },
  "po_git": {
    "name": "GitHub Issue Tracker for PO",
    "example_id": "PO_GIT:626",
    "uri_prefix": null,
    "generic_url": "https://github.com/Planteome/plant-ontology",
    "fullname": null,
    "id": "PO_GIT",
    "abbreviation": "PO_GIT",
    "url_example": "https://github.com/Planteome/plant-ontology/issues/626",
    "object": "entity",
    "url_syntax": "https://github.com/Planteome/plant-ontology/issues/[example_id]",
    "datatype": "entity",
    "database": "GitHub Issue Tracker for PO"
  },
  "pubchem_substance": {
    "uri_prefix": null,
    "generic_url": "https://pubchem.ncbi.nlm.nih.gov",
    "fullname": null,
    "abbreviation": "PubChem_Substance",
    "id": "PubChem_Substance",
    "name": "NCBI PubChem database of chemical substances",
    "example_id": "PubChem_Substance:4594",
    "url_syntax": "https://pubchem.ncbi.nlm.nih.gov/substance/[example_id]",
    "datatype": "chemical entity",
    "database": "NCBI PubChem database of chemical substances",
    "object": "chemical entity",
    "url_example": "https://pubchem.ncbi.nlm.nih.gov/substance/4594"
  },
  "orcid": {
    "datatype": "entity",
    "url_syntax": "https://orcid.org/[example_id]",
    "database": "Open Researcher and Contributor",
    "url_example": "https://orcid.org/0000-0003-4423-4370",
    "object": "entity",
    "uri_prefix": null,
    "generic_url": "https://orcid.org/",
    "fullname": "ORCID (Open Researcher and Contributor ID) is an open, non-profit, community-based effort to create and maintain a registry of unique identifiers for individual researchers.",
    "id": "orcid",
    "abbreviation": "orcid",
    "name": "Open Researcher and Contributor",
    "example_id": "orcid:0000-0003-4423-4370"
  },
  "tfclass": {
    "generic_url": "http://tfclass.bioinf.med.uni-goettingen.de/",
    "uri_prefix": null,
    "fullname": null,
    "id": "TFClass",
    "abbreviation": "tfclass",
    "example_id": "TFCLASS_FAMILY:2.1.1",
    "name": "TFClass is a resource for the classification of eukaryotic transcription factors based on the characteristics of their DNA-binding domains",
    "database": "TFClass is a resource for the classification of eukaryotic transcription factors based on the characteristics of their DNA-binding domains",
    "datatype": "protein",
    "url_syntax": "http://tfclass.bioinf.med.uni-goettingen.de/?tfclass=[example_id]",
    "object": "protein",
    "url_example": "http://tfclass.bioinf.med.uni-goettingen.de/?tfclass=2.1.1"
  },
  "iptmnet": {
    "url_example": "https://research.bioinformatics.udel.edu/iptmnet/entry/P06493/",
    "object": "entity",
    "datatype": "entity",
    "url_syntax": "https://research.bioinformatics.udel.edu/iptmnet/entry/[example_id]/",
    "database": "iPTMnet protein post-translational modification database",
    "name": "iPTMnet protein post-translational modification database",
    "example_id": "iPTM:P06493",
    "id": "iPTMnet",
    "fullname": null,
    "abbreviation": "iPTMnet",
    "uri_prefix": null,
    "generic_url": "https://research.bioinformatics.udel.edu/iptmnet/"
  },
  "tfclass_family": {
    "name": "TFClass is a resource for the classification of eukaryotic transcription factors based on the characteristics of their DNA-binding domains",
    "example_id": "TFCLASS_FAMILY:2.1.1",
    "abbreviation": "TFCLASS_FAMILY",
    "fullname": null,
    "id": "TFClass",
    "uri_prefix": null,
    "generic_url": "http://tfclass.bioinf.med.uni-goettingen.de/",
    "object": "protein",
    "url_example": "http://tfclass.bioinf.med.uni-goettingen.de/?tfclass=2.1.1",
    "url_syntax": "http://tfclass.bioinf.med.uni-goettingen.de/?tfclass=[example_id]",
    "datatype": "protein",
    "database": "TFClass is a resource for the classification of eukaryotic transcription factors based on the characteristics of their DNA-binding domains"
  },
  "hugo": {
    "object": "entity",
    "url_example": null,
    "database": "Human Genome Organisation",
    "url_syntax": null,
    "datatype": "entity",
    "example_id": null,
    "name": "Human Genome Organisation",
    "abbreviation": "HUGO",
    "fullname": null,
    "id": "HUGO",
    "generic_url": "http://www.hugo-international.org/",
    "uri_prefix": null
  },
  "ncbi_gi": {
    "name": "NCBI databases",
    "example_id": "NCBI_gi:113194944",
    "uri_prefix": null,
    "generic_url": "http://www.ncbi.nlm.nih.gov/",
    "id": "NCBI_gi",
    "fullname": null,
    "abbreviation": "NCBI_gi",
    "url_example": "http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?val=113194944",
    "object": "gene",
    "url_syntax": "http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?val=[example_id]",
    "datatype": "gene",
    "database": "NCBI databases"
  },
  "gr_ref": {
    "name": "Gramene",
    "example_id": "GR_REF:659",
    "fullname": null,
    "abbreviation": "GR_REF",
    "id": "GR_REF",
    "uri_prefix": null,
    "generic_url": "http://www.gramene.org/",
    "url_example": "http://www.gramene.org/db/literature/pub_search?ref_id=659",
    "object": "entity",
    "datatype": "entity",
    "url_syntax": "http://www.gramene.org/db/literature/pub_search?ref_id=[example_id]",
    "database": "Gramene"
  },
  "reac": {
    "id": "Reactome",
    "fullname": null,
    "abbreviation": "REAC",
    "generic_url": "https://www.reactome.org/",
    "uri_prefix": null,
    "example_id": "Reactome:R-HSA-109582",
    "name": "Reactome - a curated knowledgebase of biological pathways",
    "database": "Reactome - a curated knowledgebase of biological pathways",
    "url_syntax": "https://www.reactome.org/content/detail/[example_id]",
    "datatype": "entity",
    "object": "entity",
    "url_example": "https://www.reactome.org/content/detail/R-HSA-109582"
  },
  "embl": {
    "object": "gene",
    "url_example": "http://www.ebi.ac.uk/cgi-bin/emblfetch?style=html&Submit=Go&id=AA816246",
    "database": "EMBL Nucleotide Sequence Database",
    "url_syntax": "http://www.ebi.ac.uk/cgi-bin/emblfetch?style=html&Submit=Go&id=[example_id]",
    "datatype": "gene",
    "example_id": "EMBL:AA816246",
    "name": "EMBL Nucleotide Sequence Database",
    "abbreviation": "EMBL",
    "fullname": "International nucleotide sequence database collaboration, comprising EMBL-EBI nucleotide sequence data library (EMBL-Bank), DNA DataBank of Japan (DDBJ), and NCBI GenBank",
    "id": "EMBL",
    "generic_url": "http://www.ebi.ac.uk/embl/",
    "uri_prefix": null
  },
  "pro": {
    "uri_prefix": null,
    "generic_url": "https://proconsortium.org/",
    "id": "PR",
    "fullname": null,
    "abbreviation": "PRO",
    "name": "Protein Ontology",
    "example_id": "PR:Q64445",
    "url_syntax": "https://purl.obolibrary.org/obo/PR_[example_id]",
    "datatype": "protein",
    "database": "Protein Ontology",
    "url_example": "https://purl.obolibrary.org/obo/PR_000060258",
    "object": "protein"
  },
  "cl": {
    "fullname": null,
    "abbreviation": "CL",
    "id": "CL",
    "generic_url": "http://cellontology.org",
    "uri_prefix": null,
    "example_id": "CL:0000041",
    "name": "Cell Type Ontology",
    "database": "Cell Type Ontology",
    "url_syntax": "http://purl.obolibrary.org/obo/CL_[example_id]",
    "datatype": "cell",
    "object": "cell",
    "url_example": "http://purl.obolibrary.org/obo/CL_0000041"
  },
  "wbphenotype": {
    "database": "WormBase phenotype ontology",
    "url_syntax": "http://www.wormbase.org/get?name=[example_id]",
    "datatype": "quality",
    "object": "quality",
    "url_example": "http://www.wormbase.org/get?name=WBPhenotype:0002117",
    "id": "WBPhenotype",
    "fullname": null,
    "abbreviation": "WBPhenotype",
    "generic_url": "http://www.wormbase.org/",
    "uri_prefix": null,
    "example_id": "WBPhenotype:0002117",
    "name": "WormBase phenotype ontology"
  },
  "ensembl": {
    "database": "Ensembl database of automatically annotated genomic data",
    "datatype": "transcript",
    "url_syntax": "http://www.ensembl.org/id/[example_id]",
    "url_example": "http://www.ensembl.org/id/ENSP00000265949",
    "object": "transcript",
    "generic_url": "http://www.ensembl.org/",
    "uri_prefix": null,
    "abbreviation": "ensembl",
    "fullname": null,
    "id": "ENSEMBL",
    "example_id": "ENSEMBL:ENSP00000265949",
    "name": "Ensembl database of automatically annotated genomic data"
  },
  "ec": {
    "url_example": "https://enzyme.expasy.org/EC/1.1.1.1",
    "object": "catalytic activity",
    "database": "Enzyme Commission",
    "url_syntax": "https://enzyme.expasy.org/EC/[example_id]",
    "datatype": "catalytic activity",
    "example_id": "EC:1.1.1.1",
    "name": "Enzyme Commission",
    "abbreviation": "EC",
    "fullname": null,
    "id": "EC",
    "generic_url": "http://enzyme.expasy.org/",
    "uri_prefix": null
  },
  "genbank": {
    "uri_prefix": null,
    "generic_url": "http://www.ncbi.nlm.nih.gov/Genbank/",
    "abbreviation": "GenBank",
    "fullname": "The NIH genetic sequence database, an annotated collection of all publicly available DNA sequences.",
    "id": "GenBank",
    "name": "GenBank",
    "example_id": "GB:AA816246",
    "datatype": "protein",
    "url_syntax": "http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?db=nucleotide&val=[example_id]",
    "database": "GenBank",
    "object": "protein",
    "url_example": "http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?db=nucleotide&val=AA816246"
  },
  "kegg_reaction": {
    "example_id": "KEGG:R02328",
    "name": "KEGG Reaction Database",
    "generic_url": "http://www.genome.jp/kegg/reaction/",
    "uri_prefix": null,
    "abbreviation": "KEGG_REACTION",
    "fullname": null,
    "id": "KEGG_REACTION",
    "url_example": "http://www.genome.jp/dbget-bin/www_bget?rn:R02328",
    "object": "entity",
    "database": "KEGG Reaction Database",
    "datatype": "entity",
    "url_syntax": "http://www.genome.jp/dbget-bin/www_bget?rn:[example_id]"
  },
  "gonuts": {
    "database": "Gene Ontology Normal Usage Tracking System (GONUTS)",
    "url_syntax": "https://gowiki.tamu.edu/wiki/index.php/[example_id]",
    "datatype": "entity",
    "url_example": "https://gowiki.tamu.edu/wiki/index.php/MOUSE:CD28",
    "object": "entity",
    "generic_url": "http://gowiki.tamu.edu",
    "uri_prefix": null,
    "fullname": "Third party documentation for GO and community annotation system.",
    "abbreviation": "GONUTS",
    "id": "GONUTS",
    "example_id": "GONUTS:MOUSE:CD28",
    "name": "Gene Ontology Normal Usage Tracking System (GONUTS)"
  },
  "caro": {
    "object": "entity",
    "url_example": "http://purl.obolibrary.org/obo/CARO_0020003",
    "database": "Common Anatomy Reference Ontology",
    "url_syntax": "http://purl.obolibrary.org/obo/CARO_[example_id]",
    "datatype": "entity",
    "example_id": "CARO:0020003",
    "name": "Common Anatomy Reference Ontology",
    "generic_url": "http://purl.obolibrary.org/obo/caro",
    "uri_prefix": null,
    "abbreviation": "CARO",
    "fullname": "An upper ontology for anatomy used by OBO Foundry ontologies. Used to facilitate interoperability between existing anatomy ontologies for different species",
    "id": "CARO"
  },
  "phi-base": {
    "url_example": "http://www.phi-base.org/searchFacet.htm?queryTerm=PHI:3",
    "object": "entity",
    "database": "Pathogen-Host Interactions Database",
    "datatype": "entity",
    "url_syntax": "http://www.phi-base.org/searchFacet.htm?queryTerm=PHI:[example_id]",
    "example_id": "PHI:3",
    "name": "Pathogen-Host Interactions Database",
    "generic_url": "http://www.phi-base.org/",
    "uri_prefix": null,
    "id": "PHI-base",
    "fullname": "PHI-base catalogues experimentally verified pathogenicity, virulence and effector genes from fungal, Oomycete and bacterial pathogens, which infect animal, plant, fungal and insect hosts.",
    "abbreviation": "PHI-base"
  },
  "maizegdb_qtl": {
    "example_id": "MaizeGDB_QTL:78112",
    "name": "Maize Genetics and Genomics Database",
    "fullname": null,
    "id": "MaizeGDB_QTL",
    "abbreviation": "MaizeGDB_QTL",
    "generic_url": "https://www.maizegdb.org/",
    "uri_prefix": null,
    "object": "entity",
    "url_example": "https://www.maizegdb.org/data_center/trait?id=78112",
    "database": "Maize Genetics and Genomics Database",
    "datatype": "entity",
    "url_syntax": "https://www.maizegdb.org/data_center/trait?id=[example_id]"
  },
  "pubchem_bioassay": {
    "abbreviation": "PubChem_BioAssay",
    "fullname": null,
    "id": "PubChem_BioAssay",
    "generic_url": "https://pubchem.ncbi.nlm.nih.gov",
    "uri_prefix": null,
    "example_id": "PubChem_BioAssay:177",
    "name": "NCBI PubChem database of bioassay records",
    "database": "NCBI PubChem database of bioassay records",
    "datatype": "entity",
    "url_syntax": "https://pubchem.ncbi.nlm.nih.gov/bioassay/[example_id]",
    "url_example": "https://pubchem.ncbi.nlm.nih.gov/bioassay/177",
    "object": "entity"
  },
  "aspgd": {
    "example_id": "AspGD:ASPL0000067538",
    "name": "Aspergillus Genome Database",
    "generic_url": "http://www.aspergillusgenome.org/",
    "uri_prefix": null,
    "fullname": null,
    "id": "AspGD",
    "abbreviation": "ASPGD",
    "url_example": "http://www.aspergillusgenome.org/cgi-bin/locus.pl?dbid=ASPL0000067538",
    "object": "gene",
    "database": "Aspergillus Genome Database",
    "datatype": "gene",
    "url_syntax": "http://www.aspergillusgenome.org/cgi-bin/locus.pl?dbid=[example_id]"
  },
  "goc-owl": {
    "example_id": null,
    "name": "Gene Ontology Consortium - Logical inferences",
    "abbreviation": "GOC-OWL",
    "fullname": null,
    "id": "GOC-OWL",
    "generic_url": "http://www.geneontology.org/",
    "uri_prefix": null,
    "url_example": null,
    "object": "entity",
    "database": "Gene Ontology Consortium - Logical inferences",
    "url_syntax": null,
    "datatype": "entity"
  },
  "parkinsonsuk-ucl": {
    "name": "Parkinsons Disease Gene Ontology Initiative",
    "example_id": null,
    "uri_prefix": null,
    "generic_url": "https://www.ucl.ac.uk/cardiovascular/research/pre-clinical-and-fundamental-science/functional-gene-annotation/neurological-gene",
    "abbreviation": "ParkinsonsUK-UCL",
    "fullname": null,
    "id": "ParkinsonsUK-UCL",
    "url_example": null,
    "object": "entity",
    "datatype": "entity",
    "url_syntax": null,
    "database": "Parkinsons Disease Gene Ontology Initiative"
  },
  "corum": {
    "name": "CORUM - the Comprehensive Resource of Mammalian protein complexes",
    "example_id": "CORUM:837",
    "uri_prefix": null,
    "generic_url": "https://mips.helmholtz-muenchen.de/corum/",
    "abbreviation": "CORUM",
    "fullname": null,
    "id": "CORUM",
    "url_example": "https://mips.helmholtz-muenchen.de/corum/?id=837",
    "object": "entity",
    "url_syntax": "https://mips.helmholtz-muenchen.de/corum/?id=[example_id]",
    "datatype": "entity",
    "database": "CORUM - the Comprehensive Resource of Mammalian protein complexes"
  },
  "um-bbd_pathwayid": {
    "object": "entity",
    "url_example": "http://eawag-bbd.ethz.ch/acr/acr_map.html",
    "database": "EAWAG Biocatalysis/Biodegradation Database",
    "url_syntax": "http://eawag-bbd.ethz.ch/[example_id]/[example_id]_map.html",
    "datatype": "entity",
    "example_id": "UM-BBD_pathwayID:acr",
    "name": "EAWAG Biocatalysis/Biodegradation Database",
    "fullname": null,
    "id": "UM-BBD_pathwayID",
    "abbreviation": "UM-BBD_pathwayID",
    "generic_url": "http://eawag-bbd.ethz.ch/",
    "uri_prefix": null
  },
  "dictybase": {
    "id": "dictyBase",
    "fullname": null,
    "abbreviation": "DictyBase",
    "uri_prefix": null,
    "generic_url": "http://dictybase.org",
    "name": "dictyBase",
    "example_id": "dictyBase:DDB_G0277859",
    "datatype": "gene",
    "url_syntax": "http://dictybase.org/gene/[example_id]",
    "database": "dictyBase",
    "object": "gene",
    "url_example": "http://dictybase.org/gene/DDB_G0277859"
  },
  "ensemblprotists": {
    "url_syntax": "http://www.ensemblgenomes.org/id/[example_id]",
    "datatype": "gene",
    "database": "Ensembl Protists, the Ensembl database for accessing genome-scale data from protists.",
    "url_example": "http://www.ensemblgenomes.org/id/PFL2550w",
    "object": "gene",
    "uri_prefix": null,
    "generic_url": "http://protists.ensembl.org/",
    "abbreviation": "EnsemblProtists",
    "fullname": null,
    "id": "EnsemblProtists",
    "name": "Ensembl Protists, the Ensembl database for accessing genome-scale data from protists.",
    "example_id": "EnsemblProtists:PFL2550w"
  },
  "merops_fam": {
    "url_syntax": "https://www.ebi.ac.uk/merops/cgi-bin/famsum?family=[example_id]",
    "datatype": "protein family",
    "database": "MEROPS peptidase database",
    "url_example": "https://www.ebi.ac.uk/merops/cgi-bin/famsum?family=M18",
    "object": "protein family",
    "uri_prefix": null,
    "generic_url": "https://www.ebi.ac.uk/merops",
    "fullname": null,
    "abbreviation": "MEROPS_fam",
    "id": "MEROPS_fam",
    "name": "MEROPS peptidase database",
    "example_id": "MEROPS_fam:M18"
  },
  "wormbase": {
    "url_example": "http://www.wormbase.org/get?name=CE00274",
    "object": "protein",
    "url_syntax": "http://www.wormbase.org/get?name=[example_id]",
    "datatype": "protein",
    "database": "WormBase database of nematode biology",
    "name": "WormBase database of nematode biology",
    "example_id": "WB:CE00274",
    "uri_prefix": null,
    "generic_url": "http://www.wormbase.org/",
    "id": "WB",
    "fullname": null,
    "abbreviation": "WormBase"
  },
  "uniprotkb": {
    "abbreviation": "UniProtKB",
    "fullname": "A central repository of protein sequence and function created by joining the information contained in Swiss-Prot, TrEMBL, and PIR database",
    "id": "UniProtKB",
    "uri_prefix": null,
    "generic_url": "http://www.uniprot.org",
    "name": "Universal Protein Knowledgebase",
    "example_id": "UniProtKB:P51587",
    "datatype": "protein",
    "url_syntax": "https://www.uniprot.org/uniprot/[example_id]",
    "database": "Universal Protein Knowledgebase",
    "url_example": "https://www.uniprot.org/uniprot/",
    "object": "protein"
  },
  "geo": {
    "uri_prefix": null,
    "generic_url": "http://www.ncbi.nlm.nih.gov/geo/",
    "abbreviation": "GEO",
    "fullname": null,
    "id": "GEO",
    "name": "NCBI Gene Expression Omnibus",
    "example_id": "GEO:GDS2223",
    "url_syntax": "http://www.ncbi.nlm.nih.gov/sites/GDSbrowser?acc=[example_id]",
    "datatype": "entity",
    "database": "NCBI Gene Expression Omnibus",
    "url_example": "http://www.ncbi.nlm.nih.gov/sites/GDSbrowser?acc=GDS2223",
    "object": "entity"
  },
  "ddb_ref": {
    "uri_prefix": null,
    "generic_url": "http://dictybase.org",
    "id": "dictyBase_REF",
    "fullname": null,
    "abbreviation": "DDB_REF",
    "name": "dictyBase literature references",
    "example_id": "dictyBase_REF:10157",
    "url_syntax": "http://dictybase.org/publication/[example_id]",
    "datatype": "entity",
    "database": "dictyBase literature references",
    "url_example": "http://dictybase.org/publication/10157",
    "object": "entity"
  },
  "pir": {
    "fullname": null,
    "abbreviation": "PIR",
    "id": "PIR",
    "generic_url": "https://proteininformationresource.org/",
    "uri_prefix": null,
    "example_id": "PIR:I49499",
    "name": "Protein Information Resource",
    "database": "Protein Information Resource",
    "datatype": "protein",
    "url_syntax": "https://proteininformationresource.org/cgi-bin/nbrfget?uid=[example_id]",
    "url_example": "https://proteininformationresource.org/cgi-bin/nbrfget?uid=I49499",
    "object": "protein"
  },
  "maizegdb_locus": {
    "url_example": "https://www.maizegdb.org/gene_center/gene/25011",
    "object": "gene",
    "database": "MaizeGDB",
    "url_syntax": "https://www.maizegdb.org/gene_center/gene/[example_id]",
    "datatype": "gene",
    "example_id": "MaizeGDB_Locus:25011",
    "name": "MaizeGDB",
    "fullname": null,
    "abbreviation": "MaizeGDB_Locus",
    "id": "MaizeGDB_Locus",
    "generic_url": "https://www.maizegdb.org/",
    "uri_prefix": null
  },
  "ensemblplants/gramene": {
    "url_example": "http://www.ensemblgenomes.org/id/LOC_Os01g22954",
    "object": "gene",
    "database": "Ensembl Plants, the Ensembl database for accessing genome-scale data from plants.",
    "datatype": "gene",
    "url_syntax": "http://www.ensemblgenomes.org/id/[example_id]",
    "example_id": "EnsemblPlants:LOC_Os01g22954",
    "name": "Ensembl Plants, the Ensembl database for accessing genome-scale data from plants.",
    "abbreviation": "EnsemblPlants/Gramene",
    "fullname": null,
    "id": "EnsemblPlants",
    "generic_url": "http://plants.ensembl.org/",
    "uri_prefix": null
  },
  "ecoliwiki": {
    "url_example": null,
    "object": "gene",
    "url_syntax": null,
    "datatype": "gene",
    "database": "EcoliWiki from EcoliHub",
    "name": "EcoliWiki from EcoliHub",
    "example_id": null,
    "fullname": "EcoliHub\\'s subsystem for community annotation of E. coli K-12",
    "id": "EcoliWiki",
    "abbreviation": "EcoliWiki",
    "uri_prefix": null,
    "generic_url": "http://ecoliwiki.net/"
  },
  "gorel": {
    "example_id": null,
    "name": "GO Extensions to OBO Relation Ontology Ontology",
    "generic_url": "http://purl.obolibrary.org/obo/ro",
    "uri_prefix": null,
    "id": "GOREL",
    "fullname": "Additional relations pending addition into RO",
    "abbreviation": "GOREL",
    "url_example": null,
    "object": "entity",
    "database": "GO Extensions to OBO Relation Ontology Ontology",
    "url_syntax": null,
    "datatype": "entity"
  },
  "gr_qtl": {
    "database": "Gramene",
    "datatype": "entity",
    "url_syntax": "http://www.gramene.org/db/qtl/qtl_display?qtl_accession_id=[example_id]",
    "url_example": "http://www.gramene.org/db/qtl/qtl_display?qtl_accession_id=CQU7",
    "object": "entity",
    "generic_url": "http://www.gramene.org/",
    "uri_prefix": null,
    "fullname": null,
    "id": "GR_QTL",
    "abbreviation": "GR_QTL",
    "example_id": "GR_QTL:CQU7",
    "name": "Gramene"
  },
  "omssa": {
    "database": "Open Mass Spectrometry Search Algorithm",
    "url_syntax": null,
    "datatype": "entity",
    "url_example": null,
    "object": "entity",
    "generic_url": "http://pubchem.ncbi.nlm.nih.gov/omssa/",
    "uri_prefix": null,
    "abbreviation": "OMSSA",
    "fullname": null,
    "id": "OMSSA",
    "example_id": null,
    "name": "Open Mass Spectrometry Search Algorithm"
  },
  "eo_git": {
    "object": "entity",
    "url_example": "https://github.com/Planteome/plant-environment-ontology/issues/76",
    "url_syntax": "https://github.com/Planteome/plant-environment-ontology/issues/[example_id]",
    "datatype": "entity",
    "database": "GitHub Issue Tracker for EO",
    "name": "GitHub Issue Tracker for EO",
    "example_id": "EO_GIT:76",
    "uri_prefix": null,
    "generic_url": "https://github.com/Planteome/plant-environment-ontology",
    "fullname": null,
    "id": "EO_GIT",
    "abbreviation": "EO_GIT"
  },
  "alzheimers_university_of_toronto": {
    "object": "entity",
    "url_example": null,
    "database": "Alzheimers Project at University of Toronto",
    "datatype": "entity",
    "url_syntax": null,
    "example_id": null,
    "name": "Alzheimers Project at University of Toronto",
    "generic_url": "http://www.ims.utoronto.ca/",
    "uri_prefix": null,
    "fullname": null,
    "abbreviation": "Alzheimers_University_of_Toronto",
    "id": "Alzheimers_University_of_Toronto"
  },
  "agricola_ind": {
    "url_syntax": null,
    "datatype": "entity",
    "database": "AGRICultural OnLine Access",
    "url_example": null,
    "object": "entity",
    "uri_prefix": null,
    "generic_url": "http://agricola.nal.usda.gov/",
    "abbreviation": "AGRICOLA_IND",
    "fullname": null,
    "id": "AGRICOLA_IND",
    "name": "AGRICultural OnLine Access",
    "example_id": "AGRICOLA_IND:IND23252955"
  },
  "go": {
    "url_example": "http://amigo.geneontology.org/amigo/term/GO:0044776",
    "object": "macromolecular complex",
    "url_syntax": "http://amigo.geneontology.org/amigo/term/GO:[example_id]",
    "datatype": "macromolecular complex",
    "database": "Gene Ontology Database",
    "name": "Gene Ontology Database",
    "example_id": "GO:0044776",
    "uri_prefix": null,
    "generic_url": "http://amigo.geneontology.org/",
    "fullname": null,
    "abbreviation": "GO",
    "id": "GO"
  },
  "uberon": {
    "abbreviation": "UBERON",
    "fullname": "A multi-species anatomy ontology",
    "id": "UBERON",
    "uri_prefix": null,
    "generic_url": "http://uberon.org",
    "name": "Uber-anatomy ontology",
    "example_id": "UBERON:0000069",
    "datatype": "life cycle stage",
    "url_syntax": "http://purl.obolibrary.org/obo/UBERON_[example_id]",
    "database": "Uber-anatomy ontology",
    "object": "life cycle stage",
    "url_example": null
  },
  "nasc": {
    "name": "Nottingham Arabidopsis Stock Centre Seeds Database",
    "example_id": "NASC_code:N3371",
    "abbreviation": "NASC",
    "fullname": null,
    "id": "NASC_code",
    "uri_prefix": null,
    "generic_url": "http://arabidopsis.info",
    "object": "entity",
    "url_example": "http://seeds.nottingham.ac.uk/NASC/stockatidb.lasso?code=N3371",
    "url_syntax": "http://seeds.nottingham.ac.uk/NASC/stockatidb.lasso?code=[example_id]",
    "datatype": "entity",
    "database": "Nottingham Arabidopsis Stock Centre Seeds Database"
  },
  "plasmodb": {
    "abbreviation": "PlasmoDB",
    "fullname": null,
    "id": "PlasmoDB",
    "uri_prefix": null,
    "generic_url": "https://plasmodb.org",
    "name": "PlasmoDB",
    "example_id": "PF3D7_1467300",
    "url_syntax": "https://plasmodb.org/plasmo/app/record/gene/[example_id]",
    "datatype": "gene",
    "database": "PlasmoDB",
    "object": "gene",
    "url_example": "https://plasmodb.org/plasmo/app/record/gene/PF3D7_1467300"
  },
  "agi_locuscode": {
    "url_syntax": "http://arabidopsis.org/servlets/TairObject?type=locus&name=[example_id]",
    "datatype": "gene",
    "database": "Arabidopsis Genome Initiative",
    "object": "gene",
    "url_example": "https://www.arabidopsis.org/servlets/TairObject?type=locus&name=At2g17950",
    "fullname": "Comprises TAIR, TIGR and MIPS",
    "abbreviation": "AGI_LocusCode",
    "id": "AGI_LocusCode",
    "uri_prefix": null,
    "generic_url": "http://www.arabidopsis.org",
    "name": "Arabidopsis Genome Initiative",
    "example_id": "AGI_LocusCode:At2g17950"
  },
  "poc": {
    "example_id": null,
    "name": "Plant Ontology Consortium",
    "fullname": null,
    "id": "POC",
    "abbreviation": "POC",
    "generic_url": "http://www.plantontology.org/",
    "uri_prefix": null,
    "url_example": null,
    "object": "entity",
    "database": "Plant Ontology Consortium",
    "datatype": "entity",
    "url_syntax": null
  },
  "gene3d": {
    "object": "entity",
    "url_example": "http://gene3d.biochem.ucl.ac.uk/search?mode=family&sterm=3.30.390.30",
    "database": "Domain Architecture Classification",
    "url_syntax": "http://gene3d.biochem.ucl.ac.uk/search?mode=family&sterm=[example_id]",
    "datatype": "entity",
    "example_id": "Gene3D:3.30.390.30",
    "name": "Domain Architecture Classification",
    "fullname": null,
    "abbreviation": "Gene3D",
    "id": "Gene3D",
    "generic_url": "http://gene3d.biochem.ucl.ac.uk/Gene3D/",
    "uri_prefix": null
  },
  "coriell": {
    "name": "Coriell Institute for Medical Research",
    "example_id": "GM07892",
    "uri_prefix": null,
    "generic_url": "http://ccr.coriell.org/",
    "abbreviation": "CORIELL",
    "fullname": "The Coriell Cell Repositories provide essential research reagents to the scientific community by establishing, verifying, maintaining, and distributing cell cultures and DNA derived from cell cultures. These collections, supported by funds from the National Institutes of Health (NIH) and several foundations, are extensively utilized by research scientists around the world.",
    "id": "CORIELL",
    "url_example": "http://ccr.coriell.org/Sections/Search/Sample_Detail.aspx?Ref=GM07892",
    "object": "entity",
    "datatype": "entity",
    "url_syntax": "http://ccr.coriell.org/Sections/Search/Sample_Detail.aspx?Ref=[example_id]",
    "database": "Coriell Institute for Medical Research"
  },
  "chebi": {
    "object": "chemical entity",
    "url_example": "http://www.ebi.ac.uk/chebi/searchId.do?chebiId=CHEBI:17234",
    "database": "Chemical Entities of Biological Interest",
    "datatype": "chemical entity",
    "url_syntax": "http://www.ebi.ac.uk/chebi/searchId.do?chebiId=CHEBI:[example_id]",
    "example_id": "CHEBI:17234",
    "name": "Chemical Entities of Biological Interest",
    "generic_url": "http://www.ebi.ac.uk/chebi/",
    "uri_prefix": null,
    "id": "CHEBI",
    "fullname": null,
    "abbreviation": "ChEBI"
  },
  "tgd": {
    "url_example": null,
    "object": "entity",
    "datatype": "entity",
    "url_syntax": null,
    "database": "Tetrahymena Genome Database",
    "name": "Tetrahymena Genome Database",
    "example_id": null,
    "uri_prefix": null,
    "generic_url": "http://www.ciliate.org/",
    "fullname": null,
    "abbreviation": "TGD",
    "id": "TGD"
  },
  "so": {
    "fullname": null,
    "id": "SO",
    "abbreviation": "SO",
    "uri_prefix": null,
    "generic_url": "http://www.sequenceontology.org/",
    "name": "Sequence Ontology",
    "example_id": "SO:0001166",
    "datatype": "sequence motif",
    "url_syntax": "http://www.sequenceontology.org/browser/current_svn/term/SO:[example_id]",
    "database": "Sequence Ontology",
    "object": "sequence motif",
    "url_example": "http://www.sequenceontology.org/browser/current_svn/term/SO:0001166"
  },
  "sgn_germplasm": {
    "fullname": null,
    "abbreviation": "SGN_germplasm",
    "id": "SGN_germplasm",
    "generic_url": "https://solgenomics.net/",
    "uri_prefix": null,
    "example_id": "SGN_germplasm:6583",
    "name": "Sol Genomics Network",
    "database": "Sol Genomics Network",
    "url_syntax": "http://solgenomics.net/stock/[example_id]/view/",
    "datatype": "entity",
    "url_example": "http://solgenomics.net/stock/6583/view/",
    "object": "entity"
  },
  "arba": {
    "object": "entity",
    "url_example": "https://www.uniprot.org/arba/ARBA00000001",
    "database": "ARBA machine learning models for automatic annotation of UniProtKB unreviewed entries",
    "datatype": "entity",
    "url_syntax": "https://www.uniprot.org/arba/[example_id]",
    "example_id": "ARBA:ARBA00000001",
    "name": "ARBA machine learning models for automatic annotation of UniProtKB unreviewed entries",
    "fullname": null,
    "id": "ARBA",
    "abbreviation": "ARBA",
    "generic_url": "https://www.uniprot.org/arba/",
    "uri_prefix": null
  },
  "rgdid": {
    "datatype": "gene",
    "url_syntax": "https://rgd.mcw.edu/rgdweb/search/search.html?term=[example_id]",
    "database": "Rat Genome Database",
    "object": "gene",
    "url_example": "https://rgd.mcw.edu/rgdweb/search/search.html?term=2004",
    "id": "RGD",
    "fullname": null,
    "abbreviation": "RGDID",
    "uri_prefix": null,
    "generic_url": "https://rgd.mcw.edu/",
    "name": "Rat Genome Database",
    "example_id": "RGD:2004"
  },
  "asap": {
    "object": "gene",
    "url_example": "https://asap.genetics.wisc.edu/asap/feature_info.php?FeatureID=ABF-0014586",
    "datatype": "gene",
    "url_syntax": "https://asap.genetics.wisc.edu/asap/feature_info.php?FeatureID=[example_id]",
    "database": "A Systematic Annotation Package for Community Analysis of Genomes",
    "name": "A Systematic Annotation Package for Community Analysis of Genomes",
    "example_id": "ASAP:ABF-0014586",
    "id": "ASAP",
    "fullname": null,
    "abbreviation": "ASAP",
    "uri_prefix": null,
    "generic_url": "https://asap.genetics.wisc.edu/asap/ASAP1.htm"
  },
  "gomodel": {
    "url_example": "https://model.geneontology.org/5ae3b0f600001522",
    "object": "model",
    "datatype": "model",
    "url_syntax": "https://model.geneontology.org/[example_id]",
    "database": "Gene Ontology Causal Activity Model (GO-CAM)",
    "name": "Gene Ontology Causal Activity Model (GO-CAM)",
    "example_id": "gomodel:5ae3b0f600001522",
    "uri_prefix": null,
    "generic_url": "https://geneontology.org/go-cam",
    "fullname": null,
    "id": "gomodel",
    "abbreviation": "gomodel"
  },
  "disprot": {
    "uri_prefix": null,
    "generic_url": "https://www.disprot.org",
    "abbreviation": "DisProt",
    "fullname": "Database of intrinsically disordered proteins",
    "id": "DisProt",
    "name": "DisProt",
    "example_id": "DP00086",
    "url_syntax": "https://www.disprot.org/[example_id]",
    "datatype": "entity",
    "database": "DisProt",
    "object": "entity",
    "url_example": "https://www.disprot.org/DP00086"
  },
  "mgd": {
    "generic_url": "http://www.informatics.jax.org/",
    "uri_prefix": null,
    "fullname": null,
    "abbreviation": "MGD",
    "id": "MGD",
    "example_id": "MGD:Adcy9",
    "name": "Mouse Genome Database",
    "database": "Mouse Genome Database",
    "url_syntax": null,
    "datatype": "entity",
    "object": "entity",
    "url_example": null
  },
  "modbase": {
    "url_example": "http://salilab.org/modbase/searchbyid?databaseID=P04848",
    "object": "entity",
    "database": "ModBase comprehensive Database of Comparative Protein Structure Models",
    "datatype": "entity",
    "url_syntax": "http://salilab.org/modbase/searchbyid?databaseID=[example_id]",
    "example_id": "ModBase:P10815",
    "name": "ModBase comprehensive Database of Comparative Protein Structure Models",
    "generic_url": "http://modbase.compbio.ucsf.edu/",
    "uri_prefix": null,
    "id": "ModBase",
    "fullname": null,
    "abbreviation": "ModBase"
  },
  "ncbi_gene": {
    "uri_prefix": null,
    "generic_url": "http://www.ncbi.nlm.nih.gov/",
    "abbreviation": "NCBI_Gene",
    "fullname": null,
    "id": "NCBIGene",
    "name": "NCBI Gene",
    "example_id": "NCBI_Gene:4771",
    "datatype": "gene",
    "url_syntax": "https://www.ncbi.nlm.nih.gov/gene/[example_id]",
    "database": "NCBI Gene",
    "url_example": "https://www.ncbi.nlm.nih.gov/gene/4771",
    "object": "gene"
  },
  "tigr_tigrfams": {
    "example_id": "TIGRFAMS:TIGR00254",
    "name": "TIGRFAMs HMM collection at the J. Craig Venter Institute",
    "id": "TIGRFAMS",
    "fullname": null,
    "abbreviation": "TIGR_TIGRFAMS",
    "generic_url": "http://tigrfams.jcvi.org/cgi-bin/index.cgi",
    "uri_prefix": null,
    "url_example": "http://tigrfams.jcvi.org/cgi-bin/HmmReportPage.cgi?acc=TIGR00254",
    "object": "polypeptide region",
    "database": "TIGRFAMs HMM collection at the J. Craig Venter Institute",
    "datatype": "polypeptide region",
    "url_syntax": "http://tigrfams.jcvi.org/cgi-bin/HmmReportPage.cgi?acc=[example_id]"
  },
  "aspgd_locus": {
    "datatype": "entity",
    "url_syntax": "http://www.aspergillusgenome.org/cgi-bin/locus.pl?locus=[example_id]",
    "database": "Aspergillus Genome Database",
    "object": "entity",
    "url_example": "http://www.aspergillusgenome.org/cgi-bin/locus.pl?locus=AN10942",
    "uri_prefix": null,
    "generic_url": "http://www.aspergillusgenome.org/",
    "fullname": null,
    "abbreviation": "AspGD_LOCUS",
    "id": "AspGD_LOCUS",
    "name": "Aspergillus Genome Database",
    "example_id": "AspGD_LOCUS:AN10942"
  },
  "ncbi_locus_tag": {
    "datatype": "entity",
    "url_syntax": null,
    "database": "NCBI locus tag",
    "url_example": null,
    "object": "entity",
    "id": "NCBI_locus_tag",
    "fullname": null,
    "abbreviation": "NCBI_locus_tag",
    "uri_prefix": null,
    "generic_url": "http://www.ncbi.nlm.nih.gov/",
    "name": "NCBI locus tag",
    "example_id": "NCBI_locus_tag:CTN_0547"
  },
  "fbbt": {
    "database": "Drosophila gross anatomy",
    "url_syntax": "http://flybase.org/cgi-bin/fbcvq.html?query=FBbt:[example_id]",
    "datatype": "anatomical entity",
    "url_example": "http://flybase.org/cgi-bin/fbcvq.html?query=FBbt:10000000",
    "object": "anatomical entity",
    "id": "FBbt",
    "fullname": null,
    "abbreviation": "FBbt",
    "generic_url": "http://flybase.org/",
    "uri_prefix": null,
    "example_id": "FBbt:10000000",
    "name": "Drosophila gross anatomy"
  },
  "jaiswal_lab": {
    "name": "Jaiswal_Lab",
    "example_id": "Jaiswal_Lab:gene00002",
    "uri_prefix": null,
    "generic_url": "http://wiki.plantontology.org/index.php/PO_REF:00008",
    "fullname": null,
    "id": "Jaiswal_Lab",
    "abbreviation": "Jaiswal_Lab",
    "object": "entity",
    "url_example": "http://wiki.plantontology.org/index.php/PO_REF:00008",
    "url_syntax": "http://wiki.plantontology.org/index.php/PO_REF:00008",
    "datatype": "entity",
    "database": "Jaiswal_Lab"
  },
  "pubmed": {
    "database": "PubMed",
    "datatype": "entity",
    "url_syntax": "http://www.ncbi.nlm.nih.gov/pubmed/[example_id]",
    "url_example": "https://www.ncbi.nlm.nih.gov/pubmed/31931324",
    "object": "entity",
    "abbreviation": "PUBMED",
    "fullname": null,
    "id": "PMID",
    "generic_url": "https://www.ncbi.nlm.nih.gov/pubmed",
    "uri_prefix": null,
    "example_id": "PMID:31931324",
    "name": "PubMed"
  },
  "mod": {
    "uri_prefix": null,
    "generic_url": "http://www.psidev.info/groups/protein-modifications",
    "id": "PSI-MOD",
    "fullname": null,
    "abbreviation": "MOD",
    "name": "Proteomics Standards Initiative protein modification ontology",
    "example_id": "MOD_00219",
    "url_syntax": "http://purl.obolibrary.org/obo/[example_id]",
    "datatype": "entity",
    "database": "Proteomics Standards Initiative protein modification ontology",
    "url_example": "http://purl.obolibrary.org/obo/MOD_00219",
    "object": "entity"
  },
  "bfo": {
    "example_id": "BFO:0000066",
    "name": "Basic Formal Ontology",
    "generic_url": "http://purl.obolibrary.org/obo/bfo",
    "uri_prefix": null,
    "id": "BFO",
    "fullname": "An upper ontology used by Open Bio Ontologies (OBO) Foundry. BFO contains upper-level classes as well as core relations such as part_of (BFO_0000050)",
    "abbreviation": "BFO",
    "url_example": "http://purl.obolibrary.org/obo/BFO_0000066",
    "object": "entity",
    "database": "Basic Formal Ontology",
    "datatype": "entity",
    "url_syntax": "http://purl.obolibrary.org/obo/BFO_[example_id]"
  },
  "pombase": {
    "object": "transcript",
    "url_example": "https://www.pombase.org/gene/SPCC548.03c.2",
    "datatype": "transcript",
    "url_syntax": "https://www.pombase.org/gene/[example_id]",
    "database": "PomBase",
    "name": "PomBase",
    "example_id": "PomBase:SPCC548.03c.2",
    "abbreviation": "PomBase",
    "fullname": null,
    "id": "PomBase",
    "uri_prefix": null,
    "generic_url": "https://www.pombase.org/"
  },
  "yeastfunc": {
    "uri_prefix": null,
    "generic_url": "http://func.med.harvard.edu/yeast/",
    "id": "YeastFunc",
    "fullname": null,
    "abbreviation": "YeastFunc",
    "name": "Yeast Function",
    "example_id": null,
    "url_syntax": null,
    "datatype": "entity",
    "database": "Yeast Function",
    "url_example": null,
    "object": "entity"
  },
  "ddbj": {
    "database": "DNA Databank of Japan",
    "url_syntax": "http://getentry.ddbj.nig.ac.jp/getentry/na/[example_id]",
    "datatype": "entity",
    "url_example": "http://getentry.ddbj.nig.ac.jp/getentry/na/AA816246",
    "object": "entity",
    "generic_url": "https://www.ddbj.nig.ac.jp",
    "uri_prefix": null,
    "fullname": null,
    "abbreviation": "DDBJ",
    "id": "DDBJ",
    "example_id": "DDBJ:AA816246",
    "name": "DNA Databank of Japan"
  },
  "complexportal": {
    "url_example": "https://www.ebi.ac.uk/complexportal/complex/CPX-2158",
    "object": "macromolecular complex",
    "database": "Complex Portal database of macromolecular complexes",
    "datatype": "macromolecular complex",
    "url_syntax": "https://www.ebi.ac.uk/complexportal/complex/[example_id]",
    "example_id": "ComplexPortal:CPX-2158",
    "name": "Complex Portal database of macromolecular complexes",
    "generic_url": "https://www.ebi.ac.uk/complexportal",
    "uri_prefix": null,
    "fullname": null,
    "id": "ComplexPortal",
    "abbreviation": "ComplexPortal"
  },
  "po": {
    "uri_prefix": null,
    "generic_url": "http://www.planteome.org/",
    "id": "PO",
    "fullname": null,
    "abbreviation": "PO",
    "name": "Plant Ontology",
    "example_id": "PO:0025131",
    "url_syntax": "http://browser.planteome.org/amigo/term/PO:[example_id]",
    "datatype": "plant structure development stage",
    "database": "Plant Ontology",
    "url_example": "http://browser.planteome.org/amigo/term/PO:0025131",
    "object": "plant structure development stage"
  },
  "bto": {
    "url_example": "http://purl.obolibrary.org/obo/BTO_0002164",
    "object": "entity",
    "database": "BRENDA tissue / enzyme ontology",
    "url_syntax": "http://purl.obolibrary.org/obo/BTO_[example_id]",
    "datatype": "entity",
    "example_id": "BTO_0002164",
    "name": "BRENDA tissue / enzyme ontology",
    "generic_url": "http://purl.obolibrary.org/obo/bto",
    "uri_prefix": null,
    "fullname": "A structured controlled vocabulary for the source of an enzyme comprising tissues, cell lines, cell types and cell cultures.",
    "abbreviation": "BTO",
    "id": "BTO"
  },
  "ncbi_gp": {
    "example_id": "NCBI_GP:EAL72968",
    "name": "NCBI GenPept",
    "abbreviation": "NCBI_GP",
    "fullname": null,
    "id": "NCBI_GP",
    "generic_url": "http://www.ncbi.nlm.nih.gov/",
    "uri_prefix": null,
    "object": "protein",
    "url_example": "https://www.ncbi.nlm.nih.gov/protein/EAL72968",
    "database": "NCBI GenPept",
    "datatype": "protein",
    "url_syntax": "https://www.ncbi.nlm.nih.gov/protein/[example_id]"
  },
  "cog": {
    "object": "entity",
    "url_example": null,
    "datatype": "entity",
    "url_syntax": null,
    "database": "NCBI Clusters of Orthologous Groups",
    "name": "NCBI Clusters of Orthologous Groups",
    "example_id": null,
    "fullname": null,
    "id": "COG",
    "abbreviation": "COG",
    "uri_prefix": null,
    "generic_url": "http://www.ncbi.nlm.nih.gov/COG/"
  },
  "sgn_gene": {
    "example_id": "SGN_gene:7740",
    "name": "Sol Genomics Network",
    "generic_url": "https://www.sgn.cornell.edu/",
    "uri_prefix": null,
    "fullname": null,
    "abbreviation": "SGN_gene",
    "id": "SGN",
    "object": "gene",
    "url_example": "http://solgenomics.net/phenome/locus_display.pl?locus_id=7740",
    "database": "Sol Genomics Network",
    "url_syntax": "http://solgenomics.net/phenome/locus_display.pl?locus_id=[example_id]",
    "datatype": "gene"
  },
  "kegg": {
    "database": "Kyoto Encyclopedia of Genes and Genomes",
    "datatype": "entity",
    "url_syntax": null,
    "object": "entity",
    "url_example": null,
    "generic_url": "http://www.genome.ad.jp/kegg/",
    "uri_prefix": null,
    "abbreviation": "KEGG",
    "fullname": null,
    "id": "KEGG",
    "example_id": null,
    "name": "Kyoto Encyclopedia of Genes and Genomes"
  },
  "ma": {
    "database": "Adult Mouse Anatomical Dictionary",
    "url_syntax": "http://www.informatics.jax.org/searches/AMA.cgi?id=MA:[example_id]",
    "datatype": "entity",
    "object": "entity",
    "url_example": "http://www.informatics.jax.org/searches/AMA.cgi?id=MA:0000003",
    "abbreviation": "MA",
    "fullname": "Adult Mouse Anatomical Dictionary; part of Gene Expression Database",
    "id": "MA",
    "generic_url": "http://www.informatics.jax.org/",
    "uri_prefix": null,
    "example_id": "MA:0000003",
    "name": "Adult Mouse Anatomical Dictionary"
  },
  "obo_sf_po": {
    "uri_prefix": null,
    "generic_url": "http://sourceforge.net/tracker/?func=browse&group_id=76834&atid=835555",
    "id": "OBO_SF_PO",
    "fullname": null,
    "abbreviation": "OBO_SF_PO",
    "name": "Source Forge OBO Plant Ontology (PO) term request tracker",
    "example_id": "OBO_SF_PO:3184921",
    "url_syntax": "https://sourceforge.net/tracker/index.php?func=detail&aid=[example_id]&group_id=76834&atid=835555",
    "datatype": "entity",
    "database": "Source Forge OBO Plant Ontology (PO) term request tracker",
    "object": "entity",
    "url_example": "https://sourceforge.net/tracker/index.php?func=detail&aid=3184921&group_id=76834&atid=835555"
  },
  "ddanat": {
    "database": "Dictyostelium discoideum anatomy",
    "url_syntax": null,
    "datatype": "anatomical entity",
    "url_example": null,
    "object": "anatomical entity",
    "fullname": null,
    "abbreviation": "DDANAT",
    "id": "DDANAT",
    "generic_url": "http://dictybase.org/Dicty_Info/dicty_anatomy_ontology.html",
    "uri_prefix": null,
    "example_id": "DDANAT:0000068",
    "name": "Dictyostelium discoideum anatomy"
  },
  "collectf": {
    "generic_url": "http://www.collectf.org/",
    "uri_prefix": null,
    "abbreviation": "CollecTF",
    "fullname": null,
    "id": "CollecTF",
    "example_id": null,
    "name": "Database of transcription factor binding sites (TFBS) in the Bacteria domain",
    "database": "Database of transcription factor binding sites (TFBS) in the Bacteria domain",
    "url_syntax": null,
    "datatype": "entity",
    "object": "entity",
    "url_example": null
  },
  "cog_cluster": {
    "database": "NCBI COG cluster",
    "url_syntax": "https://www.ncbi.nlm.nih.gov/research/cog/cog/[example_id]",
    "datatype": "entity",
    "object": "entity",
    "url_example": "https://www.ncbi.nlm.nih.gov/research/cog/cog/COG0001",
    "id": "COG_Cluster",
    "fullname": null,
    "abbreviation": "COG_Cluster",
    "generic_url": "http://www.ncbi.nlm.nih.gov/COG/",
    "uri_prefix": null,
    "example_id": "COG_Cluster:COG0001",
    "name": "NCBI COG cluster"
  },
  "rfam": {
    "database": "Rfam database of RNA families",
    "datatype": "entity",
    "url_syntax": "https://rfam.org/family/[example_id]",
    "object": "entity",
    "url_example": "https://rfam.org/family/RF00012",
    "generic_url": "https://rfam.org",
    "uri_prefix": null,
    "abbreviation": "Rfam",
    "fullname": null,
    "id": "Rfam",
    "example_id": "Rfam:RF00012",
    "name": "Rfam database of RNA families"
  },
  "co_125": {
    "object": "entity",
    "url_example": "http://www.cropontology.org/ontology/CO_125:0000000",
    "database": "Crop Ontology CGIAR Musa Anatomy",
    "datatype": "entity",
    "url_syntax": null,
    "example_id": "CO_125:0000002",
    "name": "Crop Ontology CGIAR Musa Anatomy",
    "abbreviation": "CO_125",
    "fullname": null,
    "id": "CO_125",
    "generic_url": "http://www.cropontology.org/ontology/CO_125:0000000/CGIAR_Musa_anatomy",
    "uri_prefix": null
  },
  "ensemblfungi": {
    "example_id": "EnsemblFungi:YOR197W",
    "name": "Ensembl Fungi, the Ensembl database for accessing genome-scale data from fungi.",
    "generic_url": "http://fungi.ensembl.org/",
    "uri_prefix": null,
    "fullname": null,
    "abbreviation": "EnsemblFungi",
    "id": "EnsemblFungi",
    "url_example": "http://www.ensemblgenomes.org/id/YOR197W",
    "object": "gene",
    "database": "Ensembl Fungi, the Ensembl database for accessing genome-scale data from fungi.",
    "url_syntax": "http://www.ensemblgenomes.org/id/[example_id]",
    "datatype": "gene"
  },
  "cgdid": {
    "database": "Candida Genome Database",
    "datatype": "gene",
    "url_syntax": "http://www.candidagenome.org/cgi-bin/locus.pl?dbid=[example_id]",
    "object": "gene",
    "url_example": "http://www.candidagenome.org/cgi-bin/locus.pl?dbid=CAL0000179664",
    "generic_url": "http://www.candidagenome.org/",
    "uri_prefix": null,
    "id": "CGD",
    "fullname": null,
    "abbreviation": "CGDID",
    "example_id": "CGD:CAL0000179664",
    "name": "Candida Genome Database"
  },
  "cog_function": {
    "abbreviation": "COG_Function",
    "fullname": null,
    "id": "COG_Function",
    "generic_url": "http://www.ncbi.nlm.nih.gov/COG/",
    "uri_prefix": null,
    "example_id": "COG_Function:H",
    "name": "NCBI COG function",
    "database": "NCBI COG function",
    "url_syntax": "http://www.ncbi.nlm.nih.gov/COG/grace/shokog.cgi?fun=[example_id]",
    "datatype": "entity",
    "object": "entity",
    "url_example": "http://www.ncbi.nlm.nih.gov/COG/grace/shokog.cgi?fun=H"
  },
  "wb": {
    "fullname": null,
    "abbreviation": "WB",
    "id": "WB",
    "uri_prefix": null,
    "generic_url": "http://www.wormbase.org/",
    "name": "WormBase database of nematode biology",
    "example_id": "WB:CE00274",
    "url_syntax": "http://www.wormbase.org/get?name=[example_id]",
    "datatype": "protein",
    "database": "WormBase database of nematode biology",
    "object": "protein",
    "url_example": "http://www.wormbase.org/get?name=CE00274"
  },
  "riceses": {
    "name": "Rice Knowledge Bank",
    "example_id": "RiceSES:bakanae-diseases-bak",
    "uri_prefix": null,
    "generic_url": "http://www.ncbi.nlm.nih.gov/PubMed/",
    "abbreviation": "RiceSES",
    "fullname": null,
    "id": "RiceSES",
    "object": "entity",
    "url_example": "http://www.knowledgebank.irri.org/extension/crop-damage-diseases/bakanae-diseases-bak.html",
    "datatype": "entity",
    "url_syntax": "http://www.knowledgebank.irri.org/extension/crop-damage-diseases/[example_id].html",
    "database": "Rice Knowledge Bank"
  },
  "syngo-ucl": {
    "example_id": null,
    "name": "The Synapse Gene Ontology and Annotation Initiative at UCL",
    "fullname": null,
    "abbreviation": "SynGO-UCL",
    "id": "SynGO-UCL",
    "generic_url": "https://www.ucl.ac.uk/cardiovascular/research/pre-clinical-and-fundamental-science/functional-gene-annotation/neurological-gene-2",
    "uri_prefix": null,
    "url_example": null,
    "object": "entity",
    "database": "The Synapse Gene Ontology and Annotation Initiative at UCL",
    "datatype": "entity",
    "url_syntax": null
  },
  "obi": {
    "id": "OBI",
    "fullname": null,
    "abbreviation": "OBI",
    "uri_prefix": null,
    "generic_url": "http://obi-ontology.org/",
    "name": "Ontology for Biomedical Investigations",
    "example_id": "OBI:0000038",
    "datatype": "entity",
    "url_syntax": null,
    "database": "Ontology for Biomedical Investigations",
    "url_example": "http://purl.obolibrary.org/obo/OBI_0000038",
    "object": "entity"
  },
  "unirule": {
    "object": "entity",
    "url_example": "https://www.uniprot.org/unirule/UR000107224",
    "url_syntax": "https://www.uniprot.org/unirule/[example_id]",
    "datatype": "entity",
    "database": "Manually curated rules for automatic annotation of UniProtKB unreviewed entries",
    "name": "Manually curated rules for automatic annotation of UniProtKB unreviewed entries",
    "example_id": "UniRule:UR000107224",
    "uri_prefix": null,
    "generic_url": "https://www.uniprot.org/unirule/",
    "fullname": null,
    "id": "UniRule",
    "abbreviation": "UniRule"
  },
  "xenbase": {
    "url_example": "http://www.xenbase.org/entry/XB-LINE-1248",
    "object": "strain",
    "url_syntax": "http://www.xenbase.org/entry/[example_id]",
    "datatype": "strain",
    "database": "Xenbase",
    "name": "Xenbase",
    "example_id": "Xenbase:XB-LINE-1248",
    "uri_prefix": null,
    "generic_url": "http://www.xenbase.org/",
    "fullname": null,
    "id": "Xenbase",
    "abbreviation": "Xenbase"
  },
  "cas_spc": {
    "name": "Catalog of Fishes species database",
    "example_id": null,
    "uri_prefix": null,
    "generic_url": "https://researcharchive.calacademy.org/research/ichthyology/catalog/fishcatmain.asp",
    "id": "CASSPC",
    "fullname": null,
    "abbreviation": "CAS_SPC",
    "url_example": "https://researcharchive.calacademy.org/research/ichthyology/catalog/fishcatget.asp?spid=1979",
    "object": "entity",
    "url_syntax": "https://researcharchive.calacademy.org/research/ichthyology/catalog/fishcatget.asp?spid=[example_id]",
    "datatype": "entity",
    "database": "Catalog of Fishes species database"
  },
  "genesys-pgr": {
    "database": "Gene DB, Genesys",
    "url_syntax": "https://www.genesys-pgr.org/acn/search?q=[example_id]",
    "datatype": "entity",
    "url_example": "https://www.genesys-pgr.org/acn/search?q=CM1015-16",
    "object": "entity",
    "id": "Genesys-pgr",
    "fullname": null,
    "abbreviation": "Genesys-pgr",
    "generic_url": "https://www.genesys-pgr.org/",
    "uri_prefix": null,
    "example_id": "Genesys-pgr:CM1015-16",
    "name": "Gene DB, Genesys"
  },
  "rnamods": {
    "example_id": "RNAmods:20",
    "name": "RNA Modification Database",
    "generic_url": "https://mods.rna.albany.edu/",
    "uri_prefix": null,
    "id": "RNAmods",
    "fullname": null,
    "abbreviation": "RNAmods",
    "object": "entity",
    "url_example": "https://mods.rna.albany.edu/mods/modifications/view/20",
    "database": "RNA Modification Database",
    "url_syntax": "https://mods.rna.albany.edu/mods/modifications/view/[example_id]",
    "datatype": "entity"
  },
  "cog_pathway": {
    "url_syntax": "http://www.ncbi.nlm.nih.gov/COG/new/release/coglist.cgi?pathw=[example_id]",
    "datatype": "entity",
    "database": "NCBI COG pathway",
    "object": "entity",
    "url_example": "http://www.ncbi.nlm.nih.gov/COG/new/release/coglist.cgi?pathw=14",
    "id": "COG_Pathway",
    "fullname": null,
    "abbreviation": "COG_Pathway",
    "uri_prefix": null,
    "generic_url": "http://www.ncbi.nlm.nih.gov/COG/",
    "name": "NCBI COG pathway",
    "example_id": "COG_Pathway:14"
  },
  "pmc": {
    "database": "Pubmed Central",
    "url_syntax": "https://www.ncbi.nlm.nih.gov/pmc/articles/[example_id]",
    "datatype": "entity",
    "object": "entity",
    "url_example": "https://www.ncbi.nlm.nih.gov/pmc/articles/PMC201377/",
    "fullname": null,
    "id": "PMCID",
    "abbreviation": "PMC",
    "generic_url": "https://www.ncbi.nlm.nih.gov/pmc/",
    "uri_prefix": null,
    "example_id": "PMCID:PMC201377",
    "name": "Pubmed Central"
  },
  "pompep": {
    "url_example": null,
    "object": "entity",
    "database": "Schizosaccharomyces pombe protein data",
    "datatype": "entity",
    "url_syntax": null,
    "example_id": "Pompep:SPAC890.04C",
    "name": "Schizosaccharomyces pombe protein data",
    "generic_url": "https://www.pombase.org/downloads/protein-datasets",
    "uri_prefix": null,
    "fullname": null,
    "id": "Pompep",
    "abbreviation": "Pompep"
  },
  "flybase": {
    "url_syntax": "http://flybase.org/reports/[example_id].htm",
    "datatype": "reference",
    "database": "FlyBase",
    "url_example": "https://flybase.org/reports/FBrf0193169.htm",
    "object": "reference",
    "abbreviation": "FLYBASE",
    "fullname": null,
    "id": "FB",
    "uri_prefix": null,
    "generic_url": "http://flybase.org/",
    "name": "FlyBase",
    "example_id": "FBrf0193169"
  },
  "rad": {
    "example_id": "RGD:2004",
    "name": "Rat Genome Database",
    "id": "RGD",
    "fullname": null,
    "abbreviation": "RAD",
    "generic_url": "https://rgd.mcw.edu/",
    "uri_prefix": null,
    "url_example": "https://rgd.mcw.edu/rgdweb/search/search.html?term=2004",
    "object": "gene",
    "database": "Rat Genome Database",
    "url_syntax": "https://rgd.mcw.edu/rgdweb/search/search.html?term=[example_id]",
    "datatype": "gene"
  },
  "geneid": {
    "database": "NCBI Gene",
    "url_syntax": "https://www.ncbi.nlm.nih.gov/gene/[example_id]",
    "datatype": "gene",
    "url_example": "https://www.ncbi.nlm.nih.gov/gene/4771",
    "object": "gene",
    "abbreviation": "GeneID",
    "fullname": null,
    "id": "NCBIGene",
    "generic_url": "http://www.ncbi.nlm.nih.gov/",
    "uri_prefix": null,
    "example_id": "NCBI_Gene:4771",
    "name": "NCBI Gene"
  },
  "phenoscape": {
    "example_id": null,
    "name": "PhenoScape Knowledgebase",
    "generic_url": "http://phenoscape.org/",
    "uri_prefix": null,
    "fullname": null,
    "id": "PhenoScape",
    "abbreviation": "PhenoScape",
    "object": "entity",
    "url_example": null,
    "database": "PhenoScape Knowledgebase",
    "url_syntax": null,
    "datatype": "entity"
  },
  "enzyme": {
    "uri_prefix": null,
    "generic_url": "https://enzyme.expasy.org/",
    "fullname": null,
    "id": "ENZYME",
    "abbreviation": "ENZYME",
    "name": "Swiss Institute of Bioinformatics enzyme database",
    "example_id": "1.1.1.1",
    "datatype": "entity",
    "url_syntax": "https://enzyme.expasy.org/EC/[example_id]",
    "database": "Swiss Institute of Bioinformatics enzyme database",
    "url_example": "https://enzyme.expasy.org/EC/1.1.1.1",
    "object": "entity"
  },
  "gr_ensembl": {
    "fullname": null,
    "abbreviation": "GR_Ensembl",
    "id": "GR_Ensembl",
    "generic_url": "http://www.gramene.org/",
    "uri_prefix": null,
    "example_id": "GR_Ensembl:At1g10040",
    "name": "Gramene",
    "database": "Gramene",
    "datatype": "entity",
    "url_syntax": "http://gramene.org/?idList=[example_id]",
    "url_example": "http://gramene.org/?idList=At1g10040",
    "object": "entity"
  },
  "nasc_code": {
    "example_id": "NASC_code:N3371",
    "name": "Nottingham Arabidopsis Stock Centre Seeds Database",
    "id": "NASC_code",
    "fullname": null,
    "abbreviation": "NASC_code",
    "generic_url": "http://arabidopsis.info",
    "uri_prefix": null,
    "object": "entity",
    "url_example": "http://seeds.nottingham.ac.uk/NASC/stockatidb.lasso?code=N3371",
    "database": "Nottingham Arabidopsis Stock Centre Seeds Database",
    "url_syntax": "http://seeds.nottingham.ac.uk/NASC/stockatidb.lasso?code=[example_id]",
    "datatype": "entity"
  },
  "cribi_vitis": {
    "url_example": "http://genomes.cribi.unipd.it/cgi-bin/pqs2/report.pl?gene_name=VIT_00s0173g00270&release=v1",
    "object": "entity",
    "url_syntax": "http://genomes.cribi.unipd.it/cgi-bin/pqs2/report.pl?gene_name=[example_id]&release=v1",
    "datatype": "entity",
    "database": "Vitis CRIBI database",
    "name": "Vitis CRIBI database",
    "example_id": "VIT_00s0173g00270",
    "uri_prefix": null,
    "generic_url": "http://genomes.cribi.unipd.it",
    "fullname": null,
    "id": "cribi_vitis",
    "abbreviation": "cribi_vitis"
  },
  "genedb": {
    "generic_url": "http://www.genedb.org/gene/",
    "uri_prefix": null,
    "fullname": null,
    "abbreviation": "GeneDB",
    "id": "GeneDB",
    "example_id": "PF3D7_1467300",
    "name": "GeneDB",
    "database": "GeneDB",
    "datatype": "gene",
    "url_syntax": "http://www.genedb.org/gene/[example_id]",
    "url_example": "http://www.genedb.org/gene/PF3D7_1467300",
    "object": "gene"
  },
  "sgd_locus": {
    "datatype": "entity",
    "url_syntax": "https://www.yeastgenome.org/search?q=[example_id]&is_quick=true",
    "database": "Saccharomyces Genome Database",
    "url_example": "https://www.yeastgenome.org/search?q=S000006169&is_quick=true",
    "object": "entity",
    "uri_prefix": null,
    "generic_url": "http://www.yeastgenome.org/",
    "id": "SGD_LOCUS",
    "fullname": null,
    "abbreviation": "SGD_LOCUS",
    "name": "Saccharomyces Genome Database",
    "example_id": "SGD_LOCUS:GAL4"
  },
  "rnamdb": {
    "database": "RNA Modification Database",
    "datatype": "entity",
    "url_syntax": "https://mods.rna.albany.edu/mods/modifications/view/[example_id]",
    "url_example": "https://mods.rna.albany.edu/mods/modifications/view/20",
    "object": "entity",
    "id": "RNAmods",
    "fullname": null,
    "abbreviation": "RNAMDB",
    "generic_url": "https://mods.rna.albany.edu/",
    "uri_prefix": null,
    "example_id": "RNAmods:20",
    "name": "RNA Modification Database"
  },
  "lifedb": {
    "object": "entity",
    "url_example": "https://www.dkfz.de/en/mga/Groups/LIFEdb-Database.html?ID=DKFZp564O1716",
    "url_syntax": "https://www.dkfz.de/en/mga/Groups/LIFEdb-Database.html?ID=[example_id]",
    "datatype": "entity",
    "database": "LifeDB",
    "name": "LifeDB",
    "example_id": "LIFEdb:DKFZp564O1716",
    "id": "LIFEdb",
    "fullname": "LifeDB is a database for information on protein localization, interaction, functional assays and expression.",
    "abbreviation": "LIFEdb",
    "uri_prefix": null,
    "generic_url": "http://www.lifedb.de/"
  },
  "cazy": {
    "fullname": "The CAZy database describes the families of structurally-related catalytic and carbohydrate-binding modules (or functional domains) of enzymes that degrade, modify, or create glycosidic bonds.",
    "id": "CAZY",
    "abbreviation": "CAZY",
    "generic_url": "http://www.cazy.org/",
    "uri_prefix": null,
    "example_id": "CAZY:PL11",
    "name": "Carbohydrate Active EnZYmes",
    "database": "Carbohydrate Active EnZYmes",
    "url_syntax": "http://www.cazy.org/[example_id].html",
    "datatype": "entity",
    "url_example": "http://www.cazy.org/PL11.html",
    "object": "entity"
  },
  "prosite": {
    "generic_url": "https://prosite.expasy.org/",
    "uri_prefix": null,
    "abbreviation": "Prosite",
    "fullname": null,
    "id": "Prosite",
    "example_id": "PDOC00314",
    "name": "Prosite database of protein families and domains",
    "database": "Prosite database of protein families and domains",
    "datatype": "polypeptide region",
    "url_syntax": "https://prosite.expasy.org/[example_id]",
    "url_example": "https://prosite.expasy.org/PDOC00314",
    "object": "polypeptide region"
  },
  "peco_git": {
    "generic_url": "https://github.com/Planteome/plant-experimental-conditions-ontology",
    "uri_prefix": null,
    "abbreviation": "PECO_GIT",
    "fullname": null,
    "id": "PECO_GIT",
    "example_id": "PECO_GIT:76",
    "name": "GitHub Issue Tracker for PECO",
    "database": "GitHub Issue Tracker for PECO",
    "url_syntax": "https://github.com/Planteome/plant-environment-ontology/issues/[example_id]",
    "datatype": "entity",
    "object": "entity",
    "url_example": "https://github.com/Planteome/plant-experimental-conditions-ontology/issues/76"
  },
  "biocyc": {
    "object": "entity",
    "url_example": "http://biocyc.org/META/NEW-IMAGE?type=PATHWAY&object=PWY-5271",
    "url_syntax": "http://biocyc.org/META/NEW-IMAGE?type=PATHWAY&object=[example_id]",
    "datatype": "entity",
    "database": "BioCyc collection of metabolic pathway databases",
    "name": "BioCyc collection of metabolic pathway databases",
    "example_id": "BioCyc:PWY-5271",
    "uri_prefix": null,
    "generic_url": "http://biocyc.org/",
    "id": "BioCyc",
    "fullname": null,
    "abbreviation": "BioCyc"
  },
  "panther": {
    "name": "Protein ANalysis THrough Evolutionary Relationships Classification System",
    "example_id": "PANTHER:PTHR11455",
    "fullname": null,
    "abbreviation": "PANTHER",
    "id": "PANTHER",
    "uri_prefix": null,
    "generic_url": "http://www.pantherdb.org/",
    "object": "protein family",
    "url_example": "http://www.pantherdb.org/panther/lookupId.jsp?id=PTHR10000",
    "url_syntax": "http://www.pantherdb.org/panther/lookupId.jsp?id=[example_id]",
    "datatype": "protein family",
    "database": "Protein ANalysis THrough Evolutionary Relationships Classification System"
  },
  "ensembl_transcriptid": {
    "url_example": "http://www.ensembl.org/id/ENST00000371959",
    "object": "transcript",
    "url_syntax": "http://www.ensembl.org/id/[example_id]",
    "datatype": "transcript",
    "database": "Ensembl database of automatically annotated genomic data",
    "name": "Ensembl database of automatically annotated genomic data",
    "example_id": "ENSEMBL_TranscriptID:ENST00000371959",
    "abbreviation": "ENSEMBL_TranscriptID",
    "fullname": null,
    "id": "ENSEMBL_TranscriptID",
    "uri_prefix": null,
    "generic_url": "http://www.ensembl.org/"
  },
  "gr_gene": {
    "datatype": "entity",
    "url_syntax": "http://www.gramene.org/db/genes/search_gene?acc=[example_id]",
    "database": "Gramene",
    "object": "entity",
    "url_example": "http://www.gramene.org/db/genes/search_gene?acc=GR:0060198",
    "uri_prefix": null,
    "generic_url": "http://www.gramene.org/",
    "fullname": null,
    "id": "GR_GENE",
    "abbreviation": "GR_gene",
    "name": "Gramene",
    "example_id": "GR_GENE:GR:0060198"
  },
  "goc": {
    "url_syntax": null,
    "datatype": "entity",
    "database": "Gene Ontology Consortium",
    "object": "entity",
    "url_example": null,
    "fullname": null,
    "id": "GOC",
    "abbreviation": "GOC",
    "uri_prefix": null,
    "generic_url": "http://www.geneontology.org/",
    "name": "Gene Ontology Consortium",
    "example_id": null
  },
  "interpro": {
    "database": "InterPro database of protein domains and motifs",
    "datatype": "polypeptide region",
    "url_syntax": "http://www.ebi.ac.uk/interpro/entry/[example_id]",
    "object": "polypeptide region",
    "url_example": "http://www.ebi.ac.uk/interpro/entry/IPR015421",
    "generic_url": "http://www.ebi.ac.uk/interpro/",
    "uri_prefix": null,
    "id": "InterPro",
    "fullname": null,
    "abbreviation": "INTERPRO",
    "example_id": "InterPro:IPR000001",
    "name": "InterPro database of protein domains and motifs"
  },
  "cdd": {
    "object": "entity",
    "url_example": "http://www.ncbi.nlm.nih.gov/Structure/cdd/cddsrv.cgi?uid=34222",
    "datatype": "entity",
    "url_syntax": "http://www.ncbi.nlm.nih.gov/Structure/cdd/cddsrv.cgi?uid=[example_id]",
    "database": "Conserved Domain Database at NCBI",
    "name": "Conserved Domain Database at NCBI",
    "example_id": "CDD:34222",
    "uri_prefix": null,
    "generic_url": "https://www.ncbi.nlm.nih.gov/cdd",
    "id": "CDD",
    "fullname": null,
    "abbreviation": "CDD"
  },
  "iuphar/bps": {
    "uri_prefix": null,
    "generic_url": "https://www.guidetopharmacology.org/",
    "fullname": null,
    "id": "IUPHAR/BPS",
    "abbreviation": "IUPHAR/BPS",
    "name": "IUPHAR/BPS Guide to Pharmacology",
    "example_id": null,
    "datatype": "entity",
    "url_syntax": null,
    "database": "IUPHAR/BPS Guide to Pharmacology",
    "url_example": null,
    "object": "entity"
  },
  "obo_sf2_po": {
    "object": "entity",
    "url_example": "http://sourceforge.net/p/obo/plant-ontology-po-term-requests/500",
    "datatype": "entity",
    "url_syntax": "http://sourceforge.net/p/obo/plant-ontology-po-term-requests/[example_id]",
    "database": "Source Forge OBO Plant Ontology (PO) term request tracker",
    "name": "Source Forge OBO Plant Ontology (PO) term request tracker",
    "example_id": "OBO_SF2_PO:500",
    "uri_prefix": null,
    "generic_url": "https://sourceforge.net/p/obo/plant-ontology-po-term-requests/",
    "abbreviation": "OBO_SF2_PO",
    "fullname": null,
    "id": "OBO_SF2_PO"
  },
  "doi": {
    "datatype": "entity",
    "url_syntax": "http://dx.doi.org/[example_id]",
    "database": "Digital Object Identifier",
    "object": "entity",
    "url_example": "http://dx.doi.org/10.1016/S0963-9969(99)00021-6",
    "id": "DOI",
    "fullname": null,
    "abbreviation": "DOI",
    "uri_prefix": null,
    "generic_url": "http://dx.doi.org/",
    "name": "Digital Object Identifier",
    "example_id": "DOI:10.1016/S0963-9969(99)00021-6"
  },
  "taxon": {
    "example_id": "NCBITaxon:7227",
    "name": "NCBI Taxonomy",
    "generic_url": "http://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/",
    "uri_prefix": null,
    "fullname": null,
    "id": "NCBITaxon",
    "abbreviation": "taxon",
    "object": "entity",
    "url_example": "http://www.ncbi.nlm.nih.gov/Taxonomy/Browser/wwwtax.cgi?id=3702",
    "database": "NCBI Taxonomy",
    "datatype": "entity",
    "url_syntax": "http://www.ncbi.nlm.nih.gov/Taxonomy/Browser/wwwtax.cgi?id=[example_id]"
  },
  "dictybase_gene_name": {
    "example_id": "dictyBase_gene_name:mlcE",
    "name": "dictyBase",
    "id": "dictyBase_gene_name",
    "fullname": null,
    "abbreviation": "dictyBase_gene_name",
    "generic_url": "http://dictybase.org",
    "uri_prefix": null,
    "object": "entity",
    "url_example": "http://dictybase.org/gene/mlcE",
    "database": "dictyBase",
    "url_syntax": "http://dictybase.org/gene/[example_id]",
    "datatype": "entity"
  },
  "ddb": {
    "url_example": "http://dictybase.org/gene/DDB_G0277859",
    "object": "gene",
    "datatype": "gene",
    "url_syntax": "http://dictybase.org/gene/[example_id]",
    "database": "dictyBase",
    "name": "dictyBase",
    "example_id": "dictyBase:DDB_G0277859",
    "fullname": null,
    "abbreviation": "DDB",
    "id": "dictyBase",
    "uri_prefix": null,
    "generic_url": "http://dictybase.org"
  },
  "maizegdb_ref": {
    "datatype": "entity",
    "url_syntax": "http://maizegdb.org/data_center/reference?id=[example_id]",
    "database": "Maize Genetics and Genomics Database",
    "object": "entity",
    "url_example": "http://maizegdb.org/data_center/reference?id=9021423",
    "uri_prefix": null,
    "generic_url": "https://www.maizegdb.org/",
    "id": "MaizeGDB_REF",
    "fullname": null,
    "abbreviation": "MaizeGDB_REF",
    "name": "Maize Genetics and Genomics Database",
    "example_id": "MaizeGDB_REF:9021423"
  },
  "prints": {
    "database": "PRINTS compendium of protein fingerprints",
    "datatype": "polypeptide region",
    "url_syntax": "http://www.bioinf.manchester.ac.uk/cgi-bin/dbbrowser/sprint/searchprintss.cgi?display_opts=Prints&category=None&queryform=false&regexpr=off&prints_accn=[example_id]",
    "url_example": "http://www.bioinf.manchester.ac.uk/cgi-bin/dbbrowser/sprint/searchprintss.cgi?display_opts=Prints&category=None&queryform=false&regexpr=off&prints_accn=PR00025",
    "object": "polypeptide region",
    "generic_url": "http://www.bioinf.manchester.ac.uk/dbbrowser/PRINTS/",
    "uri_prefix": null,
    "abbreviation": "PRINTS",
    "fullname": null,
    "id": "PRINTS",
    "example_id": "PRINTS:PR00025",
    "name": "PRINTS compendium of protein fingerprints"
  },
  "brenda": {
    "object": "catalytic activity",
    "url_example": "https://www.brenda-enzymes.info/enzyme.php?ecno=4.2.1.3",
    "url_syntax": "https://www.brenda-enzymes.info/enzyme.php?ecno=[example_id]",
    "datatype": "catalytic activity",
    "database": "BRENDA, The Comprehensive Enzyme Information System",
    "name": "BRENDA, The Comprehensive Enzyme Information System",
    "example_id": "BRENDA:4.2.1.3",
    "fullname": null,
    "abbreviation": "BRENDA",
    "id": "BRENDA",
    "uri_prefix": null,
    "generic_url": "http://www.brenda-enzymes.info"
  },
  "protein_id": {
    "url_example": null,
    "object": "protein",
    "datatype": "protein",
    "url_syntax": null,
    "database": "DDBJ / ENA / GenBank",
    "name": "DDBJ / ENA / GenBank",
    "example_id": "protein_id:CAA71991",
    "abbreviation": "protein_id",
    "fullname": "protein identifier shared by DDBJ/EMBL-bank/GenBank nucleotide sequence databases",
    "id": "protein_id",
    "uri_prefix": null,
    "generic_url": "http://www.ddbj.nig.ac.jp/"
  },
  "mesh": {
    "name": "Medical Subject Headings",
    "example_id": "MeSH:D017209",
    "uri_prefix": null,
    "generic_url": "https://meshb.nlm.nih.gov",
    "id": "MeSH",
    "fullname": null,
    "abbreviation": "MESH",
    "object": "entity",
    "url_example": "http://id.nlm.nih.gov/mesh/D017209",
    "datatype": "entity",
    "url_syntax": "http://id.nlm.nih.gov/mesh/[example_id]",
    "database": "Medical Subject Headings"
  },
  "ensemblplants": {
    "abbreviation": "EnsemblPlants",
    "fullname": null,
    "id": "EnsemblPlants",
    "generic_url": "http://plants.ensembl.org/",
    "uri_prefix": null,
    "example_id": "EnsemblPlants:LOC_Os01g22954",
    "name": "Ensembl Plants, the Ensembl database for accessing genome-scale data from plants.",
    "database": "Ensembl Plants, the Ensembl database for accessing genome-scale data from plants.",
    "datatype": "gene",
    "url_syntax": "http://www.ensemblgenomes.org/id/[example_id]",
    "url_example": "http://www.ensemblgenomes.org/id/LOC_Os01g22954",
    "object": "gene"
  },
  "intact": {
    "url_example": "http://www.ebi.ac.uk/complexportal/complex/EBI-10205244",
    "object": "protein-containing complex",
    "url_syntax": "http://www.ebi.ac.uk/complexportal/complex/[example_id]",
    "datatype": "protein-containing complex",
    "database": "IntAct protein interaction database",
    "name": "IntAct protein interaction database",
    "example_id": "IntAct:EBI-10205244",
    "abbreviation": "IntAct",
    "fullname": null,
    "id": "IntAct",
    "uri_prefix": null,
    "generic_url": "https://www.ebi.ac.uk/intact/"
  },
  "iuphar_gpcr": {
    "database": "International Union of Pharmacology",
    "datatype": "entity",
    "url_syntax": "https://www.guidetopharmacology.org/GRAC/FamilyDisplayForward?familyId=[example_id]",
    "object": "entity",
    "url_example": "https://www.guidetopharmacology.org/GRAC/FamilyDisplayForward?familyId=13",
    "id": "IUPHAR_GPCR",
    "fullname": null,
    "abbreviation": "IUPHAR_GPCR",
    "generic_url": "http://www.iuphar.org/",
    "uri_prefix": null,
    "example_id": "IUPHAR_GPCR:13",
    "name": "International Union of Pharmacology"
  },
  "cgd_locus": {
    "fullname": null,
    "id": "CGD_LOCUS",
    "abbreviation": "CGD_LOCUS",
    "uri_prefix": null,
    "generic_url": "http://www.candidagenome.org/",
    "name": "Candida Genome Database",
    "example_id": "CGD_LOCUS:HWP1",
    "url_syntax": "http://www.candidagenome.org/cgi-bin/locus.pl?locus=[example_id]",
    "datatype": "entity",
    "database": "Candida Genome Database",
    "url_example": "http://www.candidagenome.org/cgi-bin/locus.pl?locus=HWP1",
    "object": "entity"
  },
  "plantsystematics_image_archive": {
    "database": "PlantSystematics.org",
    "url_syntax": "http://www.plantsystematics.org/imagebyid_[example_id].html",
    "datatype": "entity",
    "object": "entity",
    "url_example": "http://www.plantsystematics.org/imagebyid_37658.html",
    "fullname": null,
    "id": "PlantSystematics_image_archive",
    "abbreviation": "PlantSystematics_image_archive",
    "generic_url": "http://plantsystematics.org",
    "uri_prefix": null,
    "example_id": "PlantSystematics_image_archivee:37658",
    "name": "PlantSystematics.org"
  },
  "treegrafter": {
    "database": "TreeGrafter-generated GO annotations",
    "datatype": "protein family",
    "url_syntax": "http://www.pantherdb.org/panther/lookupId.jsp?id=[example_id]",
    "object": "protein family",
    "url_example": "http://www.pantherdb.org/panther/lookupId.jsp?id=PTHR10000",
    "generic_url": "http://www.pantherdb.org/",
    "uri_prefix": null,
    "fullname": null,
    "abbreviation": "TreeGrafter",
    "id": "TreeGrafter",
    "example_id": "PANTHER:PTHR11455",
    "name": "TreeGrafter-generated GO annotations"
  },
  "patric": {
    "database": "PathoSystems Resource Integration Center",
    "datatype": "entity",
    "url_syntax": "https://www.patricbrc.org/view/Feature/[example_id]",
    "url_example": "https://www.patricbrc.org/view/Feature/fig%7C83332.12.peg.1",
    "object": "entity",
    "abbreviation": "PATRIC",
    "fullname": "PathoSystems Resource Integration Center at the Virginia Bioinformatics Institute",
    "id": "PATRIC",
    "generic_url": "https://www.patricbrc.org",
    "uri_prefix": null,
    "example_id": "PATRIC:fig%7C83332.12.peg.11",
    "name": "PathoSystems Resource Integration Center"
  },
  "nif_subcellular": {
    "example_id": "NIF_Subcellular:sao1186862860",
    "name": "Neuroscience Information Framework standard ontology, subcellular hierarchy",
    "abbreviation": "NIF_Subcellular",
    "fullname": null,
    "id": "NIF_Subcellular",
    "generic_url": "http://www.neurolex.org/wiki",
    "uri_prefix": null,
    "url_example": "http://www.neurolex.org/wiki/sao1770195789",
    "object": "entity",
    "database": "Neuroscience Information Framework standard ontology, subcellular hierarchy",
    "url_syntax": "http://www.neurolex.org/wiki/[example_id]",
    "datatype": "entity"
  },
  "metacyc": {
    "url_syntax": "https://biocyc.org/META/NEW-IMAGE?type=NIL&object=[example_id]",
    "datatype": "entity",
    "database": "Metabolic Encyclopedia of metabolic and other pathways",
    "url_example": "https://biocyc.org/META/NEW-IMAGE?type=NIL&object=GLUTDEG-PWY",
    "object": "entity",
    "id": "MetaCyc",
    "fullname": null,
    "abbreviation": "METACYC",
    "uri_prefix": null,
    "generic_url": "https://metacyc.org/",
    "name": "Metabolic Encyclopedia of metabolic and other pathways",
    "example_id": "MetaCyc:GLUTDEG-PWY"
  },
  "medline": {
    "generic_url": "http://www.nlm.nih.gov/databases/databases_medline.html",
    "uri_prefix": null,
    "id": "MEDLINE",
    "fullname": null,
    "abbreviation": "MEDLINE",
    "example_id": "MEDLINE:20572430",
    "name": "Medline literature database",
    "database": "Medline literature database",
    "datatype": "entity",
    "url_syntax": null,
    "object": "entity",
    "url_example": null
  },
  "to_git": {
    "url_example": "https://github.com/Planteome/plant-trait-ontology/issues/381",
    "object": "entity",
    "datatype": "entity",
    "url_syntax": "https://github.com/Planteome/plant-trait-ontology/issues/[example_id]",
    "database": "GitHub Issue Tracker for TO",
    "name": "GitHub Issue Tracker for TO",
    "example_id": "TO_GIT:381",
    "abbreviation": "TO_GIT",
    "fullname": null,
    "id": "TO_GIT",
    "uri_prefix": null,
    "generic_url": "https://github.com/Planteome/plant-trait-ontology"
  },
  "pseudocap": {
    "example_id": "PseudoCAP:PA4756",
    "name": "Pseudomonas Genome Project",
    "fullname": null,
    "id": "PseudoCAP",
    "abbreviation": "PseudoCAP",
    "generic_url": "http://www.pseudomonas.com",
    "uri_prefix": null,
    "url_example": "http://www.pseudomonas.com/feature/show?locus_tag=PA4756",
    "object": "entity",
    "database": "Pseudomonas Genome Project",
    "datatype": "entity",
    "url_syntax": "http://www.pseudomonas.com/feature/show?locus_tag=[example_id]"
  },
  "tgd_locus": {
    "object": "entity",
    "url_example": "http://db.ciliate.org/cgi-bin/locus.pl?locus=PDD1",
    "database": "Tetrahymena Genome Database",
    "datatype": "entity",
    "url_syntax": "http://db.ciliate.org/cgi-bin/locus.pl?locus=[example_id]",
    "example_id": "TGD_LOCUS:PDD1",
    "name": "Tetrahymena Genome Database",
    "fullname": null,
    "id": "TGD_LOCUS",
    "abbreviation": "TGD_LOCUS",
    "generic_url": "http://www.ciliate.org/",
    "uri_prefix": null
  },
  "um-bbd": {
    "example_id": null,
    "name": "EAWAG Biocatalysis/Biodegradation Database",
    "generic_url": "http://eawag-bbd.ethz.ch/",
    "uri_prefix": null,
    "id": "UM-BBD",
    "fullname": null,
    "abbreviation": "UM-BBD",
    "url_example": null,
    "object": "entity",
    "database": "EAWAG Biocatalysis/Biodegradation Database",
    "datatype": "entity",
    "url_syntax": null
  },
  "mips_funcat": {
    "name": "MIPS Functional Catalogue",
    "example_id": "MIPS_funcat:11.02",
    "uri_prefix": null,
    "generic_url": "http://mips.gsf.de/proj/funcatDB/",
    "id": "MIPS_funcat",
    "fullname": null,
    "abbreviation": "MIPS_funcat",
    "object": "entity",
    "url_example": "http://mips.gsf.de/cgi-bin/proj/funcatDB/search_advanced.pl?action=2&wert=11.02",
    "datatype": "entity",
    "url_syntax": "http://mips.gsf.de/cgi-bin/proj/funcatDB/search_advanced.pl?action=2&wert=[example_id]",
    "database": "MIPS Functional Catalogue"
  },
  "psi-mi": {
    "name": "Proteomic Standard Initiative for Molecular Interaction",
    "example_id": "MI_0018",
    "uri_prefix": null,
    "generic_url": "http://www.psidev.info/",
    "id": "PSI-MI",
    "fullname": null,
    "abbreviation": "PSI-MI",
    "object": "entity",
    "url_example": "http://purl.obolibrary.org/obo/MI_0018",
    "datatype": "entity",
    "url_syntax": "http://purl.obolibrary.org/obo/",
    "database": "Proteomic Standard Initiative for Molecular Interaction"
  },
  "mim": {
    "database": "Mendelian Inheritance in Man",
    "datatype": "entity",
    "url_syntax": "https://omim.org/entry/[example_id]",
    "object": "entity",
    "url_example": "https://omim.org/entry/190198",
    "generic_url": "https://omim.org/",
    "uri_prefix": null,
    "fullname": null,
    "id": "OMIM",
    "abbreviation": "MIM",
    "example_id": "OMIM:190198",
    "name": "Mendelian Inheritance in Man"
  },
  "go_ref": {
    "datatype": "entity",
    "url_syntax": "http://purl.obolibrary.org/obo/go/references/[example_id]",
    "database": "Gene Ontology Database references",
    "object": "entity",
    "url_example": "http://purl.obolibrary.org/obo/go/references/0000002",
    "uri_prefix": null,
    "generic_url": "http://geneontology.org/gorefs",
    "fullname": null,
    "id": "GO_REF",
    "abbreviation": "GO_REF",
    "name": "Gene Ontology Database references",
    "example_id": "0000001"
  },
  "biomd": {
    "object": "entity",
    "url_example": "https://www.ebi.ac.uk/biomodels/BIOMD0000000045",
    "database": "BioModels Database",
    "url_syntax": "https://www.ebi.ac.uk/biomodels/[example_id]",
    "datatype": "entity",
    "example_id": "BIOMD:BIOMD0000000045",
    "name": "BioModels Database",
    "fullname": null,
    "id": "BIOMD",
    "abbreviation": "BIOMD",
    "generic_url": "https://www.ebi.ac.uk/biomodels/",
    "uri_prefix": null
  },
  "dictybase_ref": {
    "generic_url": "http://dictybase.org",
    "uri_prefix": null,
    "abbreviation": "dictyBase_REF",
    "fullname": null,
    "id": "dictyBase_REF",
    "example_id": "dictyBase_REF:10157",
    "name": "dictyBase literature references",
    "database": "dictyBase literature references",
    "datatype": "entity",
    "url_syntax": "http://dictybase.org/publication/[example_id]",
    "url_example": "http://dictybase.org/publication/10157",
    "object": "entity"
  },
  "pr": {
    "datatype": "protein",
    "url_syntax": "https://purl.obolibrary.org/obo/PR_[example_id]",
    "database": "Protein Ontology",
    "object": "protein",
    "url_example": "https://purl.obolibrary.org/obo/PR_000060258",
    "uri_prefix": null,
    "generic_url": "https://proconsortium.org/",
    "fullname": null,
    "id": "PR",
    "abbreviation": "PR",
    "name": "Protein Ontology",
    "example_id": "PR:Q64445"
  },
  "grin": {
    "datatype": "germplasm",
    "url_syntax": "https://npgsweb.ars-grin.gov/gringlobal/accessiondetail.aspx?id=[example_id]",
    "database": "Germplasm Resources Information Network",
    "url_example": "https://npgsweb.ars-grin.gov/gringlobal/accessiondetail.aspx?id=1882640",
    "object": "germplasm",
    "uri_prefix": null,
    "generic_url": "https://www.ars-grin.gov/",
    "fullname": null,
    "abbreviation": "grin",
    "id": "GRIN",
    "name": "Germplasm Resources Information Network",
    "example_id": "GRIN:1882640"
  },
  "merops": {
    "example_id": "MEROPS:A08.001",
    "name": "MEROPS peptidase database",
    "generic_url": "https://www.ebi.ac.uk/merops/",
    "uri_prefix": null,
    "fullname": null,
    "abbreviation": "MEROPS",
    "id": "MEROPS",
    "url_example": "https://www.ebi.ac.uk/merops/cgi-bin/pepsum?id=A08.001",
    "object": "protein",
    "database": "MEROPS peptidase database",
    "url_syntax": "https://www.ebi.ac.uk/merops/cgi-bin/pepsum?id=[example_id]",
    "datatype": "protein"
  },
  "cas": {
    "object": "entity",
    "url_example": null,
    "datatype": "entity",
    "url_syntax": null,
    "database": "CAS Chemical Registry",
    "name": "CAS Chemical Registry",
    "example_id": "CAS:58-08-2",
    "uri_prefix": null,
    "generic_url": "http://www.cas.org/expertise/cascontent/registry/index.html",
    "fullname": "CAS REGISTRY is the most authoritative collection of disclosed chemical substance information, containing more than 54 million organic and inorganic substances and 62 million sequences. CAS REGISTRY covers substances identified from the scientific literature from 1957 to the present, with additional substances going back to the early 1900s.",
    "id": "CAS",
    "abbreviation": "CAS"
  },
  "issn": {
    "uri_prefix": null,
    "generic_url": "http://www.issn.org/",
    "fullname": null,
    "id": "ISSN",
    "abbreviation": "ISSN",
    "name": "International Standard Serial Number",
    "example_id": "ISSN:1234-1231",
    "url_syntax": null,
    "datatype": "entity",
    "database": "International Standard Serial Number",
    "object": "entity",
    "url_example": null
  },
  "tc": {
    "url_syntax": "http://www.tcdb.org/tcdb/index.php?tc=[example_id]",
    "datatype": "protein",
    "database": "Transport Protein Database",
    "url_example": "http://www.tcdb.org/tcdb/index.php?tc=9.A.4.1.1",
    "object": "protein",
    "id": "TC",
    "fullname": null,
    "abbreviation": "TC",
    "uri_prefix": null,
    "generic_url": "http://www.tcdb.org/",
    "name": "Transport Protein Database",
    "example_id": "TC:9.A.4.1.1"
  },
  "sgdid": {
    "url_syntax": "https://www.yeastgenome.org/search?q=[example_id]&is_quick=true",
    "datatype": "gene",
    "database": "Saccharomyces Genome Database",
    "url_example": "https://www.yeastgenome.org/search?q=S000006169&is_quick=true",
    "object": "gene",
    "fullname": null,
    "abbreviation": "SGDID",
    "id": "SGD",
    "uri_prefix": null,
    "generic_url": "http://www.yeastgenome.org/",
    "name": "Saccharomyces Genome Database",
    "example_id": "SGD:S000006169"
  },
  "psort": {
    "url_example": null,
    "object": "entity",
    "url_syntax": null,
    "datatype": "entity",
    "database": "PSORT protein subcellular localization databases and prediction tools for bacteria",
    "name": "PSORT protein subcellular localization databases and prediction tools for bacteria",
    "example_id": null,
    "id": "PSORT",
    "fullname": null,
    "abbreviation": "PSORT",
    "uri_prefix": null,
    "generic_url": "https://www.psort.org/"
  },
  "casgen": {
    "uri_prefix": null,
    "generic_url": "https://researcharchive.calacademy.org/research/ichthyology/catalog/fishcatmain.asp",
    "fullname": null,
    "abbreviation": "CASGEN",
    "id": "CASGEN",
    "name": "Catalog of Fishes genus database",
    "example_id": "CASGEN:1040",
    "datatype": "entity",
    "url_syntax": "https://researcharchive.calacademy.org/research/ichthyology/catalog/fishcatget.asp?genid=[example_id]",
    "database": "Catalog of Fishes genus database",
    "object": "entity",
    "url_example": "https://researcharchive.calacademy.org/research/ichthyology/catalog/fishcatget.asp?genid=1040"
  },
  "ncbi": {
    "datatype": "entity",
    "url_syntax": null,
    "database": "National Center for Biotechnology Information",
    "url_example": null,
    "object": "entity",
    "uri_prefix": null,
    "generic_url": "http://www.ncbi.nlm.nih.gov/",
    "abbreviation": "NCBI",
    "fullname": null,
    "id": "NCBI",
    "name": "National Center for Biotechnology Information",
    "example_id": null
  },
  "cacao": {
    "name": "Community Assessment of Community Annotation with Ontologies",
    "example_id": "MYCS2:A0QNF5",
    "id": "CACAO",
    "fullname": "The Community Assessment of Community Annotation with Ontologies (CACAO) is a project to do large-scale manual community annotation of gene function using the Gene Ontology as a multi-institution student competition.",
    "abbreviation": "CACAO",
    "uri_prefix": null,
    "generic_url": "http://gowiki.tamu.edu/wiki/index.php/Category:CACAO",
    "url_example": "https://gowiki.tamu.edu/wiki/index.php/MYCS2:A0QNF5",
    "object": "entity",
    "url_syntax": "https://gowiki.tamu.edu/wiki/index.php/[example_id]",
    "datatype": "entity",
    "database": "Community Assessment of Community Annotation with Ontologies"
  },
  "soy_gene": {
    "object": "gene",
    "url_example": "https://www.soybase.org/sbt/search/search_results.php?category=FeatureName&search_term=Glyma18g02210",
    "database": "SoyBase",
    "url_syntax": "https://www.soybase.org/sbt/search/search_results.php?category=FeatureName&search_term=[example_id]",
    "datatype": "gene",
    "example_id": "Glyma18g02210",
    "name": "SoyBase",
    "generic_url": "https://soybase.org/",
    "uri_prefix": null,
    "id": "Soy_gene",
    "fullname": null,
    "abbreviation": "Soy_gene"
  },
  "h-invdb_cdna": {
    "name": "H-invitational Database",
    "example_id": "H-invDB_cDNA:AK093148",
    "fullname": null,
    "abbreviation": "H-invDB_cDNA",
    "id": "H-invDB_cDNA",
    "uri_prefix": null,
    "generic_url": "http://www.h-invitational.jp/",
    "object": "entity",
    "url_example": "http://www.h-invitational.jp/hinv/spsoup/transcript_view?acc_id=AK093149",
    "datatype": "entity",
    "url_syntax": "http://www.h-invitational.jp/hinv/spsoup/transcript_view?acc_id=[example_id]",
    "database": "H-invitational Database"
  },
  "vz": {
    "url_syntax": "http://viralzone.expasy.org/all_by_protein/[example_id].html",
    "datatype": "entity",
    "database": "ViralZone",
    "url_example": "http://viralzone.expasy.org/all_by_protein/957.html",
    "object": "entity",
    "uri_prefix": null,
    "generic_url": "http://viralzone.expasy.org/",
    "fullname": null,
    "abbreviation": "VZ",
    "id": "VZ",
    "name": "ViralZone",
    "example_id": "VZ:957"
  },
  "syngo": {
    "example_id": null,
    "name": "The Synapse Gene Ontology and Annotation Initiative",
    "id": "SynGO",
    "fullname": null,
    "abbreviation": "SynGO",
    "generic_url": "https://www.syngoportal.org/",
    "uri_prefix": null,
    "object": "entity",
    "url_example": null,
    "database": "The Synapse Gene Ontology and Annotation Initiative",
    "url_syntax": null,
    "datatype": "entity"
  },
  "rgd": {
    "name": "Rat Genome Database",
    "example_id": "RGD:2004",
    "uri_prefix": null,
    "generic_url": "https://rgd.mcw.edu/",
    "fullname": null,
    "id": "RGD",
    "abbreviation": "RGD",
    "url_example": "https://rgd.mcw.edu/rgdweb/search/search.html?term=2004",
    "object": "gene",
    "datatype": "gene",
    "url_syntax": "https://rgd.mcw.edu/rgdweb/search/search.html?term=[example_id]",
    "database": "Rat Genome Database"
  },
  "cgsc": {
    "database": "CGSC",
    "url_syntax": null,
    "datatype": "entity",
    "object": "entity",
    "url_example": "http://cgsc.biology.yale.edu/Site.php?ID=315",
    "fullname": null,
    "id": "CGSC",
    "abbreviation": "CGSC",
    "generic_url": "http://cgsc.biology.yale.edu/",
    "uri_prefix": null,
    "example_id": "CGSC:rbsK",
    "name": "CGSC"
  },
  "wb_ref": {
    "generic_url": "http://www.wormbase.org/",
    "uri_prefix": null,
    "abbreviation": "WB_REF",
    "fullname": null,
    "id": "WB_REF",
    "example_id": "WB_REF:WBPaper00004823",
    "name": "WormBase database of nematode biology",
    "database": "WormBase database of nematode biology",
    "datatype": "entity",
    "url_syntax": "http://www.wormbase.org/get?name=[example_id]",
    "object": "entity",
    "url_example": "http://www.wormbase.org/get?name=WBPaper00004823"
  },
  "tair": {
    "fullname": null,
    "id": "TAIR",
    "abbreviation": "TAIR",
    "uri_prefix": null,
    "generic_url": "http://www.arabidopsis.org/",
    "name": "The Arabidopsis Information Resource",
    "example_id": "TAIR:locus:2146653",
    "url_syntax": "http://arabidopsis.org/servlets/TairObject?accession=[example_id]",
    "datatype": "primary transcript",
    "database": "The Arabidopsis Information Resource",
    "object": "primary transcript",
    "url_example": "http://arabidopsis.org/servlets/TairObject?accession=locus:2146653"
  },
  "hpa": {
    "example_id": "HPA:HPA000237",
    "name": "Human Protein Atlas tissue profile information",
    "generic_url": "http://www.proteinatlas.org/",
    "uri_prefix": null,
    "fullname": null,
    "abbreviation": "HPA",
    "id": "HPA",
    "url_example": "http://www.proteinatlas.org/tissue_profile.php?antibody_id=HPA000237",
    "object": "entity",
    "database": "Human Protein Atlas tissue profile information",
    "url_syntax": "http://www.proteinatlas.org/tissue_profile.php?antibody_id=[example_id]",
    "datatype": "entity"
  },
  "unipathway": {
    "object": "biological_process",
    "url_example": "http://www.grenoble.prabi.fr/obiwarehouse/unipathway/upa?upid=UPA00155",
    "url_syntax": "http://www.grenoble.prabi.fr/obiwarehouse/unipathway/upa?upid=[example_id]",
    "datatype": "biological_process",
    "database": "UniPathway",
    "name": "UniPathway",
    "example_id": "UniPathway:UPA00155",
    "uri_prefix": null,
    "generic_url": "http://www.grenoble.prabi.fr/obiwarehouse/unipathway",
    "fullname": "UniPathway is a a metabolic door to UniProtKB/Swiss-Prot, a curated resource of metabolic pathways for the UniProtKB/Swiss-Prot knowledgebase.",
    "id": "UniPathway",
    "abbreviation": "UniPathway"
  },
  "sgd_ref": {
    "database": "Saccharomyces Genome Database",
    "datatype": "entity",
    "url_syntax": "http://www.yeastgenome.org/reference/[example_id]/overview",
    "object": "entity",
    "url_example": "http://www.yeastgenome.org/reference/S000049602/overview",
    "fullname": null,
    "abbreviation": "SGD_REF",
    "id": "SGD_REF",
    "generic_url": "http://www.yeastgenome.org/",
    "uri_prefix": null,
    "example_id": "SGD_REF:S000049602",
    "name": "Saccharomyces Genome Database"
  },
  "echobase": {
    "id": "EchoBASE",
    "fullname": null,
    "abbreviation": "EchoBASE",
    "generic_url": "https://www.york.ac.uk/res/thomas/",
    "uri_prefix": null,
    "example_id": "EchoBASE:EB0231",
    "name": "EchoBASE post-genomic database for Escherichia coli",
    "database": "EchoBASE post-genomic database for Escherichia coli",
    "url_syntax": "https://www.york.ac.uk/res/thomas/Gene.cfm?&recordID=[example_id]",
    "datatype": "gene",
    "url_example": "https://www.york.ac.uk/res/thomas/Gene.cfm?&recordID=EB0231",
    "object": "gene"
  },
  "ena": {
    "uri_prefix": null,
    "generic_url": "http://www.ebi.ac.uk/ena/",
    "id": "ENA",
    "fullname": "ENA is made up of a number of distinct databases that includes EMBL-Bank, the newly established Sequence Read Archive (SRA) and the Trace Archive. International nucleotide sequence database collaboration, comprising ENA-EBI nucleotide sequence data library (EMBL-Bank), DNA DataBank of Japan (DDBJ), and NCBI GenBank",
    "abbreviation": "ENA",
    "name": "European Nucleotide Archive",
    "example_id": "ENA:AA816246",
    "url_syntax": "http://www.ebi.ac.uk/ena/data/view/[example_id]",
    "datatype": "entity",
    "database": "European Nucleotide Archive",
    "object": "entity",
    "url_example": "http://www.ebi.ac.uk/ena/data/view/AA816246"
  },
  "psi-mod": {
    "example_id": "MOD_00219",
    "name": "Proteomics Standards Initiative protein modification ontology",
    "fullname": null,
    "abbreviation": "PSI-MOD",
    "id": "PSI-MOD",
    "generic_url": "http://www.psidev.info/groups/protein-modifications",
    "uri_prefix": null,
    "object": "entity",
    "url_example": "http://purl.obolibrary.org/obo/MOD_00219",
    "database": "Proteomics Standards Initiative protein modification ontology",
    "url_syntax": "http://purl.obolibrary.org/obo/[example_id]",
    "datatype": "entity"
  },
  "nc-iubmb": {
    "database": "Nomenclature Committee of the International Union of Biochemistry and Molecular Biology",
    "url_syntax": null,
    "datatype": "entity",
    "object": "entity",
    "url_example": null,
    "id": "NC-IUBMB",
    "fullname": null,
    "abbreviation": "NC-IUBMB",
    "generic_url": "http://www.chem.qmw.ac.uk/iubmb/",
    "uri_prefix": null,
    "example_id": null,
    "name": "Nomenclature Committee of the International Union of Biochemistry and Molecular Biology"
  },
  "imgt_hla": {
    "uri_prefix": null,
    "generic_url": "http://www.ebi.ac.uk/imgt/hla",
    "abbreviation": "IMGT_HLA",
    "fullname": null,
    "id": "IMGT_HLA",
    "name": "IMGT/HLA human major histocompatibility complex sequence database",
    "example_id": "IMGT_HLA:HLA00031",
    "datatype": "entity",
    "url_syntax": null,
    "database": "IMGT/HLA human major histocompatibility complex sequence database",
    "url_example": null,
    "object": "entity"
  },
  "sanger": {
    "example_id": null,
    "name": "Wellcome Trust Sanger Institute",
    "id": "Sanger",
    "fullname": null,
    "abbreviation": "Sanger",
    "generic_url": "http://www.sanger.ac.uk/",
    "uri_prefix": null,
    "url_example": null,
    "object": "entity",
    "database": "Wellcome Trust Sanger Institute",
    "datatype": "entity",
    "url_syntax": null
  },
  "ncbigene": {
    "uri_prefix": null,
    "generic_url": "http://www.ncbi.nlm.nih.gov/",
    "abbreviation": "NCBIGene",
    "fullname": null,
    "id": "NCBIGene",
    "name": "NCBI Gene",
    "example_id": "NCBI_Gene:4771",
    "url_syntax": "https://www.ncbi.nlm.nih.gov/gene/[example_id]",
    "datatype": "gene",
    "database": "NCBI Gene",
    "object": "gene",
    "url_example": "https://www.ncbi.nlm.nih.gov/gene/4771"
  },
  "pdb": {
    "database": "Protein Data Bank",
    "datatype": "protein",
    "url_syntax": "https://www.rcsb.org/structure/[example_id]",
    "object": "protein",
    "url_example": "https://www.rcsb.org/structure/1A4U",
    "abbreviation": "PDB",
    "fullname": null,
    "id": "PDB",
    "generic_url": "https://www.rcsb.org/pdb/",
    "uri_prefix": null,
    "example_id": "PDB:1A4U",
    "name": "Protein Data Bank"
  },
  "eurofung": {
    "url_example": null,
    "object": "entity",
    "database": "Eurofungbase community annotation",
    "url_syntax": null,
    "datatype": "entity",
    "example_id": null,
    "name": "Eurofungbase community annotation",
    "fullname": null,
    "id": "Eurofung",
    "abbreviation": "Eurofung",
    "generic_url": "http://www.eurofung.net/option=com_content&task=section&id=3&Itemid=4",
    "uri_prefix": null
  },
  "rebase": {
    "id": "REBASE",
    "fullname": null,
    "abbreviation": "REBASE",
    "uri_prefix": null,
    "generic_url": "http://rebase.neb.com/rebase/rebase.html",
    "name": "REBASE restriction enzyme database",
    "example_id": "REBASE:EcoRI",
    "url_syntax": "http://rebase.neb.com/rebase/enz/[example_id].html",
    "datatype": "entity",
    "database": "REBASE restriction enzyme database",
    "url_example": "http://rebase.neb.com/rebase/enz/EcoRI.html",
    "object": "entity"
  },
  "sgn": {
    "abbreviation": "SGN",
    "fullname": null,
    "id": "SGN",
    "generic_url": "https://www.sgn.cornell.edu/",
    "uri_prefix": null,
    "example_id": "SGN_gene:7740",
    "name": "Sol Genomics Network",
    "database": "Sol Genomics Network",
    "datatype": "gene",
    "url_syntax": "http://solgenomics.net/phenome/locus_display.pl?locus_id=[example_id]",
    "object": "gene",
    "url_example": "http://solgenomics.net/phenome/locus_display.pl?locus_id=7740"
  },
  "pfam": {
    "name": "Pfam database of protein families",
    "example_id": "Pfam:PF00046",
    "uri_prefix": null,
    "generic_url": "https://www.ebi.ac.uk/interpro/entry/pfam",
    "fullname": "Pfam is a collection of protein families represented by sequence alignments and hidden Markov models (HMMs)",
    "abbreviation": "Pfam",
    "id": "Pfam",
    "url_example": "https://www.ebi.ac.uk/interpro/entry/pfam/PF00069",
    "object": "polypeptide region",
    "datatype": "polypeptide region",
    "url_syntax": "https://www.ebi.ac.uk/interpro/entry/pfam/[example_id]",
    "database": "Pfam database of protein families"
  },
  "ppi": {
    "datatype": "entity",
    "url_syntax": null,
    "database": "Pseudomonas syringae community annotation project",
    "object": "entity",
    "url_example": null,
    "uri_prefix": null,
    "generic_url": "http://www.pseudomonas-syringae.org/",
    "id": "PPI",
    "fullname": null,
    "abbreviation": "PPI",
    "name": "Pseudomonas syringae community annotation project",
    "example_id": null
  },
  "gb": {
    "database": "GenBank",
    "datatype": "protein",
    "url_syntax": "http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?db=nucleotide&val=[example_id]",
    "object": "protein",
    "url_example": "http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?db=nucleotide&val=AA816246",
    "id": "GenBank",
    "fullname": "The NIH genetic sequence database, an annotated collection of all publicly available DNA sequences.",
    "abbreviation": "GB",
    "generic_url": "http://www.ncbi.nlm.nih.gov/Genbank/",
    "uri_prefix": null,
    "example_id": "GB:AA816246",
    "name": "GenBank"
  },
  "mitre": {
    "url_syntax": null,
    "datatype": "entity",
    "database": "The MITRE Corporation",
    "object": "entity",
    "url_example": null,
    "uri_prefix": null,
    "generic_url": "http://www.mitre.org/",
    "fullname": null,
    "abbreviation": "MITRE",
    "id": "MITRE",
    "name": "The MITRE Corporation",
    "example_id": null
  },
  "dtu": {
    "url_example": "http://www.cbs.dtu.dk/services/TMHMM/",
    "object": "entity",
    "datatype": "entity",
    "url_syntax": null,
    "database": "DTU Health Tech Services",
    "name": "DTU Health Tech Services",
    "example_id": "CBS:TMHMM",
    "fullname": "Formerly CBS (Center for Biological Sequence Analysis)",
    "abbreviation": "DTU",
    "id": "DTU",
    "uri_prefix": null,
    "generic_url": "http://www.cbs.dtu.dk/services"
  },
  "seed": {
    "database": "The SEED;",
    "datatype": "entity",
    "url_syntax": "http://www.theseed.org/linkin.cgi?id=[example_id]",
    "url_example": "http://www.theseed.org/linkin.cgi?id=fig|83331.1.peg.1",
    "object": "entity",
    "fullname": "Project to annotate the first 1000 sequenced genomes, develop detailed metabolic reconstructions, and construct the corresponding stoichiometric matrices",
    "abbreviation": "SEED",
    "id": "SEED",
    "generic_url": "http://www.theseed.org",
    "uri_prefix": null,
    "example_id": "SEED:fig|83331.1.peg.1",
    "name": "The SEED;"
  },
  "transfac": {
    "url_example": null,
    "object": "entity",
    "datatype": "entity",
    "url_syntax": null,
    "database": "TRANSFAC database of eukaryotic transcription factors",
    "name": "TRANSFAC database of eukaryotic transcription factors",
    "example_id": null,
    "fullname": null,
    "abbreviation": "TRANSFAC",
    "id": "TRANSFAC",
    "uri_prefix": null,
    "generic_url": "http://www.gene-regulation.com/pub/databases.html#transfac"
  },
  "uniprotkb-kw": {
    "example_id": "UniProtKB-KW:KW-0812",
    "name": "UniProt Knowledgebase keywords",
    "fullname": null,
    "id": "UniProtKB-KW",
    "abbreviation": "UniProtKB-KW",
    "generic_url": "http://www.uniprot.org/keywords/",
    "uri_prefix": null,
    "url_example": "https://www.uniprot.org/keywords/KW-0812",
    "object": "entity",
    "database": "UniProt Knowledgebase keywords",
    "url_syntax": "https://www.uniprot.org/keywords/[example_id]",
    "datatype": "entity"
  },
  "ibb": {
    "database": "iBeetleBase",
    "datatype": "entity",
    "url_syntax": "https://ibeetle-base.uni-goettingen.de/details|[example_id]",
    "object": "entity",
    "url_example": "https://ibeetle-base.uni-goettingen.de/details/TC006055",
    "fullname": "RNAi phenotypes for beetle (Tribolium) genes",
    "id": "iBB",
    "abbreviation": "iBB",
    "generic_url": "https://ibeetle-base.uni-goettingen.de/",
    "uri_prefix": null,
    "example_id": "TC006055",
    "name": "iBeetleBase"
  },
  "maizegdb": {
    "object": "entity",
    "url_example": "https://maizegdb.org/gene_center/gene/12098",
    "url_syntax": "https://maizegdb.org/gene_center/gene/[example_id]",
    "datatype": "entity",
    "database": "MaizeGDB",
    "name": "MaizeGDB",
    "example_id": "MaizeGDB:12098",
    "uri_prefix": null,
    "generic_url": "https://www.maizegdb.org/",
    "abbreviation": "MaizeGDB",
    "fullname": null,
    "id": "MaizeGDB"
  },
  "ecocyc_ref": {
    "example_id": "EcoCyc_REF:COLISALII",
    "name": "Scientific database for the bacterium Escherichia coli K-12 MG1655",
    "generic_url": "https://ecocyc.org/",
    "uri_prefix": null,
    "id": "EcoCyc_REF",
    "fullname": null,
    "abbreviation": "ECOCYC_REF",
    "object": "entity",
    "url_example": "https://ecocyc.org/ECOLI/reference.html?type=CITATION-FRAME&object=COLISALII",
    "database": "Scientific database for the bacterium Escherichia coli K-12 MG1655",
    "datatype": "entity",
    "url_syntax": "https://ecocyc.org/ECOLI/reference.html?type=CITATION-FRAME&object=[example_id]"
  },
  "biomdid": {
    "example_id": "BIOMD:BIOMD0000000045",
    "name": "BioModels Database",
    "generic_url": "https://www.ebi.ac.uk/biomodels/",
    "uri_prefix": null,
    "id": "BIOMD",
    "fullname": null,
    "abbreviation": "BIOMDID",
    "url_example": "https://www.ebi.ac.uk/biomodels/BIOMD0000000045",
    "object": "entity",
    "database": "BioModels Database",
    "datatype": "entity",
    "url_syntax": "https://www.ebi.ac.uk/biomodels/[example_id]"
  },
  "pharmgkb": {
    "object": "entity",
    "url_example": "https://www.pharmgkb.org/do/serve?objId=PA267",
    "database": "Pharmacogenetics and Pharmacogenomics Knowledge Base",
    "datatype": "entity",
    "url_syntax": "https://www.pharmgkb.org/do/serve?objId=[example_id]",
    "example_id": "PharmGKB:PA267",
    "name": "Pharmacogenetics and Pharmacogenomics Knowledge Base",
    "fullname": null,
    "id": "PharmGKB",
    "abbreviation": "PharmGKB",
    "generic_url": "https://www.pharmgkb.org",
    "uri_prefix": null
  },
  "dbsnp": {
    "fullname": null,
    "abbreviation": "dbSNP",
    "id": "dbSNP",
    "generic_url": "http://www.ncbi.nlm.nih.gov/projects/SNP",
    "uri_prefix": null,
    "example_id": "dbSNP:rs3131969",
    "name": "NCBI dbSNP",
    "database": "NCBI dbSNP",
    "url_syntax": "http://www.ncbi.nlm.nih.gov/projects/SNP/snp_ref.cgi?rs=[example_id]",
    "datatype": "entity",
    "object": "entity",
    "url_example": "http://www.ncbi.nlm.nih.gov/projects/SNP/snp_ref.cgi?rs=rs3131969"
  },
  "ipr": {
    "name": "InterPro database of protein domains and motifs",
    "example_id": "InterPro:IPR000001",
    "uri_prefix": null,
    "generic_url": "http://www.ebi.ac.uk/interpro/",
    "fullname": null,
    "id": "InterPro",
    "abbreviation": "IPR",
    "object": "polypeptide region",
    "url_example": "http://www.ebi.ac.uk/interpro/entry/IPR015421",
    "datatype": "polypeptide region",
    "url_syntax": "http://www.ebi.ac.uk/interpro/entry/[example_id]",
    "database": "InterPro database of protein domains and motifs"
  },
  "h-invdb_locus": {
    "name": "H-invitational Database",
    "example_id": "H-invDB_locus:HIX0014446",
    "fullname": null,
    "id": "H-invDB_locus",
    "abbreviation": "H-invDB_locus",
    "uri_prefix": null,
    "generic_url": "http://www.h-invitational.jp/",
    "url_example": "http://www.h-invitational.jp/hinv/spsoup/locus_view?hix_id=HIX0014446",
    "object": "entity",
    "datatype": "entity",
    "url_syntax": "http://www.h-invitational.jp/hinv/spsoup/locus_view?hix_id=[example_id]",
    "database": "H-invitational Database"
  },
  "rap-db": {
    "object": "entity",
    "url_example": "https://rapdb.dna.affrc.go.jp/viewer/gene_detail/irgsp1?name=Os01t0100600-01",
    "datatype": "entity",
    "url_syntax": "https://rapdb.dna.affrc.go.jp/viewer/gene_detail/irgsp1?name=[example_id]",
    "database": "Rice annotation Project database",
    "name": "Rice annotation Project database",
    "example_id": "RAP-DB:Os01t0100600-01",
    "id": "RAP-DB",
    "fullname": null,
    "abbreviation": "RAP-DB",
    "uri_prefix": null,
    "generic_url": "https://rapdb.dna.affrc.go.jp"
  },
  "tritrypdb": {
    "database": "TriTrypDB",
    "datatype": "gene",
    "url_syntax": "https://tritrypdb.org/tritrypdb/app/record/gene/[example_id]",
    "object": "gene",
    "url_example": "https://tritrypdb.org/tritrypdb/app/record/gene/Tb927.1.630",
    "generic_url": "https://tritrypdb.org/",
    "uri_prefix": null,
    "id": "TriTrypDB",
    "fullname": null,
    "abbreviation": "TriTrypDB",
    "example_id": "Tb927.1.630",
    "name": "TriTrypDB"
  },
  "fypo": {
    "url_example": null,
    "object": "entity",
    "database": "Fission Yeast Phenotype Ontology",
    "datatype": "entity",
    "url_syntax": null,
    "example_id": "FYPO:0000001",
    "name": "Fission Yeast Phenotype Ontology",
    "generic_url": "http://www.pombase.org/",
    "uri_prefix": null,
    "id": "FYPO",
    "fullname": null,
    "abbreviation": "FYPO"
  },
  "hgnc-ucl": {
    "fullname": "While based at UCL, HGNC provided GO annotations for proteins during the process of assigning approved gene names and symbols",
    "id": "HGNC-UCL",
    "abbreviation": "HGNC-UCL",
    "generic_url": "https://www.ucl.ac.uk/cardiovascular/hgnc-gene-annotation",
    "uri_prefix": null,
    "example_id": null,
    "name": "UCL-based HGNC",
    "database": "UCL-based HGNC",
    "url_syntax": null,
    "datatype": "entity",
    "object": "entity",
    "url_example": null
  },
  "ecocyc": {
    "name": "Scientific database for the bacterium Escherichia coli K-12 MG1655",
    "example_id": "EcoCyc:ABC-28-CPLX",
    "uri_prefix": null,
    "generic_url": "https://ecocyc.org/",
    "id": "EcoCyc",
    "fullname": null,
    "abbreviation": "EcoCyc",
    "url_example": "https://ecocyc.org/ECOLI/NEW-IMAGE?id=ABC-28-CPLX",
    "object": "protein-containing complex",
    "datatype": "protein-containing complex",
    "url_syntax": "https://ecocyc.org/ECOLI/NEW-IMAGE?id=[example_id]",
    "database": "Scientific database for the bacterium Escherichia coli K-12 MG1655"
  },
  "agricola_id": {
    "name": "AGRICultural OnLine Access",
    "example_id": "AGRICOLA_NAL:TP248.2 P76 v.14",
    "fullname": null,
    "id": "AGRICOLA_ID",
    "abbreviation": "AGRICOLA_ID",
    "uri_prefix": null,
    "generic_url": "http://agricola.nal.usda.gov/",
    "url_example": null,
    "object": "entity",
    "url_syntax": null,
    "datatype": "entity",
    "database": "AGRICultural OnLine Access"
  },
  "ensembl_geneid": {
    "database": "Ensembl database of automatically annotated genomic data",
    "datatype": "gene",
    "url_syntax": "http://www.ensembl.org/id/[example_id]",
    "url_example": "http://www.ensembl.org/id/ENSG00000126016",
    "object": "gene",
    "generic_url": "http://www.ensembl.org/",
    "uri_prefix": null,
    "abbreviation": "ENSEMBL_GeneID",
    "fullname": null,
    "id": "ENSEMBL_GeneID",
    "example_id": "ENSEMBL_GeneID:ENSG00000126016",
    "name": "Ensembl database of automatically annotated genomic data"
  },
  "uniprotkb-subcell": {
    "name": "UniProt Knowledgebase Subcellular Location vocabulary",
    "example_id": "UniProtKB-SubCell:SL-0012",
    "fullname": null,
    "id": "UniProtKB-SubCell",
    "abbreviation": "UniProtKB-SubCell",
    "uri_prefix": null,
    "generic_url": "https://www.uniprot.org/locations/",
    "url_example": "http://www.uniprot.org/locations/SL-0012",
    "object": "entity",
    "datatype": "entity",
    "url_syntax": "http://www.uniprot.org/locations/[example_id]",
    "database": "UniProt Knowledgebase Subcellular Location vocabulary"
  },
  "hpa_antibody": {
    "object": "entity",
    "url_example": "http://www.proteinatlas.org/antibody_info.php?antibody_id=HPA000237",
    "datatype": "entity",
    "url_syntax": "http://www.proteinatlas.org/antibody_info.php?antibody_id=[example_id]",
    "database": "Human Protein Atlas antibody information",
    "name": "Human Protein Atlas antibody information",
    "example_id": "HPA_antibody:HPA000237",
    "uri_prefix": null,
    "generic_url": "http://www.proteinatlas.org/",
    "fullname": null,
    "id": "HPA_antibody",
    "abbreviation": "HPA_antibody"
  },
  "zfin": {
    "object": "variation",
    "url_example": "http://zfin.org/ZDB-GENE-990415-103",
    "datatype": "variation",
    "url_syntax": "http://zfin.org/[example_id]",
    "database": "Zebrafish Information Network",
    "name": "Zebrafish Information Network",
    "example_id": "ZDB-GENE-990415-103",
    "abbreviation": "ZFIN",
    "fullname": null,
    "id": "ZFIN",
    "uri_prefix": null,
    "generic_url": "http://zfin.org/"
  },
  "sp_kw": {
    "generic_url": "http://www.uniprot.org/keywords/",
    "uri_prefix": null,
    "fullname": null,
    "abbreviation": "SP_KW",
    "id": "UniProtKB-KW",
    "example_id": "UniProtKB-KW:KW-0812",
    "name": "UniProt Knowledgebase keywords",
    "database": "UniProt Knowledgebase keywords",
    "datatype": "entity",
    "url_syntax": "https://www.uniprot.org/keywords/[example_id]",
    "url_example": "https://www.uniprot.org/keywords/KW-0812",
    "object": "entity"
  },
  "wikipedia": {
    "url_syntax": "http://en.wikipedia.org/wiki/[example_id]",
    "datatype": "entity",
    "database": "Wikipedia",
    "url_example": "http://en.wikipedia.org/wiki/Endoplasmic_reticulum",
    "object": "entity",
    "uri_prefix": null,
    "generic_url": "http://en.wikipedia.org/",
    "fullname": null,
    "id": "Wikipedia",
    "abbreviation": "Wikipedia",
    "name": "Wikipedia",
    "example_id": "Wikipedia:Endoplasmic_reticulum"
  },
  "apweb": {
    "name": "Angiosperm Phylogeny Website",
    "example_id": "APweb:Glossary",
    "uri_prefix": null,
    "generic_url": "http://www.mobot.org/mobot/research/apweb/",
    "id": "APweb",
    "fullname": null,
    "abbreviation": "APweb",
    "object": "entity",
    "url_example": "http://www.mobot.org/mobot/research/apweb/top/glossarya_h.html",
    "url_syntax": "http://www.mobot.org/mobot/research/apweb/top/glossarya_h.html",
    "datatype": "entity",
    "database": "Angiosperm Phylogeny Website"
  },
  "cgd_ref": {
    "name": "Candida Genome Database",
    "example_id": "CGD_REF:1490",
    "abbreviation": "CGD_REF",
    "fullname": null,
    "id": "CGD_REF",
    "uri_prefix": null,
    "generic_url": "http://www.candidagenome.org/",
    "url_example": "http://www.candidagenome.org/cgi-bin/reference/reference.pl?dbid=1490",
    "object": "entity",
    "datatype": "entity",
    "url_syntax": "http://www.candidagenome.org/cgi-bin/reference/reference.pl?dbid=[example_id]",
    "database": "Candida Genome Database"
  },
  "sp_sl": {
    "datatype": "entity",
    "url_syntax": "http://www.uniprot.org/locations/[example_id]",
    "database": "UniProt Knowledgebase Subcellular Location vocabulary",
    "url_example": "http://www.uniprot.org/locations/SL-0012",
    "object": "entity",
    "fullname": null,
    "abbreviation": "SP_SL",
    "id": "UniProtKB-SubCell",
    "uri_prefix": null,
    "generic_url": "https://www.uniprot.org/locations/",
    "name": "UniProt Knowledgebase Subcellular Location vocabulary",
    "example_id": "UniProtKB-SubCell:SL-0012"
  },
  "rnacentral": {
    "fullname": "An international database of ncRNA sequences",
    "abbreviation": "RNAcentral",
    "id": "RNAcentral",
    "uri_prefix": null,
    "generic_url": "https://rnacentral.org",
    "name": "RNAcentral",
    "example_id": "RNAcentral:URS000047C79B_9606",
    "url_syntax": "https://rnacentral.org/rna/[example_id]",
    "datatype": "ribonucleic acid",
    "database": "RNAcentral",
    "object": "ribonucleic acid",
    "url_example": "https://rnacentral.org/rna/URS000047C79B_9606"
  },
  "iuphar_receptor": {
    "database": "International Union of Pharmacology",
    "url_syntax": "https://www.guidetopharmacology.org/GRAC/ObjectDisplayForward?objectId=[example_id]",
    "datatype": "entity",
    "url_example": "https://www.guidetopharmacology.org/GRAC/ObjectDisplayForward?objectId=56",
    "object": "entity",
    "id": "IUPHAR_RECEPTOR",
    "fullname": null,
    "abbreviation": "IUPHAR_RECEPTOR",
    "generic_url": "http://www.iuphar.org/",
    "uri_prefix": null,
    "example_id": "IUPHAR_RECEPTOR:56",
    "name": "International Union of Pharmacology"
  },
  "ensembl_proteinid": {
    "datatype": "protein",
    "url_syntax": "http://www.ensembl.org/id/[example_id]",
    "database": "Ensembl database of automatically annotated genomic data",
    "url_example": "http://www.ensembl.org/id/ENSP00000361027",
    "object": "protein",
    "id": "ENSEMBL_ProteinID",
    "fullname": null,
    "abbreviation": "ENSEMBL_ProteinID",
    "uri_prefix": null,
    "generic_url": "http://www.ensembl.org/",
    "name": "Ensembl database of automatically annotated genomic data",
    "example_id": "ENSEMBL_ProteinID:ENSP00000361027"
  },
  "refseq": {
    "abbreviation": "RefSeq",
    "fullname": null,
    "id": "RefSeq",
    "generic_url": "http://www.ncbi.nlm.nih.gov/RefSeq/",
    "uri_prefix": null,
    "example_id": "RefSeq:XP_001068954",
    "name": "RefSeq",
    "database": "RefSeq",
    "datatype": "protein",
    "url_syntax": "https://www.ncbi.nlm.nih.gov/protein/[example_id]",
    "url_example": "https://www.ncbi.nlm.nih.gov/protein/NP_001121125",
    "object": "protein"
  },
  "um-bbd_reactionid": {
    "example_id": "UM-BBD_reactionID:r0129",
    "name": "EAWAG Biocatalysis/Biodegradation Database",
    "generic_url": "http://eawag-bbd.ethz.ch/",
    "uri_prefix": null,
    "fullname": null,
    "abbreviation": "UM-BBD_reactionID",
    "id": "UM-BBD_reactionID",
    "object": "entity",
    "url_example": "http://eawag-bbd.ethz.ch/servlets/pageservlet?ptype=r&reacID=r0129",
    "database": "EAWAG Biocatalysis/Biodegradation Database",
    "datatype": "entity",
    "url_syntax": "http://eawag-bbd.ethz.ch/servlets/pageservlet?ptype=r&reacID=[example_id]"
  },
  "img": {
    "url_example": "http://img.jgi.doe.gov/cgi-bin/pub/main.cgi?section=GeneDetail&page=geneDetail&gene_oid=640008772",
    "object": "entity",
    "database": "Integrated Microbial Genomes; JGI web site for genome annotation",
    "datatype": "entity",
    "url_syntax": "http://img.jgi.doe.gov/cgi-bin/pub/main.cgi?section=GeneDetail&page=geneDetail&gene_oid=[example_id]",
    "example_id": "IMG:640008772",
    "name": "Integrated Microbial Genomes; JGI web site for genome annotation",
    "generic_url": "http://img.jgi.doe.gov",
    "uri_prefix": null,
    "fullname": null,
    "id": "IMG",
    "abbreviation": "IMG"
  },
  "grindesc": {
    "url_example": "https://npgsweb.ars-grin.gov/gringlobal/descriptordetail.aspx?id=89033",
    "object": "germplasm descriptors",
    "url_syntax": "https://npgsweb.ars-grin.gov/gringlobal/descriptordetail.aspx?id=[example_id]",
    "datatype": "germplasm descriptors",
    "database": "Germplasm Resources Information Network",
    "name": "Germplasm Resources Information Network",
    "example_id": "GRINdesc:89033",
    "fullname": null,
    "id": "GRINDesc",
    "abbreviation": "GRINDesc",
    "uri_prefix": null,
    "generic_url": "https://www.ars-grin.gov/"
  },
  "aspgd_ref": {
    "database": "Aspergillus Genome Database",
    "datatype": "entity",
    "url_syntax": "http://www.aspergillusgenome.org/cgi-bin/reference/reference.pl?dbid=[example_id]",
    "object": "entity",
    "url_example": "http://www.aspergillusgenome.org/cgi-bin/reference/reference.pl?dbid=90",
    "fullname": null,
    "id": "AspGD_REF",
    "abbreviation": "AspGD_REF",
    "generic_url": "http://www.aspergillusgenome.org/",
    "uri_prefix": null,
    "example_id": "AspGD_REF:90",
    "name": "Aspergillus Genome Database"
  },
  "soy_ref": {
    "example_id": "SOY ref:SoyBase6597900",
    "name": "SoyBase",
    "fullname": null,
    "abbreviation": "SOY_ref",
    "id": "SOY_ref",
    "generic_url": "https://soybase.org/",
    "uri_prefix": null,
    "url_example": "https://www.soybase.org/sbt/search/search_results.php?category=Soybase_ID&search_term=SoyBase3142000126",
    "object": "entity",
    "database": "SoyBase",
    "url_syntax": "https://www.soybase.org/sbt/search/search_results.php?category=Soybase_ID&search_term=[example_id]",
    "datatype": "entity"
  },
  "refgenome": {
    "name": "GO Reference Genomes",
    "example_id": null,
    "id": "RefGenome",
    "fullname": null,
    "abbreviation": "REFGENOME",
    "uri_prefix": null,
    "generic_url": "http://www.geneontology.org/GO.refgenome.shtml",
    "url_example": null,
    "object": "entity",
    "datatype": "entity",
    "url_syntax": null,
    "database": "GO Reference Genomes"
  },
  "iric": {
    "abbreviation": "IRIC",
    "fullname": null,
    "id": "IRIC",
    "generic_url": "https://oryzasnp.org",
    "uri_prefix": null,
    "example_id": "IRIS_313-8922",
    "name": "International Rice Research Institute",
    "database": "International Rice Research Institute",
    "datatype": "entity",
    "url_syntax": "https://oryzasnp.org/_variety.zul?irisid=[example_id]",
    "url_example": "https://oryzasnp.org/_variety.zul?irisid=IRIS_313-8922",
    "object": "entity"
  },
  "tgd_ref": {
    "abbreviation": "TGD_REF",
    "fullname": null,
    "id": "TGD_REF",
    "generic_url": "http://www.ciliate.org/",
    "uri_prefix": null,
    "example_id": "TGD_REF:T000005818",
    "name": "Tetrahymena Genome Database",
    "database": "Tetrahymena Genome Database",
    "url_syntax": "http://db.ciliate.org/cgi-bin/reference/reference.pl?dbid=[example_id]",
    "datatype": "entity",
    "object": "entity",
    "url_example": "http://db.ciliate.org/cgi-bin/reference/reference.pl?dbid=T000005818"
  },
  "pmid": {
    "generic_url": "https://www.ncbi.nlm.nih.gov/pubmed",
    "uri_prefix": null,
    "fullname": null,
    "abbreviation": "PMID",
    "id": "PMID",
    "example_id": "PMID:31931324",
    "name": "PubMed",
    "database": "PubMed",
    "url_syntax": "http://www.ncbi.nlm.nih.gov/pubmed/[example_id]",
    "datatype": "entity",
    "url_example": "https://www.ncbi.nlm.nih.gov/pubmed/31931324",
    "object": "entity"
  },
  "maizegdb_stock": {
    "abbreviation": "MaizeGDB_stock",
    "fullname": null,
    "id": "MaizeGDB_stock",
    "uri_prefix": null,
    "generic_url": "https://www.maizegdb.org/",
    "name": "Maize Genetics and Genomics Database",
    "example_id": "MaizeGDB_stock:282110",
    "url_syntax": "https://maizegdb.org/data_center/stock?id=[example_id]",
    "datatype": "entity",
    "database": "Maize Genetics and Genomics Database",
    "url_example": "https://maizegdb.org/data_center/stock?id=282110",
    "object": "entity"
  },
  "superfamily": {
    "object": "entity",
    "url_example": "http://supfam.org/scop/56994",
    "datatype": "entity",
    "url_syntax": "http://supfam.org/scop/[example_id]",
    "database": "SUPERFAMILY protein annotation database",
    "name": "SUPERFAMILY protein annotation database",
    "example_id": "SUPERFAMILY:56994",
    "id": "SUPERFAMILY",
    "fullname": "A database of structural and functional protein annotations for completely sequenced genomes",
    "abbreviation": "SUPERFAMILY",
    "uri_prefix": null,
    "generic_url": "http://supfam.org/"
  },
  "sgn_ref": {
    "database": "Sol Genomics Network",
    "url_syntax": "https://sgn.cornell.edu/chado/publication.pl?pub_id=[example_id]",
    "datatype": "entity",
    "url_example": "https://sgn.cornell.edu/chado/publication.pl?pub_id=861",
    "object": "entity",
    "generic_url": "https://www.sgn.cornell.edu/",
    "uri_prefix": null,
    "abbreviation": "SGN_ref",
    "fullname": null,
    "id": "SGN_ref",
    "example_id": "SGN_ref:861",
    "name": "Sol Genomics Network"
  },
  "hamap": {
    "url_example": "http://hamap.expasy.org/unirule/MF_00131",
    "object": "entity",
    "url_syntax": "http://hamap.expasy.org/unirule/[example_id]",
    "datatype": "entity",
    "database": "High-quality Automated and Manual Annotation of microbial Proteomes",
    "name": "High-quality Automated and Manual Annotation of microbial Proteomes",
    "example_id": "HAMAP:MF_00031",
    "uri_prefix": null,
    "generic_url": "http://hamap.expasy.org/",
    "fullname": null,
    "abbreviation": "HAMAP",
    "id": "HAMAP"
  },
  "msh": {
    "url_example": "http://id.nlm.nih.gov/mesh/D017209",
    "object": "entity",
    "url_syntax": "http://id.nlm.nih.gov/mesh/[example_id]",
    "datatype": "entity",
    "database": "Medical Subject Headings",
    "name": "Medical Subject Headings",
    "example_id": "MeSH:D017209",
    "fullname": null,
    "id": "MeSH",
    "abbreviation": "MSH",
    "uri_prefix": null,
    "generic_url": "https://meshb.nlm.nih.gov"
  },
  "mgi": {
    "generic_url": "http://www.informatics.jax.org/",
    "uri_prefix": null,
    "fullname": null,
    "abbreviation": "MGI",
    "id": "MGI",
    "example_id": "MGI:MGI:3590672",
    "name": "Mouse Genome Informatics",
    "database": "Mouse Genome Informatics",
    "url_syntax": "http://www.informatics.jax.org/accession/[example_id]",
    "datatype": "variation",
    "object": "variation",
    "url_example": "http://www.informatics.jax.org/accession/MGI:3590672"
  },
  "rhea": {
    "fullname": "Rhea is a manually annotated database of chemical reactions. All data in Rhea is freely accessible and available for anyone to use.",
    "abbreviation": "RHEA",
    "id": "RHEA",
    "uri_prefix": null,
    "generic_url": "https://www.rhea-db.org",
    "name": "Rhea, the Annotated Reactions Database",
    "example_id": "RHEA:25811",
    "url_syntax": "https://www.rhea-db.org/rhea/[example_id]",
    "datatype": "entity",
    "database": "Rhea, the Annotated Reactions Database",
    "url_example": "https://www.rhea-db.org/rhea/25811",
    "object": "entity"
  },
  "po_ref": {
    "name": "Plant Ontology custom references",
    "example_id": "PO_REF:00001",
    "uri_prefix": null,
    "generic_url": "http://planteome.org/po_ref",
    "fullname": null,
    "id": "PO_REF",
    "abbreviation": "PO_REF",
    "url_example": "http://planteome.org/po_ref/00001",
    "object": "entity",
    "datatype": "entity",
    "url_syntax": "http://planteome.org/po_ref/[example_id]",
    "database": "Plant Ontology custom references"
  },
  "wbbt": {
    "abbreviation": "WBbt",
    "fullname": null,
    "id": "WBbt",
    "uri_prefix": null,
    "generic_url": "http://www.wormbase.org/",
    "name": "C. elegans gross anatomy",
    "example_id": "WBbt:0005733",
    "datatype": "anatomical entity",
    "url_syntax": "http://www.wormbase.org/get?name=[example_id]",
    "database": "C. elegans gross anatomy",
    "url_example": "http://www.wormbase.org/get?name=WBbt:0005733",
    "object": "anatomical entity"
  },
  "go_noctua": {
    "fullname": "Manual annotation derived from LEGO annotations",
    "id": "GO_Noctua",
    "abbreviation": "GO_Noctua",
    "uri_prefix": null,
    "generic_url": "https://github.com/geneontology/noctua-models",
    "name": "GO Noctua",
    "example_id": null,
    "datatype": "entity",
    "url_syntax": null,
    "database": "GO Noctua",
    "url_example": null,
    "object": "entity"
  },
  "japonicusdb": {
    "name": "JaponicusDB",
    "example_id": "JaponicusDB:SJAG_01143",
    "id": "JaponicusDB",
    "fullname": null,
    "abbreviation": "JaponicusDB",
    "uri_prefix": null,
    "generic_url": "https://www.japonicusdb.org/",
    "url_example": "https://www.japonicusdb.org/gene/SJAG_01143",
    "object": "gene",
    "datatype": "gene",
    "url_syntax": "https://www.japonicusdb.org/gene/[example_id]",
    "database": "JaponicusDB"
  },
  "hgnc": {
    "database": "HUGO Gene Nomenclature Committee",
    "url_syntax": "https://www.genenames.org/data/gene-symbol-report/#!/hgnc_id/HGNC:[example_id]",
    "datatype": "gene",
    "object": "gene",
    "url_example": "https://www.genenames.org/data/gene-symbol-report/#!/hgnc_id/HGNC:29",
    "generic_url": "http://www.genenames.org/",
    "uri_prefix": null,
    "fullname": null,
    "abbreviation": "HGNC",
    "id": "HGNC",
    "example_id": "HGNC:29",
    "name": "HUGO Gene Nomenclature Committee"
  },
  "pso_git": {
    "example_id": "PSO_GIT:169",
    "name": "GitHub Issue Tracker for PSO",
    "fullname": null,
    "id": "PSO_GIT",
    "abbreviation": "PSO_GIT",
    "generic_url": "https://github.com/Planteome/plant-stress-ontology",
    "uri_prefix": null,
    "url_example": "https://github.com/Planteome/plant-stress-ontology/issues/169",
    "object": "entity",
    "database": "GitHub Issue Tracker for PSO",
    "url_syntax": "https://github.com/Planteome/plant-stress-ontology/issues/[example_id]",
    "datatype": "entity"
  },
  "wikipediaversioned": {
    "uri_prefix": null,
    "generic_url": "http://en.wikipedia.org/",
    "fullname": null,
    "id": "WikipediaVersioned",
    "abbreviation": "WikipediaVersioned",
    "name": "WikipediaVersioned",
    "example_id": "WikipediaVersioned:Fallopian_tube&oldid=998395727",
    "url_syntax": "https://en.wikipedia.org/w/index.php?title=[example_id]",
    "datatype": "entity",
    "database": "WikipediaVersioned",
    "url_example": "https://en.wikipedia.org/w/index.php?title=Fallopian_tube&oldid=998395727",
    "object": "entity"
  },
  "casspc": {
    "url_syntax": "https://researcharchive.calacademy.org/research/ichthyology/catalog/fishcatget.asp?spid=[example_id]",
    "datatype": "entity",
    "database": "Catalog of Fishes species database",
    "url_example": "https://researcharchive.calacademy.org/research/ichthyology/catalog/fishcatget.asp?spid=1979",
    "object": "entity",
    "uri_prefix": null,
    "generic_url": "https://researcharchive.calacademy.org/research/ichthyology/catalog/fishcatmain.asp",
    "id": "CASSPC",
    "fullname": null,
    "abbreviation": "CASSPC",
    "name": "Catalog of Fishes species database",
    "example_id": null
  },
  "tigrfams": {
    "name": "TIGRFAMs HMM collection at the J. Craig Venter Institute",
    "example_id": "TIGRFAMS:TIGR00254",
    "uri_prefix": null,
    "generic_url": "http://tigrfams.jcvi.org/cgi-bin/index.cgi",
    "abbreviation": "TIGRFAMS",
    "fullname": null,
    "id": "TIGRFAMS",
    "object": "polypeptide region",
    "url_example": "http://tigrfams.jcvi.org/cgi-bin/HmmReportPage.cgi?acc=TIGR00254",
    "datatype": "polypeptide region",
    "url_syntax": "http://tigrfams.jcvi.org/cgi-bin/HmmReportPage.cgi?acc=[example_id]",
    "database": "TIGRFAMs HMM collection at the J. Craig Venter Institute"
  },
  "go_central": {
    "id": "GO_Central",
    "fullname": "Manual annotation from PAINT curators into the UniProt Protein2GO curation tool.",
    "abbreviation": "GO_CENTRAL",
    "generic_url": "http://www.geneontology.org/",
    "uri_prefix": null,
    "example_id": null,
    "name": "GO Central",
    "database": "GO Central",
    "datatype": "entity",
    "url_syntax": null,
    "object": "entity",
    "url_example": null
  },
  "fb": {
    "object": "reference",
    "url_example": "https://flybase.org/reports/FBrf0193169.htm",
    "url_syntax": "http://flybase.org/reports/[example_id].htm",
    "datatype": "reference",
    "database": "FlyBase",
    "name": "FlyBase",
    "example_id": "FBrf0193169",
    "abbreviation": "FB",
    "fullname": null,
    "id": "FB",
    "uri_prefix": null,
    "generic_url": "http://flybase.org/"
  },
  "pato": {
    "url_example": "http://purl.obolibrary.org/obo/PATO_0001420",
    "object": "entity",
    "url_syntax": null,
    "datatype": "entity",
    "database": "Phenotypic quality ontology",
    "name": "Phenotypic quality ontology",
    "example_id": "PATO:0001420",
    "uri_prefix": null,
    "generic_url": "http://www.obofoundry.org/ontology/pato.html",
    "abbreviation": "PATO",
    "fullname": null,
    "id": "PATO"
  },
  "um-bbd_ruleid": {
    "datatype": "entity",
    "url_syntax": "http://eawag-bbd.ethz.ch/servlets/rule.jsp?rule=[example_id]",
    "database": "EAWAG Biocatalysis/Biodegradation Database",
    "url_example": "http://eawag-bbd.ethz.ch/servlets/rule.jsp?rule=bt0330",
    "object": "entity",
    "uri_prefix": null,
    "generic_url": "http://eawag-bbd.ethz.ch/",
    "abbreviation": "UM-BBD_ruleID",
    "fullname": null,
    "id": "UM-BBD_ruleID",
    "name": "EAWAG Biocatalysis/Biodegradation Database",
    "example_id": "UM-BBD_ruleID:bt0330"
  },
  "obo_sf2_peco": {
    "object": "entity",
    "url_example": "https://sourceforge.net/p/obo/plant-environment-ontology-eo/89/",
    "url_syntax": "https://sourceforge.net/p/obo/plant-environment-ontology-eo/[example_id]",
    "datatype": "entity",
    "database": "Source Forge OBO plant-experimental-conditions-ontology (PECO) term request tracker",
    "name": "Source Forge OBO plant-experimental-conditions-ontology (PECO) term request tracker",
    "example_id": "OBO_SF2_PECO:89",
    "abbreviation": "OBO_SF2_PECO",
    "fullname": null,
    "id": "OBO_SF2_PECO",
    "uri_prefix": null,
    "generic_url": "https://sourceforge.net/p/obo/plant-environment-ontology-eo/"
  },
  "resid": {
    "abbreviation": "RESID",
    "fullname": null,
    "id": "RESID",
    "uri_prefix": null,
    "generic_url": "https://proteininformationresource.org/resid/resid.shtml",
    "name": "RESID Database of Protein Modifications",
    "example_id": "RESID:AA0062",
    "datatype": "entity",
    "url_syntax": "https://proteininformationresource.org/cgi-bin/resid?id=[example_id]",
    "database": "RESID Database of Protein Modifications",
    "object": "entity",
    "url_example": "https://proteininformationresource.org/cgi-bin/resid?id=AA0062"
  },
  "aspgdid": {
    "object": "gene",
    "url_example": "http://www.aspergillusgenome.org/cgi-bin/locus.pl?dbid=ASPL0000067538",
    "database": "Aspergillus Genome Database",
    "url_syntax": "http://www.aspergillusgenome.org/cgi-bin/locus.pl?dbid=[example_id]",
    "datatype": "gene",
    "example_id": "AspGD:ASPL0000067538",
    "name": "Aspergillus Genome Database",
    "fullname": null,
    "abbreviation": "AspGDID",
    "id": "AspGD",
    "generic_url": "http://www.aspergillusgenome.org/",
    "uri_prefix": null
  }
};

///
/// Exportable body.
///

module.exports = xrefs;

},{}],8:[function(require,module,exports){
/* 
 * Package: handler.js
 * 
 * Namespace: amigo.handler
 * 
 * Generic AmiGO handler (conforming to what /should/ be described in
 * the BBOP JS documentation), fed by <amigo.data.dispatch>.
 */

var bbop = require('bbop-core');
var us = require('underscore');
var each = us.each;

/*
 * Constructor: handler
 * 
 * Create an object that will run functions in the namespace with a
 * specific profile.
 * 
 * These functions have a well defined interface so that other
 * packages can use them (for example, the results display in
 * LiveSearch.js).
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  self
 */
var handler = function handler(dispatch_table) {
  this._is_a = 'amigo2.handler';

  // Okay, since trying functions into existance is slow, we'll
  // create a cache of strings to functions.
  //this.mangle = bbop.uuid();
  //    this.string_to_function_map = {};
  //this.entries = 0; // a little extra for debugging and testing
  this.dispatch_table = dispatch_table;
};

/*
 * Function: dispatch
 * 
 * Return a string.
 * 
 * The fallback function is called if no match could be found in the
 * amigo.data.dispatch. It is called with the name and context
 * arguments in the same order.
 * 
 * Arguments:
 *  data - the incoming string thing to be handled
 *  field_name - the field name to be processed
 *  context - *[optional]* a string to add extra context to the call
 *  fallback - *[optional]* a fallback function to call in case nothing is found
 * 
 * Returns:
 *  string; null if it couldn't create anything
 */
handler.prototype.dispatch = function (data, field_name, context, fallback) {
  var run_fun = null;
  var retval = null;

  // First, try and get the most specific.
  if (us.isObject(this.dispatch_table[field_name])) {
    var field_hash = this.dispatch_table[field_name];

    // console.log('data', data);
    // console.log('field_name', field_name);
    // console.log('context', context);
    // console.log('fallback', fallback);
    // console.log('field_hash', field_hash);

    // Get the most specific function to run.
    if (us.isObject(field_hash['context']) && us.isString(context) && us.isFunction(field_hash['context'][context])) {
      //console.log('context function');
      run_fun = field_hash['context'][context];
    } else if (us.isFunction(field_hash['default'])) {
      // Generic default as second place.
      //console.log('default function');
      run_fun = field_hash['default'];
    } else if (us.isFunction(fallback)) {
      //console.log('fallback function');
      run_fun = fallback;
    }
  }

  // We are now ensured that either we have a callable function or
  // null, so let's finish it--either the return value of the called
  // function or null.
  if (us.isFunction(run_fun)) {
    retval = run_fun(data, field_name, context);
  }
  return retval;
};

///
/// Exportable body.
///

module.exports = handler;

},{"bbop-core":10,"underscore":11}],9:[function(require,module,exports){
/* 
 * Package: linker.js
 * 
 * Namespace: amigo.linker
 * 
 * Generic AmiGO link generator, fed by <amigo.data.server> for local
 * links and <amigo.data.xrefs> for non-local links.
 * 
 * NOTE: A lot of this is lifted from the (defunct) amigo2.js
 * package. However, the future should be here.
 */

var bbop = require('bbop-core');
var us = require('underscore');
var each = us.each;

/*
 * Constructor: linker
 * 
 * Create an object that can make URLs and/or anchors.
 * 
 * These functions have a well defined interface so that other
 * packages can use it.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  self
 */
var linker = function linker(xrefs, server) {
  this._is_a = 'amigo2.linker';

  // TODO:BUG: With the new dispatcher, relative URLs no longer work.

  this._xrefs = xrefs;

  // Easy app base.
  this.app_base = server.app_base;
  // Internal term matcher.
  this.term_regexp = null;
  var internal_regexp_str = server.term_regexp;
  if (internal_regexp_str) {
    this.term_regexp = new RegExp(internal_regexp_str);
  }

  // Categories for different special cases (internal links).
  this.ont_category = {
    'term': true,
    'ontology_class': true,
    'annotation_class': true,
    'annotation_class_closure': true,
    'annotation_class_list': true,
    // Noctua model stuff.
    'function_class': true,
    'function_class_closure': true,
    'process_class': true,
    'process_class_closure': true,
    'location_list': true,
    'location_list_closure': true
  };
  this.bio_category = {
    'gp': true,
    'gene_product': true,
    'bioentity': true
  };
  this.ref_category = {
    'reference': true
  };
  this.model_category = {
    'model': true
  };
  this.search_category = {
    // not including the trivial medial_search below
    'search': true,
    'live_search': true
  };
  this.search_modifier = {
    // Possibly "dynamic".
    'gene_product': '/bioentity',
    'bioentity': '/bioentity',
    'ontology': '/ontology',
    'reference': '/reference',
    'annotation': '/annotation',
    'model': '/model',
    'family': '/family',
    'lego_unit': '/lego_unit',
    'general': '/general'
  };
  this.other_interlinks = {
    'medial_search': '/amigo/medial_search',
    'landing': '/amigo/landing',
    'tools': '/amigo/software_list',
    'schema_details': '/amigo/schema_details',
    'load_details': '/amigo/load_details',
    'browse': '/amigo/browse',
    'goose': '/goose',
    'grebe': '/grebe',
    'gannet': '/gannet',
    'repl': '/repl'
  };
};

/*
 * Function: url
 * 
 * Return a url string.
 * 
 * Arguments:
 *  args - id
 *  xid - *[optional]* an internal transformation id
 *  modifier - *[optional]* modify xid; only used with xid
 * 
 * Returns:
 *  string (url); null if it couldn't create anything
 */
linker.prototype.url = function (id, xid, modifier) {
  var retval = null;

  ///
  /// AmiGO hard-coded internal link types.
  ///

  // For us, having an xid means that we will be doing some more
  // complicated routing.
  if (xid && xid !== '') {
    // First let's do the ones that need an associated id to
    // function--either data urls or searches.
    if (id && id !== '') {
      if (this.ont_category[xid]) {
        retval = this.app_base + '/amigo/term/' + id;
        //retval = _add_restmark_modifier(retval, modifier);
      } else if (this.bio_category[xid]) {
        retval = this.app_base + '/amigo/gene_product/' + id;
        //retval = _add_restmark_modifier(retval, modifier);
      } else if (this.ref_category[xid]) {
        // Only operate if it's a PubMed ID.
        var db = bbop.first_split(':', id)[0];
        if (db && db === 'PMID') {
          retval = this.app_base + '/amigo/reference/' + id;
          //retval = _add_restmark_modifier(retval, modifier);
        }
      } else if (this.model_category[xid]) {
        retval = this.app_base + '/amigo/model/' + id;
      } else if (this.search_category[xid]) {
        // First, try and get the proper path out. Will
        // hardcode for now since some paths don't map
        // directly to the personality.
        var search_path = '';
        if (this.search_modifier[modifier]) {
          search_path = this.search_modifier[modifier];
        }
        retval = this.app_base + '/amigo/search' + search_path;
        if (id) {
          // Ugh...decide if the ID indicated a restmark or
          // a full http action bookmark.
          var http_re = new RegExp("^http");
          if (http_re.test(id)) {
            // HTTP bookmark.
            retval = retval + '?bookmark=' + id;
          } else {
            // minimalist RESTy restmark.
            retval = retval + '?' + id;
          }
        }
      }
    }

    // Things that do not need an id to function--like just
    // popping somebody over to Grebe or the medial search.
    if (!retval) {
      if (this.other_interlinks[xid]) {
        var extension = this.other_interlinks[xid];
        retval = this.app_base + extension;

        // Well, for medial search really, but it might be
        // general?
        if (xid === 'medial_search') {
          // The possibility of just tossing back an empty
          // search for somebody downstream to fill in.
          if (typeof id !== 'undefined' && id !== null) {
            retval = retval + '?q=' + id;
          }
        }
      }
    }
  }

  ///
  /// External resources. For us, if we haven't found something
  /// so far, try the data xrefs.
  ///

  // Since we couldn't find anything with our explicit local
  // transformation set, drop into the great abyss of the xref data.
  if (!retval && id && id !== '') {
    // not internal, but still has an id

    // First, extract the probable source and break it into parts.
    var full_id_parts = bbop.first_split(':', id);
    if (full_id_parts && full_id_parts[0] && full_id_parts[1]) {
      var src = full_id_parts[0];
      var sid = full_id_parts[1];

      // Now, check to see if it is indeed in our store.
      var lc_src = src.toLowerCase();
      var xref = this._xrefs[lc_src];
      if (xref && xref['url_syntax']) {
        // Careful, as the global flag has been deprecated;
        // now need to compile at runtime:
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace
        //retval = xref['url_syntax'].replace('[example_id]', sid, 'g');
        var scn = new RegExp('\\[example_id\\]', 'g');
        retval = xref['url_syntax'].replace(scn, sid);
      }
    }
  }
  return retval;
};

/*
 * Function: anchor
 * 
 * Return a link as a chunk of HTML, all ready to consume in a
 * display.
 * 
 * Arguments:
 *  args - hash--'id' required; 'label' and 'hilite' are inferred if not extant
 *  xid - *[optional]* an internal transformation id
 *  rest - *[optional]* modify xid; only used with xid
 * 
 * Returns:
 *  string (link); null if it couldn't create anything
 */
linker.prototype.anchor = function (args, xid, modifier) {
  var anchor = this;
  var retval = null;

  // Don't even start if there is nothing.
  if (args) {
    // Get what fundamental arguments we can.
    var id = args['id'];
    if (id) {
      // Infer label from id if not present.
      var label = args['label'];
      if (!label) {
        label = id;
      }

      // Infer hilite from label if not present.
      var hilite = args['hilite'];
      if (!hilite) {
        hilite = label;
      }

      // See if the URL is legit. If it is, make something for it.
      var url = this.url(id, xid, modifier);
      if (url) {
        // First, see if it is one of the internal ones we know about
        // and make something special for it.
        if (xid) {
          if (this.ont_category[xid]) {
            // Possible internal/external detection here.
            // var class_str = ' class="amigo-ui-term-internal" ';
            var class_str = '';
            var title_str = 'title="' +
            // internal default
            id + ' (go to the term details page for ' + label + ')"';
            if (this.term_regexp) {
              if (this.term_regexp.test(id)) {} else {
                class_str = ' class="amigo-ui-term-external" ';
                title_str = ' title="' + id + ' (is an external term; click ' + 'to view our internal information for ' + label + ')" ';
              }
            }

            //retval = '<a title="Go to the term details page for '+
            retval = '<a ' + class_str + title_str + ' href="' + url + '">' + hilite + '</a>';
          } else if (this.bio_category[xid]) {
            retval = '<a title="' + id + ' (go to the details page for ' + label + ')" href="' + url + '">' + hilite + '</a>';
          } else if (this.search_category[xid]) {
            retval = '<a title="Reinstate bookmark for ' + label + '." href="' + url + '">' + hilite + '</a>';
          }
        }

        // If it wasn't in the special transformations, just make
        // something generic.
        if (!retval) {
          retval = '<a title="' + id + ' (go to the page for ' + label + ')" href="' + url + '">' + hilite + '</a>';
        }
      }
    }
  }
  return retval;
};

///
/// Exportable body.
///

module.exports = linker;

},{"bbop-core":10,"underscore":11}],10:[function(require,module,exports){
/**
 * BBOP language extensions to JavaScript, complimenting Underscore.js.
 * Purpose: Helpful basic utilities and operations to fix common needs in JS.
 *
 * @module bbop-core 
 */

var us = require('underscore');
var each = us.each;

///
///
///

/**
 * Return the best guess (true/false) for whether or not a given
 * object is being used as a hash.
 *
 * @function
 * @name module:bbop-core#is_hash
 * @param {} in_thing - the thing in question
 * @returns {boolean} boolean
 */
function _is_hash(in_thing){
    var retval = false;
    if( in_thing && us.isObject(in_thing) &&
	! us.isArray(in_thing) &&
	! us.isFunction(in_thing) ){
	retval = true;
    }
    return retval;
}

/**
 * Return the string best guess for what the input is, null if it
 * can't be identified. In addition to the _is_a property convention,
 * current core output strings are: 'null', 'array', 'boolean',
 * 'number', 'string', 'function', and 'object'.
 * 
 * @function
 * @name module:bbop-core#what_is
 * @param {any} in_thing - the thing in question
 * @returns {string} string
 */
function _what_is(in_thing){
    var retval = null;
    if( typeof(in_thing) != 'undefined' ){
	
	// If it's an object, try and guess the 'type', otherwise, let
	// typeof.
	if( in_thing == null ){
	    retval = 'null';
	}else if( typeof(in_thing) == 'object' ){
	    
	    // Look for the 'is_a' property that I should be using.
	    if( typeof(in_thing._is_a) != 'undefined' ){
		retval = in_thing._is_a;
	    }else{
		if( us.isArray(in_thing) ){
		    retval = 'array';
		}else{
		    retval = 'object';
		}		
	    }
	}else{
	    retval = typeof(in_thing);
	}
    }
    return retval;
}

/**
 * Dump an object to a string form as best as possible. More meant for
 * debugging. This is meant to be an Object walker. For a slightly
 * different take (Object identification), see <to_string>.
 *
 * @see module:bbop-core.to_string
 * @function
 * @name module:bbop-core#dump
 * @param {} in_thing - something
 * @returns {string} string
 */
function _dump(thing){

    var retval = '';
    
    var what = _what_is(thing);
    if( what == null ){
	retval = 'null';
    }else if( what == 'null' ){
	retval = 'null';
    }else if( what == 'string' ){
	retval = '"' + thing + '"';
    }else if( what == 'boolean' ){
	if( thing ){
	    retval = "true";
	}else{
	    retval = "false";
	}
    }else if( what == 'array' ){
	
	var astack = [];
	each(thing, function(item, i){
	    astack.push(_dump(item));
	});
	retval = '[' + astack.join(', ') + ']';
	
    }else if( what == 'object' ){
	
	var hstack = [];
	each(thing, function(val, key){
	    hstack.push('"'+ key + '": ' + _dump(val));
	});
	retval = '{' + hstack.join(', ') + '}';
	
    }else{
	retval = thing;
    }
    
    return retval;
}

/**
 * (Deep) clone an object down to its atoms.
 *
 * @function
 * @name module:bbop-core#clone
 * @param {any} thing - whatever
 * @returns {any} a new whatever
 */
function _clone(thing){

    var clone = null;
    
    if( typeof(thing) === 'undefined' ){
	// Nothin' doin'.
	//print("looks undefined");
    }else if( typeof(thing) === 'function' ){
	// Dunno about this case...
	//print("looks like a function");
	clone = thing;
    }else if( typeof(thing) === 'boolean' ||
	      typeof(thing) === 'number' ||
	      typeof(thing) === 'string' ){
		  // Atomic types can be returned as-is (i.e. assignment in
		  // JS is the same as copy for atomic types).
		  //print("cloning atom: " + thing);
		  clone = thing;
	      }else if( typeof(thing) === 'object' ){
		  // Is it a null, hash, or an array?
		  if( thing == null ){
		      clone = null;
		  }else if( Array.isArray(thing) ){
		      // Looks like an array!
		      //print("looks like an array");
		      clone = [];
		      for(var i = 0; i < thing.length; i++){
			  clone[i] = _clone(thing[i]);
		      }
		  }else{
		      // Looks like a hash!
		      //print("looks like a hash");
		      clone = {};
		      for(var h in thing){
			  clone[h] = _clone(thing[h]);
		      }
		  }
	      }else{
		  // Then I don't know what it is--might be platform dep.
		  //print("no idea what it is");
	      }
    return clone;
}

/**
 * Attempt to return a two part split on the first occurrence of a
 * character.
 *
 * Returns '' for parts not found.
 * 
 * Unit tests make the edge cases clear.
 * 
 * @function
 * @name module:bbop-core#first_split
 * @param {String} character - the character to split on
 * @param {String} string - the string to split
 * @returns {Array} list of first and second parts
 */
function _first_split(character, string){

    var retlist = null;
    
    var eq_loc = string.indexOf(character);
    if( eq_loc == 0 ){
	retlist = ['', string.substr(eq_loc +1, string.length)];
    }else if( eq_loc > 0 ){
	var before = string.substr(0, eq_loc);
	var after = string.substr(eq_loc +1, string.length);
	retlist = [before, after];
    }else{
	retlist = ['', ''];
    }
    
    return retlist;
}

// Exportable body.
module.exports = {

    clone: _clone,
    dump: _dump,
    first_split: _first_split,
    is_hash: _is_hash,
    what_is: _what_is,

    /**
     * Crop a string nicely.
     * 
     * Returns: Nothing. Side-effects: throws an error if the namespace
     * defined by the strings is not currently found.
     * 
     * @param {} str - the string to crop
     * @param {} lim - the final length to crop to (optional, defaults to 10)
     * @param {} suff - the string to add to the end (optional, defaults to '')
     * @returns {string} cropped string
     */
    crop: function(str, lim, suff){
	var ret = str;
	
	var limit = 10;
	if( lim ){ limit = lim; }

	var suffix = '';
	if( suff ){ suffix = suff; }
	
	if( str.length > limit ){
	    ret = str.substring(0, (limit - suffix.length)) + suffix;
	}
	return ret;
    },

    /**
     * Fold a pair of hashes together, using the first one as an initial
     * template--only the keys in the default hash will be defined in the
     * final hash--and the second hash getting precedence.
     * 
     * The can be quite useful when defining functions--essentially
     * allowing a limited default value system for arguments.
     * 
     * @see module:bbop-core.merge
     * @param {object} default_hash - Template hash.
     * @param {object} arg_hash - Argument hash to match.
     * @returns {object} a new hash
     */
    fold: function(default_hash, arg_hash){

	if( ! default_hash ){ default_hash = {}; }
	if( ! arg_hash ){ arg_hash = {}; }

	var ret_hash = {};
	for( var key in default_hash ){
	    if( ! us.isUndefined(arg_hash[key]) ){
		ret_hash[key] = arg_hash[key];
	    }else{
		ret_hash[key] = default_hash[key];
	    }
	}
	return ret_hash;
    },

    /**
     * Merge a pair of hashes together, the second hash getting
     * precedence. This is a superset of the keys both hashes.
     * 
     * @see module:bbop-core.fold
     * @param {} older_hash - first pass
     * @param {} newer_hash - second pass
     * @returns {object} a new hash
     */
    merge: function(older_hash, newer_hash){

	if( ! older_hash ){ older_hash = {}; }
	if( ! newer_hash ){ newer_hash = {}; }

	var ret_hash = {};
	function _add (val, key){
	    ret_hash[key] = val;
	}
	each(older_hash, _add);
	each(newer_hash, _add);
	return ret_hash;
    },

    /**
     * Get the hash keys from a hash/object, return as an array.
     *
     * @param {} arg_hash - the hash in question
     * @returns {Array} an array of keys
     */
    get_keys: function(arg_hash){

	if( ! arg_hash ){ arg_hash = {}; }
	var out_keys = [];
	for (var out_key in arg_hash) {
	    if (arg_hash.hasOwnProperty(out_key)) {
		out_keys.push(out_key);
	    }
	}
	
	return out_keys;
    },

    /**
     * Returns a hash form of the argument array/list. For example ['a',
     * 'b'] would become {'a': true, 'b': true} or [['a', '12'], ['b',
     * '21']] would become {'a': '12', 'b': '21'}. Using mixed sub-lists
     * is undefined.
     *
     * @param {Array} list - the list to convert
     * @returns {object} a hash
     */
    hashify: function(list){
	var rethash = {};

	if( list && list[0] ){
	    if( us.isArray(list[0]) ){
		each(list, function(item){
		    var key = item[0];
		    var val = item[1];
		    if( ! us.isUndefined(key) ){
			rethash[key] = val;
		    }
		});
	    }else{
		each(list, function(item){
		    rethash[item] = true;
		});
	    }
	}

	return rethash;
    },

    // /**
    //  * Returns true if it things the two incoming arguments are value-wise
    //  * the same.
    //  * 
    //  * Currently only usable for simple (atomic single layer) hashes,
    //  * atomic lists, boolean, null, number, and string values. Will return
    //  * false otherwise.
    //  * 
    //  * @param {} thing1 - thing one
    //  * @param {} thing2 - thing two
    //  *
    //  * Returns: boolean
    //  */
    // is_same: function(thing1, thing2){

    // 	var retval = false;

    // 	// If is hash...steal the code from test.js.
    // 	if( _is_hash(thing1) && _is_hash(thing2) ){
    
    // 	    var same_p = true;
    
    // 	    // See if the all of the keys in hash1 are defined in hash2
    // 	    // and that they have the same ==.
    // 	    for( var k1 in thing1 ){
    // 		if( typeof thing2[k1] === 'undefined' ||
    // 		    thing1[k1] !== thing2[k1] ){
    // 			same_p = false;
    // 			break;
    // 		    }
    // 	    }

    // 	    // If there is still no problem...
    // 	    if( same_p ){
    
    // 		// Reverse of above.
    // 		for( var k2 in thing2 ){
    // 		    if( typeof thing1[k2] === 'undefined' ||
    // 			thing2[k2] !== thing1[k2] ){
    // 			    same_p = false;
    // 			    break;
    // 			}
    // 		}
    // 	    }

    // 	    retval = same_p;

    // 	}else if( bbop.core.is_array(thing1) && bbop.core.is_array(thing2) ){
    // 	    // If it's an array convert and pass it off to the hash function.
    // 	    retval = bbop.core.is_same(bbop.core.hashify(thing1),
    // 				       bbop.core.hashify(thing2));
    // 	}else{
    
    // 	    // So, we're hopefully dealing with an atomic type. If they
    // 	    // are the same, let's go ahead and try.
    // 	    var t1_is = _what_is(thing1);
    // 	    var t2_is = _what_is(thing2);
    // 	    if( t1_is == t2_is ){
    // 		if( t1_is == 'null' ||
    // 		    t1_is == 'boolean' ||
    // 		    t1_is == 'null' ||
    // 		    t1_is == 'number' ||
    // 		    t1_is == 'string' ){
    // 			if( thing1 == thing2 ){
    // 			    retval = true;
    // 			}
    // 		    }
    // 	    }
    // 	}

    // 	return retval;
    // },

    /**
     * Return the best guess (true/false) for whether or not a given
     * object is being used as an array.
     *
     * @param {} in_thing - the thing in question
     * @returns {boolean} boolean
     */
    is_array: function(in_thing){
	var retval = false;
	if( in_thing &&
	    Array.isArray(in_thing) ){
	    retval = true;
	}
	return retval;
    },

    /**
     * Return true/false on whether or not the object in question has any
     * items of interest (iterable?).
     *
     * @param {} in_thing - the thing in question
     * @returns {boolean} boolean
     */
    is_empty: function(in_thing){
	var retval = false;
	if( us.isArray(in_thing) ){
	    if( in_thing.length == 0 ){
		retval = true;
	    }
	}else if( _is_hash(in_thing) ){
	    var in_hash_keys = us.keys(in_thing);
	    if( in_hash_keys.length == 0 ){
		retval = true;
	    }
	}else{
	    // TODO: don't know about this case yet...
	    //throw new Error('unsupported type in is_empty');	
	    retval = false;
	}
	return retval;
    },

    /**
     * Return true/false on whether or not the passed object is defined.
     *
     * @param {} in_thing - the thing in question
     * @returns {boolean} boolean
     */
    is_defined: function(in_thing){
	var retval = true;
	if( typeof(in_thing) === 'undefined' ){
	    retval = false;
	}
	return retval;
    },

    /**
     * Take an array or hash and pare it down using a couple of functions
     * to what we want.
     * 
     * Both parameters are optional in the sense that you can set them to
     * null and they will have no function; i.e. a null filter will let
     * everything through and a null sort will let things go in whatever
     * order.
     *
     * @param {Array|Object} in_thing - hash or array
     * @param {Function} filter_function - hash (function(key, val)) or array (function(item, i)); this function must return boolean true or false.
     * @param {Function} sort_function - function to apply to elements: function(a, b); this function must return an integer as the usual sort functions do.
     * @returns {Array} array
     */
    pare: function(in_thing, filter_function, sort_function){

	var ret = [];
	
	// Probably an not array then.
	if( typeof(in_thing) === 'undefined' ){
	    // this is a nothing, to nothing....
	}else if( typeof(in_thing) != 'object' ){
	    throw new Error('Unsupported type in bbop.core.pare: ' +
			    typeof(in_thing) );
	}else if( us.isArray(in_thing) ){
	    // An array; filter it if filter_function is defined.
	    if( filter_function ){	
		each(in_thing, function(item, index){
		    if( filter_function(item, index) ){
			// filter out item if true
		    }else{
			ret.push(item);
		    }
		});
	    }else{
		each(in_thing, function(item, index){ ret.push(item); });
	    }
	}else if( us.isFunction(in_thing) ){
	    // Skip is function (which is also an object).
	}else if( us.isObject(in_thing) ){
	    // Probably a hash; filter it if filter_function is defined.
	    if( filter_function ){	
		each(in_thing, function(val, key){
		    if( filter_function(key, val) ){
			// Remove matches to the filter.
		    }else{
			ret.push(val);
		    }
		});
	    }else{
		each(in_thing, function(val, key){ ret.push(val); });
	    }
	}else{
	    // No idea what this is--skip.
	}

	// For both: sort if there is anything.
	if( ret.length > 0 && sort_function ){
	    ret.sort(sort_function);	    
	}

	return ret;
    },

    /**
     * Essentially add standard 'to string' interface to the string class
     * and as a stringifier interface to other classes. More meant for
     * output--think REPL. Only atoms, arrays, and objects with a
     * to_string function are handled.
     *
     * @see module:bbop-core.dump
     * @param {any} in_thing - something
     * @returns {string} string
     */
    to_string: function(in_thing){

	// First try interface, then the rest.
	if( in_thing &&
	    typeof(in_thing.to_string) !== 'undefined' &&
	    typeof(in_thing.to_string) == 'function' ){
		return in_thing.to_string();
	    }else{
		
		var what = _what_is(in_thing);
		if( what == 'number' ){
		    return in_thing.toString();
		}else if( what == 'string' ){
		    return in_thing;
		}else if( what == 'array' ){
		    return _dump(in_thing);
		    // }else if( what == 'object' ){
		    //     return bbop.core.dump(in_thing);
		    // }else{
		    //     return '[unsupported]';
		}else{
		    return in_thing;
		}
	    }
    },

    /**
     * Check to see if all top-level objects in a namespace supply an
     * "interface".
     * 
     * Mostly intended for use during unit testing.
     *
     * TODO: Unit test this to make sure it catches both prototype (okay I
     * think) and uninstantiated objects (harder/impossible?).
     *
     * @param {} iobj - the object/constructor in question
     * @param {} interface_list - the list of interfaces (as a strings) we're looking for
     * @returns {boolean} boolean
     */
    has_interface: function(iobj, interface_list){
	var retval = true;
	each(interface_list, function(iface){
	    //print('|' + typeof(in_key) + ' || ' + typeof(in_val));
	    //print('|' + in_key + ' || ' + in_val);
	    if( typeof(iobj[iface]) == 'undefined' &&
		typeof(iobj.prototype[iface]) == 'undefined' ){
		    retval = false;
		    throw new Error(_what_is(iobj) +
				    ' breaks interface ' + iface);
                }
	});
	return retval;
    },

    /**
     * Assemble an object into a GET-like query. You probably want to see
     * the tests to get an idea of what this is doing.
     * 
     * The last argument of double hashes gets quoted (Solr-esque),
     * otherwise not. It will try and avoid adding additional sets of
     * quotes to strings.
     *
     * This does nothing to make the produced "URL" in any way safe.
     * 
     * WARNING: Not a hugely clean function--there are a lot of special
     * cases and it could use a good (and safe) clean-up.
     * 
     * @param {} qargs - hash/object
     * @returns {string} string
     */
    get_assemble: function(qargs){

	var mbuff = [];
	for( var qname in qargs ){
	    var qval = qargs[qname];

	    // null is technically an object, but we don't want to render
	    // it.
	    if( qval != null ){
		if( typeof qval == 'string' || typeof qval == 'number' ){
		    // Is standard name/value pair.
		    var nano_buffer = [];
		    nano_buffer.push(qname);
		    nano_buffer.push('=');
		    nano_buffer.push(qval);
		    mbuff.push(nano_buffer.join(''));
		}else if( typeof qval == 'object' ){
		    if( typeof qval.length != 'undefined' ){
			// Is array (probably).
			// Iterate through and double on.
			for(var qval_i = 0; qval_i < qval.length ; qval_i++){
			    var nano_buff = [];
			    nano_buff.push(qname);
			    nano_buff.push('=');
			    nano_buff.push(qval[qval_i]);
			    mbuff.push(nano_buff.join(''));
			}
		    }else{
			// // TODO: The "and" case is pretty much like
			// // the array, the "or" case needs to be
			// // handled carefully. In both cases, care will
			// // be needed to show which filters are marked.
			// Is object (probably).
			// Special "Solr-esque" handling.
			for( var sub_name in qval ){
			    var sub_vals = qval[sub_name];
			    
			    // Since there might be an array down there,
			    // ensure that there is an iterate over it.
			    if( _what_is(sub_vals) != 'array' ){
				sub_vals = [sub_vals];
			    }
			    
			    each(sub_vals, function(sub_val){
				var nano_buff = [];
				nano_buff.push(qname);
				nano_buff.push('=');
				nano_buff.push(sub_name);
				nano_buff.push(':');
				if( typeof sub_val !== 'undefined' && sub_val ){
				    // Do not double quote strings.
				    // Also, do not requote if we already
				    // have parens in place--that
				    // indicates a complicated
				    // expression. See the unit tests.
				    var val_is_a = _what_is(sub_val);
				    if( val_is_a == 'string' &&
					sub_val.charAt(0) == '"' &&
					sub_val.charAt(sub_val.length -1) == '"' ){
					    nano_buff.push(sub_val);
					}else if( val_is_a == 'string' &&
						  sub_val.charAt(0) == '(' &&
						  sub_val.charAt(sub_val.length -1) == ')' ){
						      nano_buff.push(sub_val);
						  }else{
						      nano_buff.push('"' + sub_val + '"');
						  }
				}else{
				    nano_buff.push('""');
				}
				mbuff.push(nano_buff.join(''));
			    });
			}
		    }
		}else if( typeof qval == 'undefined' ){
		    // This happens in some cases where a key is tried, but no
		    // value is found--likely equivalent to q="", but we'll
		    // let it drop.
		    // var nano_buff = [];
		    // nano_buff.push(qname);
		    // nano_buff.push('=');
		    // mbuff.push(nano_buff.join(''));	    
		}else{
		    throw new Error("bbop.core.get_assemble: unknown type: " + 
				    typeof(qval));
		}
	    }
	}
	
	return mbuff.join('&');
    },

    /**
     * Random number generator of fixed length. Return a random number
     * string of length len.
     *
     * @param {} len - the number of random character to return.
     * @returns {string} string
     */
    randomness: function(len){

	var random_base = [
	    '1', '2', '3', '4', '5', '6', '7', '8', '9', '0',
	    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
	    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
	];
	var length = len || 10;
	var cache = new Array();
	for( var ii = 0; ii < length; ii++ ){
	    var rbase_index = Math.floor(Math.random() * random_base.length);
	    cache.push(random_base[rbase_index]);
	}
	return cache.join('');
    },

    /**
     * Return the parameters part of a URL.
     *
     * Unit tests make the edge cases clear.
     * 
     * @param {} url - url (or similar string)
     * @returns {Array} list of part lists
     */
    url_parameters: function(url){

	var retlist = [];

	// Pull parameters.
	var tmp = url.split('?');
	var path = '';
	var parms = [];
	if( ! tmp[1] ){ // catch bad url--nothing before '?'
	    parms = tmp[0].split('&');
	}else{ // normal structure
	    path = tmp[0];
	    parms = tmp[1].split('&');
	}

	// Decompose parameters.
	each(parms, function(p){
	    var c = _first_split('=', p);
	    if( ! c[0] && ! c[1] ){
		retlist.push([p]);
	    }else{
		retlist.push(c);		  
	    }
	});
	
	return retlist;
    },

    /**
     * Convert a string into something consistent for urls (getting icons,
     * etc.). Return a munged/hashed-down version of the resource.
     * Assembles, converts spaces to underscores, and all lowercases.
     * 
     * @param {} base - base url for the resource(s)
     * @param {} resource - the filename or whatever to be transformed
     * @param {} extension - *[optional]* the extension of the resource
     * @returns {string} string
     */
    resourcify: function(base, resource, extension){

	var retval = base + '/' + resource;

	// Add the extension if it is there.
	if( extension ){
	    retval += '.' + extension;	
	}

	// Spaces to underscores and all lowercase.
	//return retval.replace(/\ /g, "_", "g").toLowerCase();
	return retval.replace(/\ /g, "_").toLowerCase();
    },

    /**
     * RFC 4122 v4 compliant UUID generator.
     * From: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523
     *
     * @returns {string} string
     */
    uuid: function(){

	// Replace x (and y) in string.
	function replacer(c) {
	    var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
	    return v.toString(16);
	}
	var target_str = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';
	return target_str.replace(/[xy]/g, replacer);
    },

    /**
     * A sort function to put numbers in ascending order.
     * 
     * Useful as the argument to .sort().
     * 
     * See: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/sort
     * 
     * @param {number} a - the first number
     * @param {number} b - the second number
     * @returns {number} number of their relative worth
     */
    numeric_sort_ascending: function(a, b){
	return a - b;
    },

    /**
     * A sort function to put numbers in descending order.
     * 
     * Useful as the argument to .sort().
     * 
     * See: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/sort
     * 
     * @param {number} a - the first number
     * @param {number} b - the second number
     * @returns {number} number of their relative worth
     */
    numeric_sort_descending: function(a, b){
	return b - a;
    },

    /**
     * Remove the quotes from a string.
     * 
     * @param {string} str - the string to dequote
     * @returns {string} the dequoted string (or the original string)
     */
    dequote: function(str){
	var retstr = str;

	if( ! us.isUndefined(str) && str.length > 2 ){
	    var end = str.length -1;
	    if( str.charAt(0) == '"' && str.charAt(end) == '"' ){
		retstr = str.substr(1, end -1);
	    }
	}

	return retstr;
    },

    /**
     * Make sure that a substring exists at the beginning or end (or both)
     * of a string.
     * 
     * @param {} str - the string to ensure that has the property
     * @param {} add - the string to check for (and possibly add)
     * @param {} place - *[optional]* "front"|"back", place to ensure (defaults to both)
     * @returns {string} a new string with the property enforced
     */
    ensure: function(str, add, place){

	// 
	var do_front = false;
	var do_back = false;
	if( us.isUndefined(place) ){
	    do_front = true;
	    do_back = true;
	}else if( place == 'front' ){
	    do_front = true;
	}else if( place == 'back' ){
	    do_back = true;
	}else{
	    // Don't know what it is, not doing anything.
	}

	//
	var strlen = str.length;
	var addlen = add.length;
	var front_substr = str.substr(0, addlen);
	var back_substr = str.substr((strlen - addlen), (strlen -1));

	//
	var front_add = '';
	if( do_front && front_substr != add ){
	    front_add = add;
	}
	var back_add = '';
	if( do_back && back_substr != add ){
	    back_add = add;
	}

	// console.log('do_front: ' + do_front);
	// console.log('do_back: ' + do_back);
	// console.log('str.length: ' + strlen);
	// console.log('add.length: ' + addlen);
	// console.log('front_substr: ' + front_substr);
	// console.log('back_substr: ' + back_substr);
	// console.log('front_add: ' + front_add);
	// console.log('back_add: ' + back_add);

	return front_add + str + back_add;
    },

    /**
     * Trim the leading and trailing whitespace from a string.
     * Named differently so as not to confuse with JS 1.8.1's trim().
     * 
     * @param {string} str - the string to ensure that has the property
     * @returns {string} the trimmed string
     */
    chomp: function(str){

	var retstr = '';

	retstr = str.replace(/^\s+/,'');
	retstr = retstr.replace(/\s+$/,'');

	return retstr;
    },

    /**
     * Break apart a string on certain delimiter.
     * 
     * @param {} str - the string to ensure that has the property
     * @param {} delimiter - *[optional]* either a string or a simple regexp; defaults to ws
     *
     * @returns {Array} a list of separated substrings
     */
    splode: function(str, delimiter){

	var retlist = null;

	if( ! us.isUndefined(str) ){
	    if( us.isUndefined(delimiter) ){
		delimiter = /\s+/;
	    }
	    
	    retlist = str.split(delimiter);
	}

	return retlist;
    },

    // // Giving up on this for now: the general case seems too hard to work with 
    // // in so many different, contradictory, and changing environments.
    // /**
    //  * Getting a cross-platform that can evaluate to the global namespace
    //  * seems a little bit problematic. This is an attempt to wrap that all
    //  * away.
    //  * 
    //  * This is not an easy problem--just within browsers there are a lot
    //  * of issues:
    //  * http://perfectionkills.com/global-eval-what-are-the-options/ After
    //  * that, the server side stuff tries various ways to keep you from
    //  * affecting the global namespace in certain circumstances.
    //  * 
    //  * @param {} to_eval - the string to evaluate
    //  * 
    //  * Returns:
    //  *  A list with the following fields: retval, retval_str, okay_p, env_type.
    //  */
    // evaluate: function(to_eval){

    //     var retval = null;
    //     var retval_str = '';
    //     var okay_p = true;
    //     var env_type = 'server';

    //     // Try and detect our environment.
    //     try{
    // 	if( bbop.core.is_defined(window) &&
    // 	    bbop.core.is_defined(window.eval) &&
    // 	    bbop.core.what_is(window.eval) == 'function' ){
    // 		env_type = 'browser';
    // 	    }
    //     } catch (x) {
    // 	// Probably not a browser then, right? Hopefully all the
    // 	// servers that we'll run into are the same (TODO: check
    // 	// nodejs).
    //     }
    //     print('et: ' + env_type);

    //     // Now try for the execution.
    //     try{
    // 	// Try and generically evaluate.
    // 	if( env_type == 'browser' ){
    // 	    print('eval as if (browser)');
    // 	    retval = window.eval(to_eval);
    // 	}else{
    // 	    // TODO: Does this work?
    // 	    print('eval as else (server)');
    // 	    //retval = this.eval(to_eval);		
    // 	    retval = bbop.core.global.eval(to_eval);
    // 	}
    //     }catch (x){
    // 	// Bad things happened.
    // 	print('fail on: (' + retval +'): ' + to_eval);
    // 	retval_str = '[n/a]';
    // 	okay_p = false;
    //     }
    
    //     // Make whatever the tmp_ret is prettier for the return string.
    //     if( bbop.core.is_defined(retval) ){
    // 	if( bbop.core.what_is(retval) == 'string' ){
    // 	    retval_str = '"' + retval + '"';
    // 	}else{
    // 	    retval_str = retval;
    // 	}
    //     }else{
    // 	// Return as-is.
    //     }

    //     return [retval, retval_str, okay_p, env_type];
    // };

    /**
     * What seems to be a typical idiom for subclassing in JavaScript.
     * 
     * This attempt has been scraped together from bits here and there and
     * lucid explanations from Mozilla:
     * 
     * https://developer.mozilla.org/en-US/docs/JavaScript/Introduction_to_Object-Oriented_JavaScript
     * https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Details_of_the_Object_Model
     * https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Inheritance_Revisited
     * https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/new
     * 
     * @param {} subclass - the subclass object
     * @param {} superclass - the superclass object
     */
    extend: function(subclass, baseclass){

	// Create a temporary nothing so that we don't fiddle the
	// baseclass's(?) with what we do to subclass later on.
	function tmp_object(){}

	// This nothings prototype gets the base class's.
	tmp_object.prototype = baseclass.prototype;

	// We instantiate the tmp_object, whose prototype is the
	// baseclass's; we make subclass's prototype this object, giving
	// us something that is very much like baseclass.
	subclass.prototype = new tmp_object; // same as: "new tmp_object();"

	// Now we go back and make the constructor of subclass actually
	// subclass again--we blew it away in the last step. Now we have a
	// subclass constructor with the protoype of baseclass.
	subclass.prototype.constructor = subclass;

	// // Create a property to allow access to the constructor of
	// // baseclass. This is useful when subclass needs access to
	// // baseclass's constructor for property setting.
	// subclass.base_constructor = baseclass;

	// // Create a property to
	// subclass.parent_class = baseclass.prototype;
    },

    /**
     * BBOP JS logger object. Using .kvetch(), you can automatically log a
     * message in almost any environment you find yourself in--browser,
     * server wherever. Also, if you have jQuery available and an element
     * with the id "bbop-logger-console-textarea",
     * "bbop-logger-console-text", or "bbop-logger-console-html", the
     * logger will append to that element (with a "\n" (autoscroll), "\n",
     * or "<br />" terminator respectively) instead.
     *
     * @constructor
     * @param {string} initial_context - (optional) initial context as string.
     */
    logger: function(initial_context){

	/**
	 * Different debugging available per object. Externally toggle
	 * between true and false to switch on and off the logging.
	 *
	 * @variable {boolean}
	 */
	this.DEBUG = false;

	var anchor = this;

	// Define an optional context to tag onto the front of messages.
	this._context = [];
	if( initial_context ){
	    this._context = [initial_context];
	}

	/**
	 * Define the ability to reset the contex.
	 * 
	 * @param {string} new_initial_context - (optional) new context to start with
	 */
	this.reset_context = function(new_initial_context){
	    if( new_initial_context ){
		this._context = [new_initial_context];
	    }else{
		this._context = [];	    
	    }
	};

	/**
	 * Add an additional logging context to the stack.
	 * 
	 * @param {string} new_context - New context to add to the context stack.
	 */
	this.push_context = function(new_context){
	    this._context.push(new_context);
	};

	/**
	 * Remove the last context if it's there.
	 */
	this.pop_context = function(){
	    var popped_context = null;
	    if( this._context.length > 0 ){
		popped_context = this._context.pop();
	    }
	    return popped_context;
	};

	// Generalizer console (or whatever) printing.
	this._console_sayer = function(){};

	if( typeof(jQuery) != 'undefined' && jQuery('#' + 'bbop-logger-console-html') != 'undefined' && jQuery('#' + 'bbop-logger-console-html').length ){
	    // Our own logging console takes precedence. 
	    this._console_sayer = function(msg){
		var area = jQuery('#'+ 'bbop-logger-console-html');
		area.append(msg + "<br />");
		try{
    		    area.scrollTop(area[0].scrollHeight);
		} catch (x) {
		    // could scroll
		}
		//jQuery('#'+'bbop-logger-console-html').append(msg + "<br />");
	    };
	}else if( typeof(console) != 'undefined' && typeof(console.log) == 'function' ){
	    // This may be okay for Chrome and a subset of various
	    // console loggers. This should now include FF's Web
	    // Console and NodeJS.  this._console_sayer =
	    // function(msg){ console.log(msg + "\n"); }; These
	    // usually seem to have "\n" incorporated now.
	    this._console_sayer = function(msg){ console.log(msg); };
	}else if( typeof(opera) != 'undefined' && typeof(opera.postError) == 'function' ){
	    // If Opera is in there, probably Opera.
	    this._console_sayer = function(msg){ opera.postError(msg + "\n"); };
	}else if( typeof(window) != 'undefined' && typeof(window.dump) == 'function' ){
	    // From developer.mozilla.org: To see the dump output you
	    // have to enable it by setting the preference
	    // browser.dom.window.dump.enabled to true. You can set
	    // the preference in about:config or in a user.js
	    // file. Note: this preference is not listed in
	    // about:config by default, you may need to create it
	    // (right-click the content area -> New -> Boolean).
	    this._console_sayer = function(msg){ dump( msg + "\n"); };
	}else if( typeof(window) != 'undefined' && typeof(window.console) != 'undefined' && typeof(window.console.log) == 'function' ){
	    // From developer.apple.com: Safari's "Debug" menu allows
	    // you to turn on the logging of JavaScript errors. To
	    // display the debug menu in Mac OS X, open a Terminal
	    // window and type: "defaults write com.apple.Safari
	    // IncludeDebugMenu 1" Need the wrapper function because
	    // safari has personality problems.
	    this._console_sayer = function(msg){ window.console.log(msg + "\n"); };
	}else if( typeof(build) == 'function' && typeof(getpda) == 'function' && typeof(pc2line) == 'function' && typeof(print) == 'function' ){
	    // This may detect SpiderMonkey on the comand line.
	    this._console_sayer = function(msg){ print(msg); };
	}else if( typeof(org) != 'undefined' && typeof(org.rhino) != 'undefined' && typeof(print) == 'function' ){
	    // This may detect Rhino on the comand line.
	    this._console_sayer = function(msg){ print(msg); };
	}
	
	/**
	 * Log a string to somewhere. Also return a string to (mostly for
	 * the unit tests).
	 * 
	 * @param {string} initial_context - (optional) initial context as string
	 * @returns {string} string to print out to wherever we found
	 */
	this.kvetch = function(string){
	    var ret_str = null;
	    if( anchor.DEBUG == true ){

		// Make sure there is something there no matter what.
		if( typeof(string) == 'undefined' ){ string = ''; }

		// Redefined the string a little if we have contexts.
		if( anchor._context.length > 0 ){
		    var cstr = anchor._context.join(':');
		    string = cstr + ': '+ string;
		}

		// Actually log to the console.
		anchor._console_sayer(string);

		// Bind for output.
		ret_str = string;
	    }
	    return ret_str;
	};
    }

};

},{"underscore":11}],11:[function(require,module,exports){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result  either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],12:[function(require,module,exports){
(function (global){(function (){
/*
 * Package: autocomplete_simple.js
 * 
 * Namespace: bbop.widget.autocomplete_simple
 * 
 * BBOP object to draw various UI elements that have to do with
 * autocompletion.
 * 
 * This is a completely self-contained UI and manager.
 */

var us = require('underscore');
var bbop = require('bbop-core');
var bbop_response_golr = require('bbop-response-golr');
var mustache = require('mustache');

/* jshint ignore:start */
var jQuery = typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null;
//require('jquery-ui');
/* jshint ignore:end */

/*
 * Constructor: autocomplete_simple
 * 
 * Contructor for the bbop-widget-set.autocomplete_simple object.
 * 
 * This is a specialized (and widgetized) subclass of
 * <bbop-manager-golr.jquery>.
 * 
 * The function for the callback argument should either accept a
 * JSONized solr document representing the selected item or null
 * (nothing found).
 * 
 * While everything in the argument hash is technically optional,
 * there are probably some fields that you'll want to fill out to make
 * things work decently. The options for the argument hash are:
 * 
 *  fill_p - whether or not to fill the input with the val on select (default true)
 *  label_template - string template for dropdown, can use any document field
 *  value_template - string template for selected, can use any document field
 *  additional_results_class - class to add to the pop-up autocomplete ul tag when there are more results than are shown in the results
 *  minimum_length - wait for this many characters to start (default 3)
 *  list_select_callback - function takes a json solr doc on dropdown selection
 * 
 * To get a better idea on how to use the templates, see the demo page
 * at http://cdn.berkeleybop.org/jsapi/bbop-js/demo/index.html and
 * read the documentation for <bbop.template>.
 * 
 * Arguments:
 *  manager - a <bbop-manager-golr>; needs to be using the jQuery engine
 *  golr_loc - string url to GOlr server;
 *  golr_conf_obj - a <golr-conf> object
 *  interface_id - string id of the element to build on
 *  in_argument_hash - *[optional]* optional hash of optional arguments
 * 
 * Returns:
 *  this object
 */
var autocomplete_simple = function autocomplete_simple(manager, golr_loc, golr_conf_obj, interface_id, in_argument_hash) {
  this._is_a = 'bbop-widget-set.autocomplete_simple';
  var anchor = this;

  // Per-UI logger.
  var logger = new bbop.logger();
  logger.DEBUG = true;
  function ll(str) {
    logger.kvetch('W (auto): ' + str);
  }

  // Our argument default hash.
  var default_hash = {
    'fill_p': true,
    'label_template': '{{id}}',
    'value_template': '{{id}}',
    'additional_results_class': '',
    'minimum_length': 3,
    // wait for three characters or more
    'list_select_callback': function list_select_callback() {}
  };
  var folding_hash = in_argument_hash || {};
  var arg_hash = bbop.fold(default_hash, folding_hash);

  // There should be a string interface_id argument.
  this._interface_id = interface_id;
  this._fill_p = arg_hash['fill_p'];
  this._list_select_callback = arg_hash['list_select_callback'];
  var label_tt = arg_hash['label_template'];
  var value_tt = arg_hash['value_template'];
  var ar_class = arg_hash['additional_results_class'];
  var minlen = arg_hash['minimum_length'];
  // The document  return counts. Need  tri-state here since 0  is a
  // legit return.
  var result_count = null;
  var return_count = null;

  // The all-important argument hash. See:
  // http://jqueryui.com/demos/autocomplete/#method-widget
  var auto_args = {
    minLength: minlen,
    // Function for a successful data hit.
    // The data getter, which is making it all more complicated
    // than it needs to be...we need to close around those
    // callback hooks so we have to do it inplace here.
    source: function source(request_data, response_hook) {
      // Remove any previous registries and reregister the
      // function with the new capture.
      var fun_id = 'foo';
      manager.unregister('search', fun_id);
      manager.register('search', function (resp) {
        var retlist = [];

        // Reset the last return; remember: tri-state.
        result_count = null;
        return_count = null;
        if (resp.success()) {
          // Get best shot at document counts.
          result_count = resp.total_documents();
          return_count = resp.documents().length;
          us.each(resp.documents(), function (doc) {
            // First, try and pull what we can out of our
            var lbl = mustache.render(label_tt, doc);

            // Now the same thing for the return/value.
            var val = mustache.render(value_tt, doc);

            // Add the discovered items to the return
            // save.
            var item = {
              'label': lbl,
              'value': val,
              'document': doc
            };
            retlist.push(item);
          });
        }
        //console.log(retlist);
        response_hook(retlist);
      }, 0, fun_id);

      // Get the selected term into the manager and fire.
      //anchor.set_query(request_data.term);
      manager.set_comfy_query(request_data.term);
      manager.search();
    },
    // What to do when an element is selected.
    select: function select(event, ui) {
      // Prevent default selection input filling action (from
      // jQuery UI) when non-default marked.
      if (!anchor._fill_p) {
        event.preventDefault();
      }
      var doc_to_apply = null;
      if (ui.item) {
        doc_to_apply = ui.item.document;
      }

      // Only do the callback if it is defined.
      if (doc_to_apply && us.isFunction(anchor._list_select_callback)) {
        anchor._list_select_callback(doc_to_apply);
      }
    },
    // What to do when a search is completed.
    response: function response(event, ui) {
      // if(	result_count !== null && return_count !== null ){ // possible
      // 	if( result_count > return_count ){
      // 	    //console.log('incomplete listing');
      // 	    var item = {
      // 		'label': '...',
      // 		'value': null,
      // 		'document': null
      // 	    };
      // 	    ui.content.push(item);
      // 	}else{
      // 	    //console.log('complete listing');
      // 	}
      // }
    }
  };

  // Set the ball rolling (attach jQuery autocomplete to doc).
  var jac = jQuery('#' + anchor._interface_id).autocomplete(auto_args);

  // Add our render override.
  // Extension point to get the additional
  jac.data('ui-autocomplete')._renderMenu = function (ul, items) {
    // Allow standard menu construction delegation.
    var anchor = this;
    us.each(items, function (item) {
      anchor._renderItemData(ul, item);
    });

    // Add a special class to the UL if there are results that
    // are not shown.
    if (ar_class && ar_class !== '') {
      jQuery(ul).removeClass(ar_class); // default no
      if (result_count !== null && return_count !== null) {
        // possible
        console.log('res_c: ' + result_count);
        console.log('ret_c: ' + return_count);
        if (result_count > return_count) {
          // If 
          jQuery(ul).addClass(ar_class);
        }
      }
    }
  };

  /*
   * Function: destroy
   * 
   * Remove the autocomplete and functionality from the DOM.
   * 
   * Arguments:
   *  n/a
   * 
   * Returns:
   *  n/a
   */
  this.destroy = function () {
    jQuery('#' + anchor._interface_id).autocomplete('destroy');
  };

  /*
   * Function: content
   * 
   * Get the current text contents of the search box.
   * 
   * Arguments:
   *  n/a
   * 
   * Returns:
   *  string
   */
  this.content = function () {
    return jQuery('#' + anchor._interface_id).val();
  };
};

///
/// Exportable body.
///

module.exports = autocomplete_simple;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"bbop-core":26,"bbop-response-golr":32,"mustache":69,"underscore":108}],13:[function(require,module,exports){
/*
 * Package: browse.js
 * 
 * Namespace: bbop-widget-set.browse
 * 
 * BBOP object to draw various UI elements that have to do with
 * autocompletion.
 * 
 * This is a completely self-contained UI and manager.
 */

var us = require('underscore');
var bbop = require('bbop-core');
var html = require('./html');
var display = require('./display');
var generators = require('./generators');

// Graphs.
var model = require('bbop-graph');

// And some old bracket graph tooling.
var graph_tools = require('./graph_tools');

/*
 * Constructor: browse
 * 
 * Contructor for the bbop-widget-set.browse object.
 * 
 * This is a specialized (and widgetized) subclass of
 * <bbop.golr.manager.jquery>.
 * 
 * While everything in the argument hash is technically optional,
 * there are probably some fields that you'll want to fill out to make
 * things work decently. The options for the argument hash are:
 * 
 *  topology_graph_field -  the field for the topology graph
 *  transitivity_graph_field - the field for the transitivity graph
 *  info_button_callback - function to call when info clicked, gets term id
 *  base_icon_url - the url base that the fragments will be added to
 *  image_type - 'gif', 'png', etc.
 *  current_icon - the icon fragment for the current term
 *  info_icon - the icon fragment for the information icon
 *  info_alt - the alt text and title for the information icon
 * 
 * The basic formula for the icons is: base_icon_url + '/' + icon +
 * '.' + image_type; then all spaces are turned to underscores and all
 * uppercase letters are converted into lowercase letters.
 * 
 * The functions for the callbacks look like function(<term acc>,
 * <json data for the specific document>){}. If no function is given,
 * an empty function is used.
 * 
 * Arguments:
 *  manager - manager
 *  interface_id - string id of the element to build on
 *  in_argument_hash - *[optional]* optional hash of optional arguments
 * 
 * Returns:
 *  this object
 */
var browse = function browse(manager, interface_id, in_argument_hash) {
  var anchor = this;
  anchor._is_a = 'bbop-widget-set.browse';

  // Per-UI logger.
  var logger = new bbop.logger();
  logger.DEBUG = true;
  function ll(str) {
    logger.kvetch('browse: ' + str);
  }

  // Our argument default hash.
  var default_hash = {
    'topology_graph_field': 'topology_graph_json',
    'transitivity_graph_field': 'transitivity_graph_json',
    //'transitivity_graph_field' : 'regulates_transitivity_graph_json',
    'info_button_callback': function info_button_callback() {},
    'base_icon_url': null,
    'image_type': 'gif',
    'current_icon': 'this',
    'info_icon': 'info',
    'info_alt': 'Click for more information.'
  };
  var folding_hash = in_argument_hash || {};
  var arg_hash = bbop.fold(default_hash, folding_hash);

  // There should be a string interface_id argument.
  this._interface_id = interface_id;
  this._info_button_callback = arg_hash['info_button_callback'];
  var topo_graph_field = arg_hash['topology_graph_field'];
  var trans_graph_field = arg_hash['transitivity_graph_field'];
  var base_icon_url = arg_hash['base_icon_url'];
  var image_type = arg_hash['image_type'];
  var current_icon = arg_hash['current_icon'];
  var info_icon = arg_hash['info_icon'];
  var info_alt = arg_hash['info_alt'];

  // The current acc that we are interested in.
  this._current_acc = null;

  // Successful callbacks call draw_rich_layout.
  manager.register('search', draw_rich_layout);

  // Recursively draw a rich layout using nested uls.
  function draw_rich_layout(resp) {
    ///
    /// Get the rich layout from the returned document if
    /// possible. Note the use of JSON, supplied by jQuery,
    /// instead of out internal method bbop.json.parse.
    ///
    var doc = resp.documents()[0];
    if (!doc) {
      console.log('failure to get requested doc, resp: ', resp);
      return null;
    }
    var topo_graph = new model.graph();
    topo_graph.load_base_json(JSON.parse(doc[topo_graph_field]));
    var trans_graph = new model.graph();
    trans_graph.load_base_json(JSON.parse(doc[trans_graph_field]));

    //ll('to: ' + doc['topology_graph']);
    //ll('tr: ' + doc['transitivity_graph']);
    //ll('ro: ' + anchor._current_acc);
    //ll('g: ' + topo_graph.get_parent_nodes(anchor._current_acc));
    var rich_layout = graph_tools.rich_bracket_layout(topo_graph, trans_graph, anchor._current_acc);
    //ll("rl: " + bbop.dump(rich_layout));

    ///
    /// Next, produce the raw HTML skeleton.
    /// TODO: Keep a cache of the interesting ids for adding
    /// events later.
    ///

    // I guess we'll just start by making the list.
    var tl_attrs = {
      'class': 'bbop-js-ui-browse'
    };
    var top_level = new html.list([], tl_attrs);

    // Store the navigation anf info buttons.
    var nav_button_hash = {};
    var info_button_hash = {};

    // Cycle down through the brackets, adding spaces every time
    // we go down another level.
    var spacing = '&nbsp;&nbsp;&nbsp;&nbsp;';
    var spaces = spacing;
    us.each(rich_layout, function (layout_level) {
      // every level
      us.each(layout_level, function (level_item) {
        // every item at level

        var nid = level_item[0];
        var lbl = level_item[1];
        var rel = level_item[2];

        // For various sections, decide to run image
        // (img) or text code depending on whether
        // or not it looks like we have a real URL.
        var use_img_p = true;
        if (base_icon_url === null || base_icon_url === '') {
          use_img_p = false;
        }

        // Clickable acc span.
        // No images, so the same either way. Ignore
        // it if we're current.
        var nav_b = null;
        if (anchor._current_acc === nid) {
          var inact_attrs = {
            'class': 'bbop-js-text-button-sim-inactive',
            'title': 'Current term.'
          };
          nav_b = new html.span(nid, inact_attrs);
        } else {
          var tbs = generators.text_button_sim;
          var bttn_title = 'Reorient neighborhood onto this node (' + nid + ').';
          nav_b = new tbs(nid, bttn_title);
          nav_button_hash[nav_b.get_id()] = nid;
        }

        // Clickable info span. A little difference
        // if we have images.
        var info_b = null;
        if (use_img_p) {
          // Do the icon version.
          var imgsrc = bbop.resourcify(base_icon_url, info_icon, image_type);
          info_b = new html.image({
            'alt': info_alt,
            'title': info_alt,
            'src': imgsrc,
            'generate_id': true
          });
        } else {
          // Do a text-only version.
          info_b = new html.span('<b>[i]</b>', {
            'generate_id': true
          });
        }
        info_button_hash[info_b.get_id()] = nid;

        // "Icon". If base_icon_url is defined as
        // something try for images, otherwise fall
        // back to this text ick.
        var icon = null;
        if (use_img_p) {
          // Do the icon version.
          var ialt = '[' + rel + ']';
          var isrc = null;
          if (anchor._current_acc === nid) {
            isrc = bbop.resourcify(base_icon_url, current_icon, image_type);
          } else {
            isrc = bbop.resourcify(base_icon_url, rel, image_type);
          }
          icon = new html.image({
            'alt': ialt,
            'title': rel,
            'src': isrc,
            'generate_id': true
          });
        } else {
          // Do a text-only version.
          if (anchor._current_acc === nid) {
            icon = '[[->]]';
          } else if (rel && rel.length && rel.length > 0) {
            icon = '[' + rel + ']';
          } else {
            icon = '[???]';
          }
        }

        // Stack the info, with the additional
        // spaces, into the div.
        top_level.add_to(spaces, icon, nav_b.to_string(), lbl, info_b.to_string());
      });
      spaces = spaces + spacing;
    });

    // Add the skeleton to the doc.
    jQuery('#' + anchor._interface_id).empty();
    jQuery('#' + anchor._interface_id).append(top_level.to_string());

    ///
    /// Finally, attach any events to the browser HTML doc.
    ///

    // Navigation.
    us.each(nav_button_hash, function (node_id, button_id) {
      jQuery('#' + button_id).click(function () {
        var tid = jQuery(this).attr('id');
        var call_time_node_id = nav_button_hash[tid];
        //alert(call_time_node_id);
        anchor.draw_browser(call_time_node_id);
      });
    });

    // Information.
    us.each(info_button_hash, function (node_id, button_id) {
      jQuery('#' + button_id).click(function () {
        var tid = jQuery(this).attr('id');
        var call_time_node_id = info_button_hash[tid];
        anchor._info_button_callback(call_time_node_id);
      });
    });
  }

  /*
   * Function: draw_browser
   * 
   * Bootstraps the process.
   * 
   * Parameters:
   *  term_acc - acc of term we want to have as the term of interest
   * 
   * Returns
   *  n/a
   */
  //bbop-widget-set.browse.prototype.draw_browser = function(term_acc){
  // this._current_acc = term_acc;
  // this.set_id(term_acc);
  // this.update('search');
  this.draw_browser = function (term_acc) {
    anchor._current_acc = term_acc;
    manager.set_id(term_acc);
    manager.update('search');
  };
};

///
/// Exportable body.
///

module.exports = browse;

},{"./display":14,"./generators":15,"./graph_tools":16,"./html":17,"bbop-core":26,"bbop-graph":27,"underscore":108}],14:[function(require,module,exports){
(function (global){(function (){
var us = require('underscore');
var bbop = require('bbop-core');

// Code here will be ignored by JSHint, as we are technically
// "redefining" jQuery (although we are not).
/* jshint ignore:start */
var jQuery = typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null;
//require('jquery-ui');
/* jshint ignore:end */

var html = require('./html');
var generators = require('./generators');

/*
 * Package: spinner.js
 * 
 * Namespace: bbop-widget-set.spinner
 * 
 * BBOP object to produce a self-constructing/self-destructing
 * spinner. It can display various spinner/throbber images and can
 * have a set timeout to deal with annoying servers and exotic race
 * conditions.
 * 
 * The class of the spinner image is "bbop-widget-spinner".
 * 
 * Visibility is controlled by the application and removal of
 * "bbop-js-spinner-hidden".
 * 
 * This is a completely self-contained UI.
 */

/*
 * Constructor: spinner
 * 
 * Contructor for the bbop-widget-set.spinner object.
 * 
 * A trivial invocation might be something like:
 * : var s = new bbop-widget-set.spinner("inf01", "http://localhost/amigo2/images/waiting_ajax.gif");
 * : s.hide();
 * : s.show();
 * 
 * Or, in a slightly different use case:
 * 
 * : var s = new bbop-widget-set.spinner("inf01", "http://localhost/amigo2/images/waiting_ajax.gif", {'timout': 5});
 * : s.start_wait();
 * 
 * The optional hash arguments look like:
 *  timeout - the number of seconds to wait before invoking <clear_waits>; 0 indicates waiting forever; defaults to 5
 *  visible_p - whether or not the spinner is visible on initialization; true|false; defaults to true
 *  classes - a string of space-separated classes that you want added to the spinner image
 * 
 * Arguments:
 *  host_elt_id - string id of the place to place the widget
 *  img_src - the URL for the image to use in the spinner
 *  argument_hash - *[optional]* optional hash of optional arguments
 * 
 * Returns:
 *  self
 */
var spinner = function spinner(host_elt_id, img_src, argument_hash) {
  this._is_a = 'bbop-widget-set.spinner';
  var anchor = this;

  // Per-UI logger.
  var logger = new bbop.logger();
  logger.DEBUG = false;
  //logger.DEBUG = true;
  function ll(str) {
    logger.kvetch('W (spinner): ' + str);
  }

  // Our argument default hash.
  var default_hash = {
    'timeout': 5,
    'visible_p': true,
    'classes': ''
  };
  var folding_hash = argument_hash || {};
  var arg_hash = bbop.fold(default_hash, folding_hash);

  // Spin out arguments.
  var timeout = arg_hash['timeout'];
  var visible_p = arg_hash['visible_p'];
  var classes = arg_hash['classes'];

  ///
  /// Part 1: Append the image into the given element id.
  ///

  // Use the incoming arguments to help determine the default
  // classes on the element.'
  var spinner_classes = ['bbop-js-spinner'];
  if (!visible_p) {
    spinner_classes.push('bbop-js-spinner-hidden');
  }
  if (classes && classes !== '') {
    spinner_classes.push(classes);
  }

  // Create new element.
  var spinner_elt = new html.image({
    'generate_id': true,
    'src': img_src,
    'title': "Please wait...",
    'class': spinner_classes.join(' '),
    'alt': "(waiting...)"
  });
  var spinner_elt_id = spinner_elt.get_id();

  // Append img to end of given element.
  jQuery('#' + host_elt_id).append(spinner_elt.to_string());

  ///
  /// Part 2: Dynamic display management.
  ///

  // Counts and accounting.
  var current_waits = 0;
  var timeout_queue = [];

  /*
   * Function: show
   * 
   * Show the spinner if it is hidden (regardless of current waits).
   * 
   * Parameters:
   *  n/a
   * 
   * Returns
   *  n/a
   */
  this.show = function () {
    ll("show");
    jQuery('#' + spinner_elt_id).removeClass('bbop-js-spinner-hidden');

    // If the timeout is defined, push a timer onto
    // the queue.
    function _on_timeout() {
      anchor.finish_wait();
    }
    if (timeout > 0) {
      setTimeout(_on_timeout, timeout * 1000);
    }
    // foo=setTimeout(function(){}, 1000);
    // clearTimeout(foo);
  };

  /*
   * Function: hide
   * 
   * Hide the spinner if it is showing (regardless of current waits).
   * 
   * Parameters:
   *  n/a
   * 
   * Returns
   *  n/a
   */
  this.hide = function () {
    ll("hide");
    jQuery('#' + spinner_elt_id).addClass('bbop-js-spinner-hidden');
  };

  /*
   * Function: start_wait
   * 
   * Displays the initial spinner if it is not already displayed and
   * adds one to the wait count.
   * 
   * Parameters:
   *  n/a
   * 
   * Returns
   *  n/a
   */
  this.start_wait = function () {
    ll("Start outstanding waits: " + current_waits);

    // 
    if (current_waits === 0) {
      anchor.show();
    }
    current_waits++;
  };

  /*
   * Function: finish_wait
   * 
   * Removes one from the wait count and hides the spinner if the
   * number of outstanding waits has reached zero.
   * 
   * Parameters:
   *  n/a
   * 
   * Returns
   *  n/a
   */
  this.finish_wait = function () {
    ll("Finish outstanding waits: " + current_waits);

    // Stay at least at 0--we might have stragglers or incoming
    // after a reset.
    if (current_waits > 0) {
      current_waits--;
    }

    // Gone if we are not waiting for anything.
    if (current_waits === 0) {
      anchor.hide();
    }
  };

  /*
   * Function: clear_waits
   * 
   * Hides the spinner and resets all the waiting counters. Can be
   * used during things like server errors or collisions.
   * 
   * Parameters:
   *  n/a
   * 
   * Returns
   *  n/a
   */
  this.clear_waits = function () {
    current_waits = 0;
    anchor.hide();
  };
};

/*
 * Package: filter_table.js
 * 
 * Namespace: bbop-widget-set.filter_table
 * 
 * Create a dynamic filter for removing rows from a table (where the
 * rows are inside of a tbody).
 * 
 * The repaint_func argument takes the table id as its argument. If a
 * function is not specified, the default function will do nothing.
 */

// YANKED: ...apply the classes "even_row" and "odd_row" to the table.

/*
 * Method: filter_table
 * 
 * The table needs to keep the row information in a tbody, not just at
 * the top level.
 * 
 * Arguments:
 *  elt_id - the element to inject the filter into
 *  table_id - the table that we will operate on
 *  img_src - *[optional]* img source URL for the spinner image (defaults to no spinner)
 *  repaint_func - the repaint function to run after filtering (see above)
 *  label - *[optional]* the label to use for the filter
 * 
 * Returns:
 *  n/a
 */
var filter_table = function filter_table(elt_id, table_id, img_src, repaint_func, label) {
  this._is_a = 'bbop-widget-set.filter_table';
  var anchor = this;
  var logger = new bbop.logger();
  //logger.DEBUG = true;
  logger.DEBUG = false;
  function ll(str) {
    logger.kvetch(str);
  }
  ll('init filter_table in ' + elt_id + ' for ' + table_id);

  // Sort out spinner image source.
  anchor.img_src = null;
  if (img_src) {
    anchor.img_src = img_src;
  }

  // Sort out repaint function.
  anchor.repaint_func = function (tid) {};
  // function (tid){
  //     jQuery('table#' + tid + ' tr:even').attr('class', 'even_row');
  //     jQuery('table#' + tid + ' tr:odd').attr('class', 'odd_row');
  // };
  if (repaint_func) {
    anchor.repaint_func = repaint_func;
  }

  // Sort out label.
  anchor.label = 'Filter:';
  if (label) {
    anchor.label = label;
  }
  ll('finished args');

  // Create a label, input field, and a clear button.
  var input_attrs = {
    'type': 'text',
    'class': 'form-control bbop-js-filter-table-input',
    'value': '',
    'generate_id': true
  };
  var input = new html.input(input_attrs);
  var lbl_attrs = {
    'for': input.get_id(),
    'generate_id': true
  };
  var lbl = new html.tag('label', lbl_attrs, anchor.label);
  var clear_button_attrs = {
    'type': 'button',
    'class': 'btn btn-danger',
    'title': 'Clear filter',
    'generate_id': true
  };
  var clear_button =
  //new bbop-widget-set.display.text_button_sim('&times;', 'Clear filter');
  new html.button('&times;', clear_button_attrs);
  var cont_attrs = {
    'class': 'form-inline'
  };
  var cont = new html.tag('div', cont_attrs, [lbl, input, clear_button]);
  ll('widget gen done');

  // And add them to the DOM at the location.
  jQuery('#' + elt_id).empty();
  jQuery('#' + elt_id).append(cont.to_string());

  // Also, attach a spinner.
  var spin = null;
  if (anchor.img_src) {
    jQuery('#' + elt_id).append('&nbsp;&nbsp;');
    spin = new spinner(elt_id, anchor.img_src, {
      visible_p: false
    });
  }
  ll('widget addition done');

  // Make the clear button active.
  jQuery('#' + clear_button.get_id()).click(function () {
    ll('click call');
    if (spin) {
      spin.show();
    }
    jQuery('#' + input.get_id()).val('');
    trs.show();
    // Recolor after filtering.
    anchor.repaint_func(table_id);
    if (spin) {
      spin.hide();
    }
  });

  // Cache information about the table.
  var trs = jQuery('#' + table_id + ' tbody > tr');
  var tds = trs.children();

  // Make the table filter active.
  jQuery('#' + input.get_id()).keyup(function () {
    if (spin) {
      spin.show();
    }
    var stext = jQuery(this).val();
    ll('keyup call: (' + stext + '), ' + trs);
    if (!bbop.is_defined(stext) || stext === "") {
      // Restore when nothing found.
      trs.show();
    } else {
      // Want this to be insensitive.
      stext = stext.toLowerCase();

      // All rows (the whole table) gets hidden.
      trs.hide();

      // jQuery filter to match element contents against
      // stext.
      var _match_filter = function _match_filter() {
        var retval = false;
        var lc = jQuery(this).text().toLowerCase();
        if (lc.indexOf(stext) >= 0) {
          retval = true;
        }
        return retval;
      };

      // If a td has a match, the parent (tr) gets shown.
      // Or: show only matching rows.
      tds.filter(_match_filter).parent("tr").show();
    }

    // Recolor after filtering.
    anchor.repaint_func(table_id);
    if (spin) {
      spin.hide();
    }
  });
};

/*
 * Function: results_table_by_class_conf
 *
 * Using a conf class and a set of data, automatically populate and
 * return a results table.
 *  
 * This is the Bootstrap 3 version of this display. It affixes itself
 * directly to the DOM using jQuery at elt_id.
 *  
 * Parameters:
 *  class_conf - a <bbop.golr.conf_class>
 *  golr_resp - a <bbop.golr.response>
 *  linker - a linker object; see <amigo.linker> for more details
 *  handler - a handler object; see <amigo.handler> for more details
 *  elt_id - the element id to attach it to
 *  selectable_p - *[optional]* whether to create checkboxes (default true)
 *
 * Returns:
 *  this object
 *
 * See Also:
 *  <bbop-widget-set.display.results_table_by_class>
 */
var results_table_by_class_conf = function results_table_by_class_conf(cclass, golr_resp, linker, handler, elt_id, selectable_p, select_toggle_id, select_item_name) {
  //
  var anchor = this;

  // Temp logger.
  var logger = new bbop.logger();
  //logger.DEBUG = true;
  logger.DEBUG = false;
  function ll(str) {
    logger.kvetch('RTBCCBS3: ' + str);
  }

  // Tie important things down for cell rendering prototype.
  anchor._golr_response = golr_resp;
  anchor._linker = linker;
  anchor._handler = handler;

  // The context we'll deliver to
  var display_context = 'bbop-widget-set.live_results';

  // Only want to compile once.
  var ea_regexp = new RegExp("\<\/a\>", "i"); // detect an <a>
  var br_regexp = new RegExp("\<br\ \/\>", "i"); // detect a <br />

  // // Sort out whether we want to display checkboxes. Also, give life
  // // to the necessary variables if they will be called upon.
  // var select_toggle_id = null;
  // var select_item_name = null;
  // if( is_defined(selectable_p) && selectable_p == true ){

  // }

  // Now take what we have, and wrap around some expansion code
  // if it looks like it is too long.
  var trim_hash = {};
  var trimit = 100;
  function _trim_and_store(in_str) {
    var retval = in_str;

    //ll("T&S: " + in_str);

    // Skip if it is too short.
    //if( ! ea_regexp.test(retval) && retval.length > (trimit + 50) ){
    if (retval.length > trimit + 50) {
      //ll("T&S: too long: " + retval);

      // Let there be tests.
      var list_p = br_regexp.test(retval);
      var anchors_p = ea_regexp.test(retval);
      var tease = null;
      if (!anchors_p && !list_p) {
        // A normal string then...trim it!
        //ll("\tT&S: easy normal text, go nuts!");
        tease = new html.span(bbop.crop(retval, trimit, ''), {
          'generate_id': true
        });
      } else if (anchors_p && !list_p) {
        // It looks like it is a link without a break, so not
        // a list. We cannot trim this safely.
        //ll("\tT&S: single link so cannot work on!");
      } else {
        //ll("\tT&S: we have a list to deal with");

        var new_str_list = retval.split(br_regexp);
        if (new_str_list.length <= 3) {
          // Let's just ignore lists that are only three
          // items.
          //ll("\tT&S: pass thru list length <= 3");
        } else {
          //ll("\tT&S: contruct into 2 plus tag");
          var new_str = '';
          new_str = new_str + new_str_list.shift();
          new_str = new_str + '<br />';
          new_str = new_str + new_str_list.shift();
          tease = new html.span(new_str, {
            'generate_id': true
          });
        }
      }

      // If we have a tease, assemble the rest of the packet
      // to create the UI.
      if (tease) {
        // Setup the text for tease and full versions.
        var bgen = function bgen(lbl, dsc) {
          var b = new html.button(lbl, {
            'generate_id': true,
            'type': 'button',
            'title': dsc || lbl,
            //'class': 'btn btn-default btn-xs'
            'class': 'btn btn-primary btn-xs'
          });
          return b;
        };
        var more_b = new bgen('more...', 'Display the complete list');
        var full = new html.span(retval, {
          'generate_id': true
        });
        var less_b = new bgen('less', 'Display the truncated list');

        // Store the different parts for later activation.
        var tease_id = tease.get_id();
        var more_b_id = more_b.get_id();
        var full_id = full.get_id();
        var less_b_id = less_b.get_id();
        trim_hash[tease_id] = [tease_id, more_b_id, full_id, less_b_id];

        // New final string.
        retval = tease.to_string() + " " + more_b.to_string() + " " + full.to_string() + " " + less_b.to_string();
      }
    }
    return retval;
  }

  // Create a locally mangled checkbox.
  function _create_select_box(val, id, name) {
    if (!bbop.is_defined(name)) {
      name = select_item_name;
    }
    var input_attrs = {
      'value': val,
      'name': name,
      'type': 'checkbox'
    };
    if (bbop.is_defined(id)) {
      input_attrs['id'] = id;
    }
    var input = new html.input(input_attrs);
    return input;
  }

  ///
  /// Render the headers.
  ///

  // Start with score, and add the others by order of the class
  // results_weights field.
  // var headers = ['score'];
  // var headers_display = ['Score'];
  var headers = [];
  var headers_display = [];
  if (selectable_p) {
    // Hint for later.
    headers.push(select_toggle_id);

    // Header select for selecting all.
    var hinp = _create_select_box('', select_toggle_id, '');
    //headers_display.push('All ' + hinp.to_string());
    headers_display.push(hinp.to_string());
  }
  var results_order = cclass.field_order_by_weight('result');
  us.each(results_order, function (fid) {
    // Store the raw headers/fid for future use.
    headers.push(fid);
    // Get the headers into a presentable state.
    var field = cclass.get_field(fid);
    if (!field) {
      throw new Error('conf error: not found:' + fid);
    }
    //headers_display.push(field.display_name());
    var fdname = field.display_name();
    var fdesc = field.description() || '???';
    var head_span_attrs = {
      // TODO/NOTE: to make the tooltip work properly, since the
      // table headers are being created each time,
      // the tooltop initiator would have to be called after
      // each pass...I don't know that I want to do that.
      //'class': 'bbop-js-ui-hoverable bbop-js-ui-tooltip',
      'class': 'bbop-js-ui-hoverable',
      'title': fdesc
    };
    // More aggressive link version.
    //var head_span = new html.anchor(fdname, head_span_attrs);
    var head_span = new html.span(fdname, head_span_attrs);
    headers_display.push(head_span.to_string());
  });

  ///
  /// Render the documents.
  ///

  // Cycle through and render each document.
  // For each doc, deal with it as best we can using a little
  // probing. Score is a special case as it is not an explicit
  // field.
  var table_buff = [];
  var docs = golr_resp.documents();
  us.each(docs, function (doc) {
    // Well, they had better be in here, so we're just gunna cycle
    // through all the headers/fids.
    var entry_buff = [];
    us.each(headers, function (fid) {
      // Detect out use of the special selectable column and add
      // a special checkbox there.
      if (fid === select_toggle_id) {
        // Also
        var did = doc['id'];
        var dinp = _create_select_box(did);
        entry_buff.push(dinp.to_string());
      } else if (fid === 'score') {
        // Remember: score is also
        // special--non-explicit--case.
        var score = doc['score'] || 0.0;
        score = bbop.to_string(100.0 * score);
        entry_buff.push(bbop.crop(score, 4) + '%');
      } else {
        // Not "score", so let's figure out what we can
        // automatically.
        var field = cclass.get_field(fid);

        // Make sure that something is there and that we can
        // iterate over whatever it is.
        var bits = [];
        if (doc[fid]) {
          if (field.is_multi()) {
            //ll("Is multi: " + fid);
            bits = doc[fid];
          } else {
            //ll("Is single: " + fid);
            bits = [doc[fid]];
          }
        }

        // Render each of the bits.
        var tmp_buff = [];
        us.each(bits, function (bit) {
          var out = anchor.process_entry(bit, fid, doc, display_context);
          tmp_buff.push(out);
        });
        // Join it, trim/store it, push to to output.
        var joined = tmp_buff.join('<br />');
        entry_buff.push(_trim_and_store(joined));
      }
    });
    table_buff.push(entry_buff);
  });

  // Add the table to the DOM.
  var final_table = new html.table(headers_display, table_buff, {
    'class': 'table table-striped table-hover table-condensed'
  });
  // new html.table(headers_display, table_buff,
  // 		    {'class': 'bbop-js-search-pane-results-table'});
  jQuery('#' + elt_id).append(bbop.to_string(final_table));

  // Add the roll-up/down events to the doc.
  us.each(trim_hash, function (val, key) {
    var tease_id = val[0];
    var more_b_id = val[1];
    var full_id = val[2];
    var less_b_id = val[3];

    // Initial state.
    jQuery('#' + full_id).hide();
    jQuery('#' + less_b_id).hide();

    // Click actions to go back and forth.
    jQuery('#' + more_b_id).click(function () {
      jQuery('#' + tease_id).hide();
      jQuery('#' + more_b_id).hide();
      jQuery('#' + full_id).show('fast');
      jQuery('#' + less_b_id).show('fast');
    });
    jQuery('#' + less_b_id).click(function () {
      jQuery('#' + full_id).hide();
      jQuery('#' + less_b_id).hide();
      jQuery('#' + tease_id).show('fast');
      jQuery('#' + more_b_id).show('fast');
    });
  });

  // Since we already added to the DOM in the table, now add the
  // group toggle if the optional checkboxes are defined.
  if (select_toggle_id && select_item_name) {
    jQuery('#' + select_toggle_id).click(function () {
      var cstr = 'input[id=' + select_toggle_id + ']';
      var nstr = 'input[name=' + select_item_name + ']';
      if (jQuery(cstr).prop('checked')) {
        jQuery(nstr).prop('checked', true);
      } else {
        jQuery(nstr).prop('checked', false);
      }
    });
  }
};

/*
 * Function: process_entry
 *
 * The function used to render a single entry in a cell in the results
 * table. It can be overridden to specify special behaviour. There may
 * be multiple entries within a cell, but they will all have this
 * function individually run over them.
 *
 * This function can access this._golr_response (a
 * <bbop.golr.response>), this._linker (a <bbop.linker>), and
 * this._handler (a <bbop.handler>).
 *
 * Arguments:
 *  bit - string (?) for the one entry in the cell
 *  field_id - string for the field under consideration
 *  document - the single document for this item from the solr response
 *
 * Returns:
 *  string or empty string ('')
 */
results_table_by_class_conf.prototype.process_entry = function (bit, field_id, document, display_context) {
  var anchor = this;

  // First, allow the hanndler to take a whack at it. Forgive
  // the local return. The major difference that we'll have here
  // is between standard fields and special handler fields. If
  // the handler resolves to null, fall back onto standard.
  //console.log('! B:' + bit + ', F:' + field_id + ', D:' + display_context);
  var out = anchor._handler.dispatch(bit, field_id, display_context);
  if (typeof out !== 'undefined' && out != null) {
    return out;
  }

  // Otherwise, use the rest of the context to try and render
  // the item.
  var retval = '';
  var did = document['id'];

  // BUG/TODO: First see if the filed will be multi or not.
  // If not multi, follow the first path. If multi, break it
  // down and try again.

  // Get a label instead if we can.
  var ilabel = anchor._golr_response.get_doc_label(did, field_id, bit);
  if (!ilabel) {
    ilabel = bit;
  }

  // Extract highlighting if we can from whatever our "label"
  // was.
  var hl = anchor._golr_response.get_doc_highlight(did, field_id, ilabel);

  // See what kind of link we can create from what we got.
  var ilink = anchor._linker.anchor({
    id: bit,
    label: ilabel,
    hilite: hl
  }, field_id);

  //ll('processing: ' + [field_id, ilabel, bit].join(', '));
  //ll('ilink: ' + ilink);

  // See what we got, in order of how much we'd like to have it.
  if (ilink) {
    retval = ilink;
  } else if (ilabel) {
    retval = ilabel;
  } else {
    retval = bit;
  }
  return retval;
};

/*
 * Package: filter_shield.js
 * 
 * Namespace: bbop-widget-set.display.filter_shield
 * 
 * BBOP object to produce a self-constructing/self-destructing shield
 * to support very large filter selection in the live search/search
 * pane genre.
 */

/*
 * Constructor: filter_shield
 * 
 * Contructor for the bbop-widget-set.display.filter_shield object.
 * 
 * Support for <bbop-widget-set.search_pane> by way of
 * <bbop-widget-set.display.live_search>
 * 
 * Arguments:
 *  spinner_img_src - *[optional]* optional source of a spinner image to use
 *  wait_msg - *[optional]* the wait message to use; may be a string or html; defaults to "Waiting..."
 * 
 * Returns:
 *  self
 */
var filter_shield = function filter_shield(spinner_img_src, wait_msg) {
  this._is_a = 'bbop-widget-set.display.filter_shield';
  var anchor = this;

  // Per-UI logger.
  var logger = new bbop.logger();
  logger.DEBUG = true;
  function ll(str) {
    logger.kvetch('W (filter_shield): ' + str);
  }

  // Determine wait_msg, if any.
  if (!wait_msg) {
    wait_msg = 'Waiting...';
  } else {
    // pass it through
  }

  // Variables that we'll need to keep.
  var is_open_p = false;
  var parea = new html.tag('div', {
    'generate_id': true
  });
  var pmsg = new html.tag('div', {
    'generate_id': true
  }, wait_msg);
  parea.add_to(pmsg);
  var div = new html.tag('div', {
    'generate_id': true
  }, parea);
  var pmsg_id = pmsg.get_id();
  //var pbar_id = pbar.get_id();
  var div_id = div.get_id();
  var diargs = {
    modal: true,
    draggable: false,
    width: 800,
    height: 600,
    close: function close() {
      // TODO: Could maybe use .dialog('destroy') instead?
      jQuery('#' + div_id).remove();
    }
  };

  /*
   * Function: start_wait
   * 
   * Render an unpopulated modal shield with some kind of waiting
   * element. This is to act as a block for the IO if
   * desired--calling this before .draw() is not required (as
   * .draw() will call it anyways if you haven't).
   * 
   * Arguments:
   *  n/a
   * 
   * Returns:
   *  n/a
   */
  this.start_wait = function () {
    // Mark that we've finally opened it.
    is_open_p = true;

    // Append div to body.
    jQuery('body').append(div.to_string());

    // If we have an image source specified, go ahead and add it to
    // the waiting display before popping it open.
    if (spinner_img_src && spinner_img_src !== '') {
      var s = new spinner(parea.get_id(), spinner_img_src);
    }

    // Pop open the dialog.
    var dia = jQuery('#' + div_id).dialog(diargs);
  };

  /*
   * Function: draw
   * 
   * Render a temporary modal filter shield.
   * 
   * Arguments:
   *  field_name - the name (id) of the filter field to display
   *  filter_list - a list of [[filter_id, filter_count], ...]
   *  manager - the manager that we'll use for the callbacks
   * 
   * Returns:
   *  n/a
   */
  this.draw = function (field_name, filter_list, manager) {
    //ll(doc['id']);

    // Open the shield if it is not already open.
    if (!is_open_p) {
      anchor.open();
    }
    var txt = 'No filters...';
    var tbl = new html.table(null, null, {
      'generate_id': true
    });
    var button_hash = {};
    us.each(filter_list, function (field) {
      var fname = field[0];
      var fcount = field[1];
      var b_plus = new generators.text_button_sim('+', 'Add positive filter');
      var b_minus = new generators.text_button_sim('-', 'Add negative filter');
      button_hash[b_plus.get_id()] = [field_name, fname, fcount, '+'];
      button_hash[b_minus.get_id()] = [field_name, fname, fcount, '-'];
      tbl.add_to([fname, '(' + fcount + ')', b_plus.to_string(), b_minus.to_string()]);
    });
    txt = tbl.to_string();

    // Create a filter slot div.

    // Add filter slot and table text to div.
    jQuery('#' + div_id).empty();
    var fdiv = new html.tag('div', {
      'generate_id': true
    });
    jQuery('#' + div_id).append(fdiv.to_string());
    jQuery('#' + div_id).append(txt);

    // Apply the filter to the table.
    var ft = null;
    if (spinner_img_src && spinner_img_src !== '') {
      ft = filter_table(fdiv.get_id(), tbl.get_id(), spinner_img_src, null);
    } else {
      ft = filter_table(fdiv.get_id(), tbl.get_id(), null);
    }

    // Okay, now introducing a function that we'll be using a
    // couple of times in our callbacks. Given a button id (from
    // a button hash) and the [field, filter, count, polarity]
    // values from the props, make a button-y thing an active
    // filter.
    function filter_select_live(create_time_button_props, button_id) {
      var in_polarity = create_time_button_props[3];

      // Decide on the button graphical elements.
      var b_ui_icon = 'ui-icon-plus';
      if (in_polarity === '-') {
        b_ui_icon = 'ui-icon-minus';
      }
      var b_ui_props = {
        icons: {
          primary: b_ui_icon
        },
        text: false
      };

      // Create the button and immediately add the event.
      jQuery('#' + button_id).click(function () {
        var tid = jQuery(this).attr('id');
        var call_time_button_props = button_hash[tid];
        var call_field = call_time_button_props[0];
        var call_filter = call_time_button_props[1];
        //var in_count = button_props[2];
        var call_polarity = call_time_button_props[3];

        // Change manager, fire, and close the dialog.
        manager.add_query_filter(call_field, call_filter, [call_polarity]);
        manager.search();
        jQuery('#' + div_id).remove();
      });
    }

    // Now let's go back and add the buttons, styles,
    // events, etc. in the main accordion section.
    us.each(button_hash, filter_select_live);
  };
};

/*
 * Package: list_select_shield.js
 * 
 * Namespace: bbop-widget-set.list_select_shield
 * 
 * BBOP object to produce a self-constructing/self-destructing term
 * information shield.
 * 
 * A simple invocation could be:
 * 
 * : new bbop-widget-set.list_select_shield({title: 'foo', blurb: 'explanation', list_of_lists: [[['a', 'b'], ['c', 'd', true]], [[1, 2], [3, 4]]], title_list: ['title 1', 'title 2'], action: function(selected_args){ alert(selected_args.join(', '));}})
 * 
 * This is a completely self-contained UI and manager.
 */

/*
 * Constructor: list_select_shield
 * 
 * Contructor for the bbop-widget-set.list_select_shield object.
 * 
 * The purpose of this object to to create a popup that 1) display
 * multiple lists for the user to select from and 2) triggers an
 * action (by function argument) to act on the list selections.
 * 
 * The "list_of_lists" argument is a list of lists structured like:
 * : [[[label, value, nil|true|false], ...], ...]
 * 
 * Items that are true will appear as pre-checked when the lists come
 * up.
 * 
 * The "action" argument is a function that takes a list of selected
 * values.
 * 
 * The argument hash looks like:
 *  title - *[optional]* the title to be displayed 
 *  blurb - *[optional]* a text chunk to explain the point of the action
 *  title_list - a list of titles/explanations for the lists
 *  list_of_lists - a list of lists (see above)
 *  action - *[optional] * the action function to be triggered (see above, defaults to no-op)
 *  width - *[optional]* width as px integer (defaults to 800)
 * 
 * Arguments:
 *  in_argument_hash - hash of arguments (see above)
 * 
 * Returns:
 *  self
*/
var list_select_shield = function list_select_shield(in_argument_hash) {
  this._is_a = 'bbop-widget-set.list_select_shield';
  var anchor = this;

  // Per-UI logger.
  var logger = new bbop.logger();
  logger.DEBUG = true;
  function ll(str) {
    logger.kvetch('W (list_select_shield): ' + str);
  }

  // Our argument default hash.
  var default_hash = {
    'title': '',
    'blurb': '',
    'title_list': [],
    'list_of_lists': [],
    'action': function action() {},
    'width': 800
  };
  var folding_hash = in_argument_hash || {};
  var arg_hash = bbop.fold(default_hash, folding_hash);
  var title = arg_hash['title'];
  var blurb = arg_hash['blurb'];
  var title_list = arg_hash['title_list'];
  var list_of_lists = arg_hash['list_of_lists'];
  var action = arg_hash['action'];
  var width = arg_hash['width'];

  // Cache the group names as we go so we can pull them out later
  // when we scan for checked items.
  var group_cache = [];
  function _draw_radio_list(list) {
    var list_cache = [];
    var rdo_grp = 'bbop_js_lss_' + bbop.uuid();
    group_cache.push(rdo_grp);
    us.each(list, function (item) {
      var lbl = item[0];
      var val = item[1];
      var ckt = item[2] || false;

      //ll('lbl: ' + lbl);
      //ll('val: ' + val);
      //ll('ckt: ' + ckt);

      // Radio button.	 
      var rdo_attrs = {
        'generate_id': true,
        'name': rdo_grp,
        'type': 'radio',
        'value': val
      };
      if (ckt) {
        rdo_attrs['checked'] = 'checked';
      }
      var rdo = new html.input(rdo_attrs);
      //ll('rdo: ' + rdo.to_string());

      // Label for it.
      var rdo_lbl_attrs = {
        'for': rdo.get_id()
      };
      var rdo_lbl = new html.tag('label', rdo_lbl_attrs, '&nbsp;' + lbl);
      //ll('rdo_lbl: ' + rdo_lbl.to_string());

      // And a span to capture both.
      var rdo_span_attrs = {};
      var rdo_span = new html.span('', rdo_span_attrs);
      //ll('rdo_span (1): ' + rdo_span.to_string());
      rdo_span.add_to(rdo);
      //ll('rdo_span (2): ' + rdo_span.to_string());
      rdo_span.add_to(rdo_lbl);
      //ll('rdo_span (3): ' + rdo_span.to_string());

      // Now /this/ goes into the list.
      list_cache.push(rdo_span);
    });

    // Now we have a list of all the items, put them into a UL
    // element.
    var ul_list_attrs = {
      'generate_id': true,
      'class': 'bbop-js-ui-list-select-shield-list'
    };
    var ul_list = new html.list(list_cache, ul_list_attrs);

    // ...and send it back.
    return ul_list;
  }

  // Append super container div to body.
  var div = new html.tag('div', {
    'generate_id': true
  });
  var div_id = div.get_id();
  jQuery('body').append(div.to_string());

  // Add title and blurb to div.
  jQuery('#' + div_id).append('<p>' + blurb + '</p>');

  // Add the table of lists to div.
  var cont_table_attrs = {
    'class': 'bbop-js-ui-list-select-shield-table'
  };
  var tbl = new html.table(title_list, [], cont_table_attrs);
  var lol_cache = []; // not funny: list of lists
  us.each(list_of_lists, function (sub_list) {
    lol_cache.push(_draw_radio_list(sub_list));
  });
  tbl.add_to(lol_cache);
  jQuery('#' + div_id).append(tbl.to_string());

  // Finally, add a clickable button to that calls the action
  // function. (Itself embedded in a container div to help move it
  // around.)
  var cont_div_attrs = {
    'class': 'bbop-js-ui-dialog-button-right',
    'generate_id': true
  };
  var cont_div = new html.tag('div', cont_div_attrs);
  var cont_btn_attrs = {
    //'class': 'bbop-js-ui-dialog-button-right'
  };
  var cont_btn = new generators.text_button_sim('Continue', 'Click to continue', null, cont_btn_attrs);
  cont_div.add_to(cont_btn);
  jQuery('#' + div_id).append(cont_div.to_string());

  // Since we've technically added the button, back it clickable
  // Note that this is very much radio button specific.
  jQuery('#' + cont_btn.get_id()).click(function () {
    // Jimmy values out from above by cycling over the
    // collected groups.
    var selected = [];
    us.each(group_cache, function (gname) {
      var find_str = 'input[name=' + gname + ']';
      var val = null;
      jQuery(find_str).each(function () {
        if (this.checked) {
          val = jQuery(this).val();
        }
        // }else{
        // 	 selected.push(null);
        //}
      });
      selected.push(val);
    });

    // Calls those values with our action function.
    action(selected);

    // And destroy ourself.
    jQuery('#' + div_id).remove();
  });

  // Modal dialogify div; include self-destruct.
  var diargs = {
    'title': title,
    'modal': true,
    'draggable': false,
    'width': width,
    'close': function close() {
      // TODO: Could maybe use .dialog('destroy') instead?
      jQuery('#' + div_id).remove();
    }
  };
  var dia = jQuery('#' + div_id).dialog(diargs);
};

/*
 * Package: drop_select_shield.js
 * 
 * Namespace: bbop-widget-set.drop_select_shield
 * 
 * BBOP object to produce a self-constructing/self-destructing DnD
 * selection and ordering shield.
 * 
 * A simple invocation could be:
 * 
 * : new bbop-widget-set.drop_select_shield({title: 'foo', blurb: 'explanation', pool_list: [['a', 'b'], ['c', 'd']], selected_list [['a', 'b']], action: function(selected_items){ alert(selected_items.join(', '));}})
 * 
 * This is a completely self-contained UI and manager.
 */

/*
 * Constructor: drop_select_shield
 * 
 * Contructor for the bbop-widget-set.drop_select_shield object.
 * 
 * The purpose of this object to to create a popup that 1) displays a
 * drag selectable and reorderable list of items and 2) define an
 * action (by function argument) to act on the selection.
 * 
 * The list arguments take the form of: ["label", "id"].
 * 
 * The "action" argument is a function that takes a list of selected
 * ids.
 * 
 * The argument hash looks like:
 *  title - *[optional]* the title to be displayed 
 *  blurb - *[optional]* a text chunk to explain the point of the action
 *  pool_list - a list of lists (see above)
 *  selected_list - a list of lists (see above)
 *  action_label - *[optional] * defaults to "Select"
 *  action - *[optional] * the action function to be triggered (see above, defaults to no-op)
 *  width - *[optional]* width as px integer (defaults to 800)
 * 
 * Arguments:
 *  in_argument_hash - hash of arguments (see above)
 * 
 * Returns:
 *  self
 */
var drop_select_shield = function drop_select_shield(in_argument_hash) {
  this._is_a = 'bbop-widget-set.drop_select_shield';
  var anchor = this;

  // Per-UI logger.
  var logger = new bbop.logger();
  logger.DEBUG = true;
  function ll(str) {
    logger.kvetch('W (drop_select_shield): ' + str);
  }

  // Our argument default hash.
  var default_hash = {
    'title': '',
    'blurb': '',
    'pool_list': [],
    'selected_list': [],
    'action_label': 'Select',
    'action': function action() {},
    'width': 800
  };
  var folding_hash = in_argument_hash || {};
  var arg_hash = bbop.fold(default_hash, folding_hash);
  var title = arg_hash['title'];
  var blurb = arg_hash['blurb'];
  var pool_list = arg_hash['pool_list'];
  var selected_list = arg_hash['selected_list'];
  var action_label = arg_hash['action_label'];
  var action = arg_hash['action'];
  var width = arg_hash['width'];

  // Create a random class that we'll use as a connector later.
  var rclass = 'bbop-js-ui-dss-rclass-' + bbop.randomness(20);

  // Get the pool and selected lists into html form for loading into
  // the frame table.
  var li_attrs = {
    'class': 'ui-state-default bbop-js-ui-hoverable'
    //'class': 'bbop-js-ui-hoverable'
  };
  var ul_src_list_attrs = {
    'generate_id': true,
    'class': 'bbop-js-ui-drop-select-shield ' + rclass
  };
  var pool_ul_list = new html.list([], ul_src_list_attrs);
  us.each(pool_list, function (item) {
    var lbl = item[0];
    var val = item[1];
    //ll('lbl: ' + lbl);
    //ll('val: ' + val);
    li_attrs['value'] = val;
    var cntnt = '' + '<span class="ui-icon ui-icon-arrow-4"></span> ' + '' + lbl + ' (' + val + ')' + '';
    var li_elt = new html.tag('li', li_attrs, cntnt);
    pool_ul_list.add_to(li_elt);
  });
  var ul_target_list_attrs = {
    'generate_id': true,
    'class': 'bbop-js-ui-drop-select-shield bbop-js-ui-drop-select-shield-target ' + rclass
  };
  var selected_ul_list = new html.list([], ul_target_list_attrs);
  us.each(selected_list, function (item) {
    var lbl = item[0];
    var val = item[1];
    //ll('lbl: ' + lbl);
    //ll('val: ' + val);
    li_attrs['value'] = val;
    var cntnt = '' + '<span class="ui-icon ui-icon-arrow-4"></span> ' + '' + lbl + ' (' + val + ')' + '';
    var li_elt = new html.tag('li', li_attrs, cntnt);
    selected_ul_list.add_to(li_elt);
  });

  // Append super container div to body.
  var div = new html.tag('div', {
    'generate_id': true
  });
  var div_id = div.get_id();
  jQuery('body').append(div.to_string());

  // Add title and blurb to div.
  jQuery('#' + div_id).append('<p>' + blurb + '</p>');

  // Add the table frame to the div.
  var tbl = new html.table(['Available pool', 'Selected fields'], [[pool_ul_list, selected_ul_list]], {
    'class': 'bbop-js-ui-drop-select-shield-frame'
  });
  jQuery('#' + div_id).append(tbl.to_string());

  // Make the lists operable.
  var pul_id = pool_ul_list.get_id();
  var sul_id = selected_ul_list.get_id();
  jQuery('#' + pul_id + ',#' + sul_id).sortable({
    connectWith: '.' + rclass
  }).disableSelection();

  // Helper function to pull the values.
  // Currently, JQuery adds a lot of extra non-attributes li
  // tags when it creates the DnD, so filter those out to
  // get just the fields ids.
  function _get_selected() {
    var ret_list = [];
    var selected_strings = jQuery('#' + sul_id).sortable('toArray', {
      'attribute': 'value'
    });
    us.each(selected_strings, function (in_thing) {
      if (in_thing && in_thing !== '') {
        ret_list.push(in_thing);
      }
    });
    return ret_list;
  }

  // Buttons for final dialog.
  var mod_buttons = {};
  mod_buttons[action_label] = function (event) {
    var final_selected = _get_selected();

    // Calls those values with our action function.
    action(final_selected);

    // And destroy ourself.
    jQuery('#' + div_id).remove();
  };
  mod_buttons['Cancel'] = function (event, selected_items) {
    jQuery('#' + div_id).remove();
  };

  // Modal dialogify div; include self-destruct.
  var diargs = {
    'title': title,
    'modal': true,
    'draggable': false,
    'width': width,
    'buttons': mod_buttons,
    'close': function close() {
      //jQuery(this).dialog('destroy');
      jQuery(this).remove();
    }
  };
  var dia = jQuery('#' + div_id).dialog(diargs);
};

/*
 * Package: dialog.js
 * 
 * Namespace: bbop-widget-set.dialog
 * 
 * BBOP object to produce a self-constructing/self-destructing
 * jQuery popup dialog.
 * 
 * This is a completely self-contained UI.
 */

/*
 * Constructor: dialog
 * 
 * Contructor for the bbop-widget-set.dialog object.
 * 
 * The optional hash arguments look like:
 * 
 * Arguments:
 *  item - string or html obj to display.
 *  in_argument_hash - *[optional]* optional hash of optional arguments
 * 
 * Returns:
 *  self
 */
var dialog = function dialog(item, in_argument_hash) {
  this._is_a = 'bbop-widget-set.dialog';
  var anchor = this;

  // Per-UI logger.
  var logger = new bbop.logger();
  logger.DEBUG = true;
  function ll(str) {
    logger.kvetch('W (dialog): ' + str);
  }

  // Our argument default hash.
  var default_hash = {
    //modal: true,
    //draggable: false,
    width: 300,
    // the jQuery default anyways
    title: '',
    buttons: null,
    close: function close() {
      // TODO: Could maybe use .dialog('destroy') instead?
      jQuery('#' + div_id).remove();
    }
  };
  var folding_hash = in_argument_hash || {};
  var arg_hash = bbop.fold(default_hash, folding_hash);

  // Not an argument for the dialog, so remove it.
  var title = arg_hash['title'];
  delete arg_hash['title'];

  ///
  /// Actually draw.
  ///

  // Coerce our argument into a string.
  var str = item || 'Nothing here...';
  if (bbop.what_is(item) !== 'string') {
    str = item.to_string();
  }

  // Create new div.
  var div = new html.tag('div', {
    'generate_id': true,
    title: title
  });
  var div_id = div.get_id();

  // Append div to end of body.
  jQuery('body').append(div.to_string());

  // Add text to div.
  jQuery('#' + div_id).append(str);

  // Boink!
  var dia = jQuery('#' + div_id).dialog(arg_hash);
};

/*
 * Package: button_templates.js
 * 
 * Namespace: bbop-widget-set.display.button_templates
 * 
 * Template generators for various button "templates" that can be fed
 * into the <search_pane> widget.
 * 
 * These templates foten have functions that manipulate the
 * environment outside, such as window.*, etc. Be aware and look at
 * the code carefully--there is a reason they're in the
 * widgets/display area.
 * 
 * Note: this is a collection of methods, not a constructor/object.
 */

var button_templates = {};

/*
 * Method: field_download
 * 
 * Generate the template for a simple download button.
 * 
 * Arguments:
 *  label - the text to use for the hover
 *  count - the number of items to download
 *  fields - the field to download
 *  download_url - *[optional]* the golr download URL, if different
 * 
 * Returns:
 *  hash form of jQuery button template for consumption by <search_pane>.
 */
button_templates.field_download = function (label, count, fields, download_url) {
  var dl_props = {
    'entity_list': null,
    'rows': count
  };
  var field_download_button = {
    label: '<span class="glyphicon glyphicon-download"></span> ' + label,
    diabled_p: false,
    // text_p: false,
    // icon: 'ui-icon-document',
    click_function_generator: function click_function_generator(results_table, manager) {
      return function (event) {
        var dialog_props = {
          title: 'Download',
          buttons: {
            'Download': function Download() {
              //alert('download');
              dl_props['entity_list'] = results_table.get_selected_items();
              dl_props['golr_download_url'] = download_url;
              results_table.get_selected_items();
              var raw_gdl = manager.get_download_url(fields, dl_props);
              window.open(raw_gdl, '_blank');
              //jQuery(this).dialog('destroy');
              jQuery(this).remove();
            },
            'Cancel': function Cancel() {
              //jQuery(this).dialog('destroy');
              jQuery(this).remove();
            }
          }
        };
        new dialog('<h4>Download (up to ' + count + ')</h4><p>You may download up to ' + count + ' lines in a new window. If your request is large or if the the server busy, this may take a while to complete--please be patient.</p>', dialog_props);
        //window.open(raw_gdl, '_blank');
      };
    }
  };
  return field_download_button;
};

/*
 * Method: restmark
 * 
 * Generate the template for a simple bookmark button with pop-up.
 * 
 * Arguments:
 *  linker - the linker to be used for this bookmarking
 * 
 * Returns:
 *  hash form of jQuery button template for consumption by <search_pane>.
 */
button_templates.restmark = function (linker) {
  var bookmark_button = {
    label: '<span class="glyphicon glyphicon-share"></span> Bookmark',
    diabled_p: false,
    text_p: false,
    icon: 'ui-icon-link',
    click_function_generator: function click_function_generator(results_table, manager) {
      return function (event) {
        //alert('GAF download: ' + manager.get_query_url());
        //alert('URL: ' + manager.get_query_url());
        var raw_restmark = manager.get_filter_query_string();
        // var a_args = {
        // 	// Since we're using the whole URI as a
        // 	// parameter, we use the heavy hitter on top
        // 	// of the already encoded URI.
        // 	id: encodeURIComponent(raw_bookmark),
        // 	label: 'this search'
        // };
        //  linker.anchor(a_args, 'search', curr_personality)

        var restmark_anchor = '<a href="?' + raw_restmark + '">this search</a>';
        new dialog('<p>Bookmark for: ' + restmark_anchor + '.</p><p>Please be aware that <strong>this bookmark does not save properties</strong> like currently selected items.</p><p>The AmiGO 2 bookmarking method may change in the future: at this point, <strong>it is intended as a temporary method</strong> (days, not weeks or months) of allowing the reruning of searches using a link.</p>', {
          'title': 'Bookmark'
        });
      };
    }
  };
  return bookmark_button;
};

/*
 * Method: bookmark
 * 
 * Generate the template for a simple bookmark (for search) button
 * with pop-up.
 * 
 * Arguments:
 *  linker - the linker to be used for this bookmarking
 * 
 * Returns:
 *  hash form of jQuery button template for consumption by <search_pane>.
 */
button_templates.bookmark = function (linker) {
  var bookmark_button = {
    label: '<span class="glyphicon glyphicon-share"></span> Bookmark',
    diabled_p: false,
    text_p: false,
    icon: 'ui-icon-link',
    click_function_generator: function click_function_generator(results_table, manager) {
      return function (event) {
        //alert('GAF download: ' + manager.get_query_url());
        //alert('URL: ' + manager.get_query_url());
        var raw_bookmark = manager.get_state_url();
        var curr_personality = manager.get_personality();
        var a_args = {
          // Since we're using the whole URI as a
          // parameter, we use the heavy hitter on top
          // of the already encoded URI.
          id: encodeURIComponent(raw_bookmark),
          label: 'this search'
        };
        new dialog('<p>Bookmark for: ' + linker.anchor(a_args, 'search', curr_personality) + '</p><p>Please be aware that <strong>this bookmark does not save properties</strong> like currently selected items.</p><p>The AmiGO 2 bookmarking method may change in the future: at this point, <strong>it is intended as a temporary method</strong> (days, not weeks or months) of allowing the reruning of searches using a link.</p>', {
          'title': 'Bookmark'
        });
      };
    }
  };
  return bookmark_button;
};

/*
 * Method: send_fields_to_galaxy
 * 
 * Generate the template for a button that sends fields to a Galaxy
 * instance.
 * 
 * Arguments:
 *  label - the text to use for the hover
 *  count - the number of items to download
 *  fields - the field to download
 *  galaxy - the url to the galaxy instance we're sending to
 *  download_url - *[optional]* the golr download URL, if different
 * 
 * Returns:
 *  hash form of jQuery button template for consumption by <search_pane>.
 */
button_templates.send_fields_to_galaxy = function (label, count, fields, galaxy, download_url) {
  var dl_props = {
    'entity_list': null,
    'rows': count
  };
  var galaxy_button = {
    label: '<span class="glyphicon glyphicon-circle-arrow-up"></span> ' + label,
    diabled_p: false,
    text_p: false,
    icon: 'ui-icon-mail-closed',
    click_function_generator: function click_function_generator(results_table, manager) {
      return function (event) {
        // If we have something, construct a form
        if (!galaxy || galaxy === "") {
          alert('Sorry: could not find a usable Galaxy.');
        } else {
          // We have a galaxy, so let's try and kick out
          // to it. Cribbing form POST from Gannet.
          var bval = '1 field';
          if (fields && fields.length > 1) {
            bval = fields.length + ' fields';
          }
          var input_su = new html.input({
            name: 'submit',
            type: 'submit',
            value: bval
          });
          var input_um = new html.input({
            name: 'URL_method',
            type: 'hidden',
            value: 'get'
          });

          // See GAF download button for more info.
          dl_props['entity_list'] = results_table.get_selected_items();
          dl_props['golr_download_url'] = download_url;
          var raw_gdl = manager.get_download_url(fields, dl_props);
          var input_url = new html.input({
            name: 'URL',
            type: 'hidden',
            value: raw_gdl
          });
          var form = new html.tag('form', {
            id: 'galaxyform',
            name: 'galaxyform',
            method: 'POST',
            target: '_blank',
            action: galaxy
          }, [input_su, input_um, input_url]);

          // Finally, bang out what we've constructed in
          // a form.
          var diargs = {
            modal: true,
            title: 'Trigger kick back to Galaxy',
            width: 700
          };
          new dialog('Export to Galaxy: ' + form.to_string(), diargs);
        }
      };
    }
  };
  return galaxy_button;
};

/*
 * Method: open_facet_matrix
 * 
 * Generate the template for a button that sends the user to the
 * facet_matrix page with the current manager state and two facets.
 * 
 * TODO: The facet_matrix link should be handled by the linker, not
 * manually using the app_base info.
 * 
 * Arguments:
 *  gconf - a copy of the <golr_conf> for the currrent setup
 *  instance_data - a copy of an amigo.data.server() for app_base info
 * 
 * Returns:
 *  hash form of jQuery button template for consumption by <search_pane>.
 */
button_templates.open_facet_matrix = function (gconf, instance_data) {
  var facet_matrix_button = {
    label: '<span class="glyphicon glyphicon-th"></span> Matrix compare',
    diabled_p: false,
    text_p: false,
    //icon: 'ui-icon-caret-2-e-w',
    icon: 'ui-icon-calculator',
    click_function_generator: function click_function_generator(results_table, manager) {
      return function (event) {
        // 
        var pers = manager.get_personality();
        var class_conf = gconf.get_class(pers);
        if (class_conf) {
          var filter_list = class_conf.field_order_by_weight('filter');

          // Get a list of all the facets that we can
          // compare.
          var facet_list_1 = [];
          us.each(filter_list, function (filter_id, findex) {
            var cf = class_conf.get_field(filter_id);
            var cname = cf.display_name();
            var cid = cf.id();
            var pset = [cname, cid];

            // Make sure the first one is
            // checked.
            if (findex === 0) {
              pset.push(true);
            }
            facet_list_1.push(pset);
          });
          // We need two though.
          var facet_list_2 = bbop.clone(facet_list_1);

          // Stub sender.
          var lss_args = {
            title: 'Select facets to compare',
            blurb: 'This dialog will launch you into a tool in another window where you can examine the document counts for two selected facets in a matrix (grid) view.',
            list_of_lists: [facet_list_1, facet_list_2],
            title_list: ['Facet 1', 'Facet 2'],
            action: function action(selected_args) {
              var f1 = selected_args[0] || '';
              var f2 = selected_args[1] || '';
              var jmp_state = manager.get_state_url();
              var mngr = encodeURIComponent(jmp_state);
              var jump_url = instance_data.app_base + '/facet_matrix?' + ['facet1=' + f1, 'facet2=' + f2, 'manager=' + mngr].join('&');
              window.open(jump_url, '_blank');
            }
          };
          new list_select_shield(lss_args);
        }
      };
    }
  };
  return facet_matrix_button;
};

/*
 * Method: flexible_download
 * 
 * Generate the template for a button that gives the user a DnD and
 * reorderable selector for how they want their tab-delimited
 * downloads.
 * 
 * Arguments:
 *  label - the text to use for the hover
 *  count - the number of items to be downloadable
 *  start_fields - ordered list of the initially selected fields 
 *  personality - the personality (id) that we want to work with
 *  gconf - a copy of the <golr_conf> for the currrent setup
 *  download_url - *[optional]* the golr download URL, if different
 * 
 * Returns:
 *  hash form of jQuery button template for consumption by <search_pane>.
 */
button_templates.flexible_download = function (label, count, start_fields, personality, gconf, download_url) {
  var dl_props = {
    'entity_list': null,
    'rows': count
  };
  var flexible_download_button = {
    label: '<span class="glyphicon glyphicon-download"></span> ' + label,
    diabled_p: false,
    text_p: false,
    icon: 'ui-icon-circle-arrow-s',
    click_function_generator: function click_function_generator(results_table, manager) {
      return function (event) {
        var class_conf = gconf.get_class(personality);
        if (class_conf) {
          // First, a hash of our default items so we can
          // check against them later to remove those items
          // from the selectable pool.  Then convert the
          // list into a more interesting data type.
          var start_hash = bbop.hashify(start_fields);
          var start_list = [];
          us.each(start_fields, function (field_id, field_index) {
            var cf = class_conf.get_field(field_id);
            var cname = cf.display_name();
            var cid = cf.id();
            var pset = [cname, cid];
            start_list.push(pset);
          });

          // Then get an ordered list of all the
          // different values we want to show in
          // the pool list.
          var pool_list = [];
          var all_fields = class_conf.get_fields();
          us.each(all_fields, function (field, field_index) {
            var field_id = field.id();
            if (start_hash[field_id]) {
              // Skip if already in start list.
            } else {
              var cname = field.display_name();
              var cid = field.id();
              var pset = [cname, cid];
              pool_list.push(pset);
            }
          });

          // To alphabetical.
          pool_list.sort(function (a, b) {
            var av = a[0];
            var bv = b[0];
            var val = 0;
            if (av < bv) {
              return -1;
            } else if (av > bv) {
              return 1;
            }
            return val;
          });

          // Stub sender.
          var dss_args = {
            title: 'Select the fields to download (up to ' + count + ')',
            blurb: '<p><strong>Drag and drop</strong> the desired fields <strong>from the left</strong> column (available pool) <strong>to the right</strong> (selected fields). You may also reorder them.</p><p>Download up to ' + count + ' lines in a new window by clicking <strong>Download</strong>. If your request is large or if the the server busy, this may take a while to complete--please be patient.</p>',
            //blurb: 'By clicking "Download" at the bottom, you may download up to ' + count + ' lines in your browser in a new window. If your request is large or if the the server busy, this may take a while to complete--please be patient.',
            pool_list: pool_list,
            selected_list: start_list,
            action_label: 'Download',
            action: function action(selected_items) {
              dl_props['entity_list'] = results_table.get_selected_items();
              dl_props['golr_download_url'] = download_url;
              var raw_gdl = manager.get_download_url(selected_items, dl_props);
              window.open(raw_gdl, '_blank');
            }
          };
          new drop_select_shield(dss_args);
        }
      };
    }
  };
  return flexible_download_button;
};

/*
 * Method: flexible_download_b3
 * 
 * Generate the template for a button that gives the user a DnD and
 * reorderable selector for how they want their tab-delimited
 * downloads.
 * 
 * Arguments:
 *  label - the text to use for the hover
 *  count - the number of items to be downloadable
 *  start_fields - ordered list of the initially selected fields 
 *  personality - the personality (id) that we want to work with
 *  gconf - a copy of the <golr_conf> for the currrent setup
 *  download_url - *[optional]* the golr download URL, if different
 * 
 * Returns:
 *  hash form of jQuery button template for consumption by other widgets
 */
button_templates.flexible_download_b3 = function (label, count, start_fields, personality, gconf, download_url) {
  var dl_props = {
    'entity_list': null,
    'rows': count
  };
  var flexible_download_button = {
    label: '<span class="glyphicon glyphicon-download"></span> ' + label,
    diabled_p: false,
    text_p: false,
    click_function_generator: function click_function_generator(results_table, manager) {
      return function (event) {
        var class_conf = gconf.get_class(personality);
        if (class_conf) {
          // First, a hash of our default items so we can
          // check against them later to remove those items
          // from the selectable pool.  Then convert the
          // list into a more interesting data type.
          var start_hash = bbop.hashify(start_fields);
          var start_list = [];
          us.each(start_fields, function (field_id, field_index) {
            var cf = class_conf.get_field(field_id);
            var cname = cf.display_name();
            var cid = cf.id();
            var pset = [cname, cid];
            start_list.push(pset);
          });

          // Then get an ordered list of all the
          // different values we want to show in
          // the pool list.
          var pool_list = [];
          var all_fields = class_conf.get_fields();
          us.each(all_fields, function (field, field_index) {
            var field_id = field.id();
            if (start_hash[field_id]) {
              // Skip if already in start list.
            } else {
              var cname = field.display_name();
              var cid = field.id();
              var pset = [cname, cid];
              pool_list.push(pset);
            }
          });

          // To alphabetical.
          pool_list.sort(function (a, b) {
            var av = a[0];
            var bv = b[0];
            var val = 0;
            if (av < bv) {
              return -1;
            } else if (av > bv) {
              return 1;
            }
            return val;
          });

          // Stub sender.
          var dss_args = {
            title: 'Select the fields to download (up to ' + count + ')',
            blurb: '<p><strong>Drag and drop</strong> the desired fields <strong>from the left</strong> column (available pool) <strong>to the right</strong> (selected fields). You may also reorder them.</p><p>Download up to ' + count + ' lines in a new window by clicking <strong>Download</strong>. If your request is large or if the the server busy, this may take a while to complete--please be patient.</p>',
            //blurb: 'By clicking "Download" at the bottom, you may download up to ' + count + ' lines in your browser in a new window. If your request is large or if the the server busy, this may take a while to complete--please be patient.',
            pool_list: pool_list,
            selected_list: start_list,
            action_label: 'Download',
            action: function action(selected_items) {
              // Get selected items from results
              // checkboxes.
              dl_props['entity_list'] = null;
              if (!us.isEmpty(results_table)) {
                dl_props['entity_list'] = results_table.get_selected_items();
              }
              dl_props['golr_download_url'] = download_url;
              // Download for the selected fields...
              var raw_gdl = manager.get_download_url(selected_items, dl_props);
              // ...opening it in a new window.
              window.open(raw_gdl, '_blank');
            }
          };
          new drop_select_shield(dss_args);
        }
      };
    }
  };
  return flexible_download_button;
};

/*
 * Package: term_shield.js
 * 
 * Namespace: bbop.widget.term_shield
 * 
 * BBOP object to produce a self-constructing/self-destructing term
 * information shield.
 * 
 * This is a completely self-contained UI and manager.
 */

/*
 * Constructor: term_shield
 * 
 * Contructor for the bbop.widget.term_shield object.
 * 
 * This is (sometimes) a specialized (and widgetized) subclass of
 * <bbop.golr.manager.jquery>.
 * 
 * To actually do much useful, you should set the personality of the
 * widget.
 * 
 * The optional hash arguments look like:
 * 
 *  linker - a "linker" object
 *  width - defaults to 700
 * 
 * Arguments:
 *  golr_loc - string url to GOlr server; not needed if local
 *  golr_conf_obj - a <golr-conf.conf> object
 *  in_argument_hash - *[optional]* optional hash of optional arguments
 * 
 * Returns:
 *  self
 */
var term_shield = function term_shield(doc, confclass, linker, in_argument_hash, add_ons) {
  this._is_a = 'bbop-widget-set.term_shield';
  var anchor = this;

  // Per-UI logger.
  var logger = new bbop.logger();
  logger.DEBUG = true;
  function ll(str) {
    logger.kvetch('W (term_shield): ' + str);
  }

  // Our argument default hash.
  var default_hash = {
    'linker_function': function linker_function() {},
    'width': 700
  };
  var folding_hash = in_argument_hash || {};
  var arg_hash = bbop.fold(default_hash, folding_hash);
  var width = arg_hash['width'];

  ///
  ///
  ///

  var txt = 'Nothing here...';
  if (doc && confclass) {
    var tbl = new html.table();
    var results_order = confclass.field_order_by_weight('result');
    us.each(results_order, function (fid) {
      // 
      var field = confclass.get_field(fid);
      var val = doc[fid];

      // Determine if we have a list that we're working
      // with or not.
      if (field.is_multi()) {
        if (val) {
          val = val.join(', ');
        } else {
          val = 'n/a';
        }
      } else {
        // When handling just the single value, see
        // if we can link out the value.
        var link = null;
        if (val) {
          // Try and extract the label.
          var lbl = doc[fid + '_label'];
          if (us.isString(lbl)) {
            link = linker.anchor({
              id: val,
              label: lbl
            }, fid);
          } else {
            link = linker.anchor({
              id: val
            }, fid);
          }
          if (link) {
            val = link;
          }
        } else {
          val = 'n/a';
        }
      }
      tbl.add_to([field.display_name(), val]);
    });
    us.each(add_ons, function (add_on) {
      tbl.add_to(add_on);
    });
    txt = tbl.to_string();
  }

  // Create div.
  var div = new html.tag('div', {
    'generate_id': true
  });
  var div_id = div.get_id();

  // Append div to body.
  jQuery('body').append(div.to_string());

  // Add text to div.
  jQuery('#' + div_id).append(txt);

  // Modal dialogify div; include self-destruct.
  var diargs = {
    modal: true,
    draggable: false,
    width: width,
    close: function close() {
      // TODO: Could maybe use .dialog('destroy') instead?
      jQuery('#' + div_id).remove();
    }
  };
  var dia = jQuery('#' + div_id).dialog(diargs);
  return dia;
};

///
/// Exportable body.
///

module.exports.spinner = spinner;
module.exports.dialog = dialog;
module.exports.filter_shield = filter_shield;
module.exports.filter_table = filter_table;
module.exports.results_table_by_class_conf = results_table_by_class_conf;
module.exports.drop_select_shield = drop_select_shield;
module.exports.list_select_shield = list_select_shield;
module.exports.term_shield = term_shield;
// Buttons.
module.exports.button_templates = button_templates;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./generators":15,"./html":17,"bbop-core":26,"underscore":108}],15:[function(require,module,exports){
var us = require('underscore');
var bbop = require('bbop-core');
var html = require('./html');
var generators = {};

/*
 * Method: clickable_object
 * 
 * Generator for a clickable object.
 * 
 * TODO: May eventually expand it to include making a jQuery button.
 * 
 * Arguments:
 *  label - *[optional]* the text to use for the span or label (defaults to '')
 *  source - *[optional]* the URL source of the image (defaults to '')
 *  id - *[optional]* the id for the object (defaults to generate_id: true)
 * 
 * Returns:
 *  html.span or html.image
 */
generators.clickable_object = function (label, source, id) {
  //this._is_a = 'bbop-widget-set.display.clickable_object';
  //var anchor = this;
  // // Per-UI logger.
  // var logger = new bbop.logger();
  // logger.DEBUG = true;
  // function ll(str){ logger.kvetch('W (clickable_object): ' + str); }

  // Default args.
  if (!label) {
    label = '';
  }
  if (!source) {
    source = '';
  }

  // Decide whether we'll use an incoming id or generate our own.
  var args = {};
  if (id) {
    args['id'] = id;
  } else {
    args['generate_id'] = true;
  }

  // Figure out an icon or a label.
  var obj = null;
  if (source === '') {
    obj = new html.span(label, args);
  } else {
    args['src'] = source;
    args['title'] = label;
    obj = new html.image(args);
  }
  return obj;
};

/*
 * Package: text_buttom_sim.js
 * 
 * Namespace: bbop-widget-set.display.text_button_sim
 * 
 * BBOP object to produce a clickable text span, that in conjunction with the local CSS, should make an awfully button looking creature.
 * 
 * It uses the class: "bbop-js-text-button-sim".
 * 
 * Note: this is a method, not a constructor.
 */

/*
 * Method: text_button_sim_generator
 * 
 * Generator for a text span for use for buttons.
 * 
 * Arguments:
 *  label - *[optional]* the text to use for the span or (defaults to 'X')
 *  title - *[optional]* the hover text (defaults to 'X')
 *  id - *[optional]* the id for the object (defaults to generate_id: true)
 *  add_attrs - *[optional]* more attributes to be folded in to the span as hash
 * 
 * Returns:
 *  html.span
 */
generators.text_button_sim = function (label, title, id, add_attrs) {
  // Default args.
  if (!label) {
    label = 'X';
  }
  if (!title) {
    title = 'X';
  }
  if (!add_attrs) {
    add_attrs = {};
  }

  // Decide whether we'll use an incoming id or generate our own.
  var args = {
    'class': "bbop-js-text-button-sim",
    'title': title
  };
  if (id) {
    args['id'] = id;
  } else {
    args['generate_id'] = true;
  }

  // Addtional optional atrributes and overrides.    
  args = bbop.merge(args, add_attrs);
  var obj = new html.span(label, args);
  return obj;
};

///
/// Exportable body.
///

module.exports = generators;

},{"./html":17,"bbop-core":26,"underscore":108}],16:[function(require,module,exports){
/*
 * Package: graph_tools.js
 * 
 * Namespace: bbop-widget-set.graph_tools.*
 * 
 * Purpose: An extension of <bbop.model.graph> to produce a bracketed
 * layout (like the neighborhood view in AmiGO 1.8).
 * 
 * TODO: A work in progress...
 * Tools for special operations on graphs.
 */

var us = require('underscore');
var bbop = require('bbop-core');

// Graphs.
var model = require('bbop-graph');
var graph_tools = {};

///
///
///

/*
 * Function: bracket_layout
 *
 * Largely borrowed from ChewableGraph.pm from the perl section on
 * AmiGO 2.
 * 
 * Produces a simple bracketed layout based on the maximum
 * distance from the node-of-interest to all other nodes. It also
 * includes direct children as the last row. Useful in some layout
 * contexts.
 *
 * Any node in a properly made graph should be fine, but for the
 * usual end case, see <rich_bracket_layout>.
 * 
 * Parameters: 
 *  graph - bbop-graph instance containing term_acc
 *  term_acc - node of interest
 *
 * Returns: 
 *  list of lists or id strings [[id1, id2], ...]
 */
graph_tools.bracket_layout = function (topology_graph, term_acc) {
  // // This is the actual path climbing agent.
  // function max_info_climber(in_curr_term, in_curr_term_dist,
  // 			  in_max_hist, in_enc_hist){

  //     // We either bootstrap (first run) or pull them in.
  //     var curr_term = in_curr_term || term_acc;
  //     var curr_term_distance = in_curr_term_dist || 0;
  //     var max_hist = in_max_hist || {};
  //     var encounter_hist = in_enc_hist || {};

  //     // ll('looking at: ' + curr_term + ' at ' + curr_term_distance);

  //     // Only recur if our encounter history sez that either
  //     // this node is new or if we have a higher distance count
  //     // (in which case we add it and continue on our merry
  //     // way).
  //     if( ! bbop.is_defined(encounter_hist[curr_term]) ){
  // 	// ll(curr_term + ' is a new encounter at distance ' +
  // 	//    curr_term_distance);

  // 	// Note that we have encountered this node before.
  // 	encounter_hist[curr_term] = 1;

  // 	// Our first distance is the current one!
  // 	max_hist[curr_term] = curr_term_distance;

  // 	// Increment our distance.
  // 	curr_term_distance++;

  // 	// Take a look at all the parents of our current term.
  // 	us.each(graph.get_parent_nodes(curr_term), function(p){
  // 		 // Since this is a new node encounter, let's
  // 		 // see what else is out there to discover.
  // 		 max_info_climber(p.id(), curr_term_distance,
  // 				  max_hist, encounter_hist);
  // 	     });

  //     }else if( encounter_hist[curr_term] ){
  // 	// ll(curr_term + ' has been seen before');

  // 	// If we're seeing this node again, but with a
  // 	// separate history, we'll add the length or our
  // 	// history to the current, but will not recur in any
  // 	// case (we've been here before).
  // 	if( max_hist[curr_term] < curr_term_distance ){
  // 	    // ll(curr_term +' has a new max of '+ curr_term_distance);
  // 	    max_hist[curr_term] = curr_term_distance;
  // 	}
  //     }

  //     // Return the collected histories.
  //     return max_hist;
  // }

  // This is the actual path climbing agent.
  function max_info_climber(in_curr_list, in_curr_term_dist, in_max_hist, in_enc_hist) {
    // We either bootstrap (first run) or pull them in.
    var curr_list = in_curr_list || [];
    // curr_list must be a list.
    if (!us.isArray(curr_list)) {
      curr_list = [curr_list];
    }
    var curr_term_distance = in_curr_term_dist || 0;
    var max_hist = in_max_hist || {};
    var encounter_hist = in_enc_hist || {};
    function update_info_for(update_item, update_distance) {
      if (!encounter_hist[update_item]) {
        // ll('first time encountering: ' +
        //    update_item + ', @:' + update_distance);
        // Note that we have encountered this node before.
        encounter_hist[update_item] = 1;
        // Our first distance is the current one!
        max_hist[update_item] = update_distance;
      } else {
        // ll('have seen before: ' + update_item + '...' +
        //    max_hist[update_item] + '/' + update_distance);
        // If we're seeing this node again, but with a
        // separate history, we'll add the length or our
        // history to the current, but will not recur in
        // any case (we've been here before).
        if (max_hist[update_item] < update_distance) {
          // ll('   new high at current: ' + update_distance);
          max_hist[update_item] = update_distance;
        } else {
          // ll('   keeping current: ' + max_hist[update_item]);
        }
      }
    }

    // //
    // ll('new set @' + curr_term_distance + ' looks like: ' +
    //    bbop.dump(curr_list));

    // Only work if we have things in our list.
    if (curr_list && curr_list.length > 0) {
      // Process everything in the list.
      us.each(curr_list, function (item) {
        update_info_for(item, curr_term_distance);
      });

      // Collect the parents of everything in the list.
      var next_round = {};
      us.each(curr_list, function (item) {
        us.each(topology_graph.get_parent_nodes(item), function (p) {
          var pid = p.id();
          next_round[pid] = true;
        });
      });
      var next_list = bbop.get_keys(next_round);

      // Increment our distance.
      curr_term_distance++;

      // //
      // ll('future @' + curr_term_distance + ' looks like: ' +
      //    bbop.dump(next_list));

      // Recur on new parent list.
      max_info_climber(next_list, curr_term_distance, max_hist, encounter_hist);
    }

    // Return the collected histories.
    return max_hist;
  }

  // A hash of the maximum distance from the node-in-question to
  // the roots.
  var max_node_dist_from_root = max_info_climber(term_acc);
  // ll('max_node_dist_from_root: ' +
  //    bbop.dump(max_node_dist_from_root));

  ///
  /// Convert this into something like brackets.
  ///

  // First, invert hash.
  // E.g. from {x: 1, y: 1, z: 2} to {1: [x, y], 2: [z]} 
  var lvl_lists = {};
  us.each(max_node_dist_from_root, function (lvl, node_id) {
    // Make sure that level is defined before we push.
    if (!bbop.is_defined(lvl_lists[lvl])) {
      lvl_lists[lvl] = [];
    }
    lvl_lists[lvl].push(node_id);
  });
  // ll('lvl_lists: ' + bbop.dump(lvl_lists));

  // Now convert the level-keyed hash into an array of arrays.
  // E.g. from {1: [x, y], 2: [z]} to [[x, y], [z]]
  var bracket_list = [];
  var levels = bbop.get_keys(lvl_lists);
  levels.sort(bbop.numeric_sort_ascending);
  // ll('levels: ' + bbop.dump(levels));
  us.each(levels, function (level) {
    var bracket = [];
    us.each(lvl_lists[level], function (item) {
      bracket.push(item);
    });
    bracket_list.push(bracket);
  });
  bracket_list.reverse(); // ...but I want the opposite
  // ll('bracket_list: ' + bbop.dump(bracket_list));

  // Well, that takes care of the parents, now lets do the
  // trivial task of adding all of the kids (if any).
  var c_nodes = topology_graph.get_child_nodes(term_acc);
  // Only add another level when there are actually kids.
  if (c_nodes && !bbop.is_empty(c_nodes)) {
    var kid_bracket = [];
    us.each(c_nodes, function (c) {
      kid_bracket.push(c.id());
    });
    bracket_list.push(kid_bracket);
  }
  return bracket_list;
};

/*
 * Function: relation_weight
 *
 * A GO-specific take on the relative importance of relations in a
 * graph.
 * 
 * Parameters: 
 *  predicate_acc - as string
 *  default_weight - *[optional]* as numbrt
 *
 * Returns: 
 *  relative weight of predicate as number; defaults to 0
 */
graph_tools.relation_weight = function (predicate_acc, default_weight) {
  var rel = predicate_acc || '';
  var dflt = default_weight || 0;
  var order = {
    'is_a': 1,
    'is a': 1,
    'has_part': 2,
    'has part': 2,
    'part_of': 3,
    'part of': 3,
    'regulates': 4,
    'negatively_regulates': 5,
    'negatively regulates': 5,
    'positively_regulates': 6,
    'positively regulates': 6,
    'occurs_in': 7,
    'occurs in': 7
  };
  var ret_weight = dflt;
  if (bbop.is_defined(rel) && rel && bbop.is_defined(order[rel])) {
    ret_weight = order[rel];
  }
  return ret_weight;
};

/*
 * Function: dominant_relationship
 *
 * Given a bunch of relationships, return the one that is more
 * "dominant".
 * 
 * A GO-specific take on the relative importance of relations in a
 * graph.
 * 
 * Parameters: 
 *  whatever - predicate acc, or lists of lists them...whatever
 *
 * Returns: 
 *  string acc of the dominant relationship or null
 * 
 * See also:
 *  <relationship_weight>
 */
graph_tools.dominant_relationship = function () {
  // Collect all of the relations, recursively unwinding as
  // necessary to get to the end of the arguments/lists of
  // predicate accs.
  // WARNING: Do /not/ try to refactor this for loop--see the
  // documentation for each for the reason.
  var all_rels = [];
  for (var dri = 0; dri < arguments.length; dri++) {
    var arg = arguments[dri];
    //ll('ARG: ' + arg);
    if (us.isArray(arg)) {
      // This funny thing is actually "dereferencing" the
      // array one step for the recursion.
      all_rels.push(graph_tools.dominant_relationship.apply(this, arg));
    } else {
      all_rels.push(arg);
    }
  }

  // Sort all of the remaining predicate accs according to
  // relation_weight.
  all_rels.sort(function (a, b) {
    return graph_tools.relation_weight(b) - graph_tools.relation_weight(a);
  });

  // Choose the top if it's there, null otherwise.
  var retval = null;
  if (all_rels.length) {
    retval = all_rels[0];
  }
  return retval;
};

/*
 * Function: rich_bracket_layout
 *
 * Very similar to <bracket_layout>, except that instead of the
 * node id, there is a list of [node_id, node_label, predicate].
 * 
 * This is only reliably producable if the following two condition
 * is met: the transitivity graph is the one made for the node of
 * interest by the GOlr loading engine. This is easy to meet if
 * using GOlr, but probably better to roll your own if you're not.
 * 
 * Also, the relative weight of the relations used is very
 * GO-specific--see <relation_weight>.
 * 
 * Again, heavy borrowing from ChewableGraph.pm from the perl
 * section in AmiGO 2.
 * 
 * Parameters: 
 *  graph - bbop-graph instance containing term_acc
 *  term_acc - node of interest
 *  transitivity_graph - the <bbop.model.graph> for the relations
 *
 * Returns: 
 *  list of lists of lists: [[[id, label, predicate], ...], ...]
 */
graph_tools.rich_bracket_layout = function (topology_graph, transitivity_graph, term_acc) {
  // First, lets just get our base bracket layout.
  var layout = graph_tools.bracket_layout(topology_graph, term_acc);

  // So, let's go through all the rows, looking on the
  // transitivity graph to see if we can find the predicates.
  var bracket_list = [];
  us.each(layout, function (layout_level) {
    var bracket = [];
    us.each(layout_level, function (layout_item) {
      // The defaults for what we'll pass back out.
      var curr_acc = layout_item;
      //var pred_id = 'is_a';
      // BUG/TODO: This is the temporary workaround for
      // incomplete transitivity graphs in some cases:
      // https://github.com/kltm/bbop-js/wiki/TransitivityGraph#troubleshooting-caveats-and-fail-modes
      var pred_id = 'related_to';
      var curr_node = topology_graph.get_node(curr_acc);
      var label = curr_node.label() || layout_item;

      // Now we just have to determine predicates. If we're
      // the one, we'll just use the defaults.
      if (curr_acc === term_acc) {
        // Default.
      } else {
        // Since the transitivity graph only stores
        // ancestors, we can also use it to passively test
        // if these are children we should be looking for.
        var trels = transitivity_graph.get_predicates(term_acc, curr_acc);
        if (!bbop.is_empty(trels)) {
          // Not children, so decide which of
          // the returned edges is the best.
          pred_id = graph_tools.dominant_relationship(trels);
        } else {
          // Probably children, so go ahead and try and
          // pull the direct parent/child relation.
          var drels = topology_graph.get_predicates(curr_acc, term_acc);
          if (!bbop.is_empty(drels)) {
            pred_id = graph_tools.dominant_relationship(drels);
          }
        }
      }

      // Turn our old layout item into a new-info
      // rich list.
      bracket.push([curr_acc, label, pred_id]);
    });
    // Sort alphanum and then re-add to list.
    bracket.sort(function (a, b) {
      if (a[1] < b[1]) {
        return -1;
      } else if (a[1] > b[1]) {
        return 1;
      } else {
        return 0;
      }
    });
    bracket_list.push(bracket);
  });
  return bracket_list;
};

///
/// Exportable body.
///

module.exports = graph_tools;

},{"bbop-core":26,"bbop-graph":27,"underscore":108}],17:[function(require,module,exports){
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
/* 
 * Package: html.js
 * 
 * Namespace: html
 * 
 * Right now contains html.tag, but all html producing functions
 * should go in here somewhere.
 * 
 * All html implement the interface:
 *  .to_string(): returns a string of you and below
 *  .add_to(): add things between the tags
 *  .empty(): empties all things between the tags
 *  .get_id(): return the id or null if not defined
 * These are enforced during the tests.
 * 
 * For functions that take attribute hashes, there is a special
 * attribute {'generate_id': true} that will generate a somewhat
 * random id if an incoming id was not already specified. This id can
 * be retrieved using get_id().
 * 
 * This package takes all of the html.* namespace.
 */

var us = require('underscore');
var bbop = require('bbop-core');
var html = {};

/*
 * Namespace: html.tag
 * 
 * Constructor: tag
 * 
 * Create the fundamental tag object to work with and extend.
 * 
 * Parameters:
 *  tag - the tag name to be created
 *  attrs - *[serially optional]* the typical attributes to add
 *  below - *[optional]* a list/array of other html objects that exists "between" the tags
 * 
 * Returns:
 *  html.tag object
 */
html.tag = function (tag, attrs, below) {
  this._is_a = 'bbop-widget-set.html.tag';

  // Arg check--attrs should be defined as something.
  if (!attrs) {
    attrs = {};
  } else {
    // Prevent sharing of structure.
    attrs = bbop.clone(attrs);
  }

  // Generate (or not) id if it was requested.
  if (!bbop.is_defined(attrs['id']) && bbop.is_defined(attrs['generate_id']) && bbop.is_defined(attrs['generate_id']) === true) {
    // Add a real id.
    attrs['id'] = 'gen_id-bbop-html-' + bbop.randomness(20);
    // Remove the 'generated_id' property.
    delete attrs['generate_id'];
  }
  this._attrs = attrs;

  // Arg check--below should be some kind of an array.
  if (!below) {
    below = [];
  } else if (us.isArray(below)) {
    // do nothing
  } else {
    // hopefully a html.tag then
    below = [below];
  }

  // Accumulate the incoming attributes if there are any.
  var additional_attrs = '';
  us.each(this._attrs, function (in_val, in_key) {
    additional_attrs = additional_attrs + ' ' + in_key + '="' + in_val + '"';
  });
  this._car = '<' + tag + additional_attrs + '>';
  this._cdr = '</' + tag + '>';
  this._contents = below;
  this._singleton = '<' + tag + additional_attrs + ' />';
};

/*
 * Function: to_string
 * 
 * Convert a tag object into a html-ized string.
 * 
 * Parameters: n/a
 * 
 * Returns:
 *  string
 */
html.tag.prototype.to_string = function () {
  var acc = '';
  us.each(this._contents, function (item, i) {
    // if( typeof(item) === 'string' ){
    // 	   acc = acc + item;
    // }else if( typeof(item['to_string']) === 'function' ){
    // 	   acc = acc + item.to_string();
    // }else{
    // 	   throw new Error('No to_string for (' +
    // 			   bbop.what_is(item) +
    // 			   ') ' + item);
    // }
    acc = acc + bbop.to_string(item);
  });

  // Special return case if there are no children (to prevent
  // weirdness for things like br and input).
  var output = this._singleton;
  if (acc !== '') {
    output = this._car + acc + this._cdr;
  }
  return output;
};

/*
 * Function: add_to
 * 
 * Add content between the tags. Order of addition is order of output.
 * 
 * Parameters:
 *  bbop_html_tag_or_string - another tag object or a string (html or otherwise)
 * 
 * Returns: n/a
 */
html.tag.prototype.add_to = function (bbop_html_tag_or_string) {
  this._contents.push(bbop_html_tag_or_string);
};

/*
 * Function: empty
 * 
 * Remove all content between the tags.
 * 
 * Parameters: n/a
 * 
 * Returns: n/a
 */
html.tag.prototype.empty = function () {
  this._contents = [];
};

/*
 * Function: get_id
 * 
 * Return the id if extant, null otherwise.
 * 
 * Parameters: n/a
 * 
 * Returns: string or null
 */
html.tag.prototype.get_id = function () {
  var retval = null;
  if (bbop.is_defined(this._attrs['id'])) {
    retval = this._attrs['id'];
  }
  return retval;
};

/*
 * Namespace: html.accordion
 * 
 * Constructor: accordion
 * 
 * Create the a frame for the functional part of a jQuery accordion
 * structure.
 * 
 * :Input:
 * : [[title, string/*.to_string()], ...]
 * :
 * :Output:
 * : <div id="accordion">
 * :  <h3><a href="#">Section 1</a></h3>
 * :  <div>
 * :   <p>
 * :    foo
 * :   </p>
 * :  </div>
 * :  ...
 * : </div>
 * 
 * Parameters:
 *  in_list - accordion frame headers: [[title, string/*.to_string()], ...]
 *  attrs - *[serially optional]* attributes to apply to the new top-level div
 *  add_id_p - *[optional]* true or false; add a random id to each section
 * 
 * Returns:
 *  html.accordion object
 * 
 * Also see: <tag>
 */
html.accordion = function (in_list, attrs, add_id_p) {
  this._is_a = 'bbop-widget-set.html.accordion';

  //
  if (typeof add_id_p === 'undefined') {
    add_id_p = false;
  }

  // Arg check--attrs should be defined as something.
  this._attrs = attrs || {};

  // Internal stack always starts with a div.
  this._div_stack = new html.tag('div', this._attrs);
  this._section_id_to_content_id = {};

  // Iterate over the incoming argument list.
  var accordion_this = this;
  us.each(in_list, function (item) {
    var sect_title = item[0];
    var content = item[1];
    accordion_this.add_to(sect_title, content, add_id_p);
  });
};

/*
 * Function: to_string
 * 
 * Convert the accordion object into a html-ized string.
 * 
 * Parameters: n/a
 * 
 * Returns:
 *  string
 */
html.accordion.prototype.to_string = function () {
  return this._div_stack.to_string();
};

/*
 * Function: add_to
 * 
 * Add a contect section to the accordion.
 * 
 * Parameters:
 *  section_info - a string or a hash with 'id', 'label', and 'description'
 *  content_blob - string or html object to put in a section
 *  add_id_p - *[optional]* true or false; add a random id to the section
 * 
 * Returns: n/a
 */
html.accordion.prototype.add_to = function (section_info, content_blob, add_id_p) {
  // If section_info isn't an object, assume it is a string and use
  // it for everything.
  var section_id = null;
  var section_label = null;
  var section_desc = null;
  if (_typeof(section_info) !== 'object') {
    section_id = section_info;
    section_label = section_info;
  } else {
    if (section_info['id']) {
      section_id = section_info['id'];
    }
    if (section_info['label']) {
      section_label = section_info['label'];
    }
    if (section_info['description']) {
      section_desc = section_info['description'];
    }
  }

  // Add header section.
  //var h3 = new html.tag('h3', {title: section_desc});
  var h3 = new html.tag('h3');
  var anc = null;
  if (section_desc) {
    // anc = new html.tag('a', {href: '#'}, section_label);
    anc = new html.tag('a', {
      href: '#',
      title: section_desc
    }, section_label);
  } else {
    anc = new html.tag('a', {
      href: '#'
    }, section_label);
  }
  h3.add_to(anc);
  this._div_stack.add_to(h3);
  var div = null;

  // Generate random id for the div.
  if (typeof add_id_p === 'undefined') {
    add_id_p = false;
  }
  if (add_id_p) {
    var rid = 'accordion-' + section_id + '-' + bbop.randomness(20);
    this._section_id_to_content_id[section_id] = rid;
    div = new html.tag('div', {
      'id': rid
    });
  } else {
    div = new html.tag('div');
  }

  // Add add content stub to section.
  var p = new html.tag('p', {}, bbop.to_string(content_blob));
  div.add_to(p);
  this._div_stack.add_to(div);
};

// // Add a section to the accordion.
// html.accordion.prototype.add_to_section = function(sect_id, content){
//     var cdiv = this._section_id_to_content_div[sect_id];
//     if( ! cdiv ){
// 	throw new Error('Cannot add to undefined section.');
//     }
// };

/*
 * Function: empty
 * 
 * Empty all sections from the accordion.
 * 
 * Parameters: n/a
 * 
 * Returns: n/a
 */
html.accordion.prototype.empty = function () {
  this._div_stack = new html.tag('div', this._attrs);
  this._section_id_to_content_id = {};
};

/*
 * Function: get_id
 * 
 * Return the id if extant, null otherwise.
 * 
 * Parameters: n/a
 * 
 * Returns: string or null
 */
html.accordion.prototype.get_id = function () {
  return this._div_stack.get_id();
};

/*
 * Function: get_section_id
 * 
 * Get the "real" section id by way of the "convenience" section id?
 * 
 * Parameters:
 *  sect_id - TODO ???
 * 
 * Returns: TODO ???
 */
html.accordion.prototype.get_section_id = function (sect_id) {
  return this._section_id_to_content_id[sect_id];
};

// // TODO: just empty the contents from an ided section.
// html.accordion.prototype.empty_section = function(sect_id){
//     var div = this._section_id_to_content_div[sect_id];
//     div.empty();
// };

/*
 * Namespace: html.list
 * 
 * Constructor: list
 * 
 * Create the a frame for an unordered list object.
 * 
 * :Input:
 * : [string/*.to_string(), ...]
 * :
 * :Output:
 * : <ul id="list">
 * :  <li>foo</li>
 * :   ...
 * : </ul>
 * 
 * Parameters:
 *  in_list - list of strings/html objects to be li separated
 *  attrs - *[optional]* attributes to apply to the new top-level ul
 * 
 * Returns:
 *  html.list object
 * 
 * Also see: <tag>
 */
html.list = function (in_list, attrs) {
  this._is_a = 'bbop-widget-set.html.list';

  // Arg check--attrs should be defined as something.
  if (!attrs) {
    attrs = {};
  }
  this._attrs = attrs;

  // Internal stack always starts with a ul.
  this._ul_stack = new html.tag('ul', this._attrs);
  var list_this = this;
  us.each(in_list, function (item) {
    list_this.add_to(item);
  });
};

/*
 * Function: to_string
 * 
 * Convert a list object into a html-ized string.
 * 
 * Parameters: n/a
 * 
 * Returns:
 *  string
 */
html.list.prototype.to_string = function () {
  return this._ul_stack.to_string();
};

/*
 * Function: add_to
 * 
 * Add a new li section to a list.
 * 
 * Optionally, it can take multiple arguments and will add each of
 * them to the new li tag in turn.
 * 
 * Parameters:
 *  item1 - another tag object or a string (html or otherwise)
 *  item2 - *[optional]* ...on forever
 * 
 * Returns: n/a
 */
html.list.prototype.add_to = function () {
  // Convert anonymous arguments into an Array.
  var args = Array.prototype.slice.call(arguments);

  // Cycle through and add them to the accumulator for the new li.
  var li_acc = [];
  us.each(args, function (arg) {
    li_acc.push(bbop.to_string(arg));
  });

  // Join them and add them to the stack of the encompassing ul.
  var li = new html.tag('li', {}, li_acc.join(" "));
  this._ul_stack.add_to(li);
};

/*
 * Function: empty
 * 
 * Remove all content (li's) from the list.
 * 
 * Parameters: n/a
 * 
 * Returns: n/a
 */
html.list.prototype.empty = function () {
  this._ul_stack = new html.tag('ul', this._attrs);
};

/*
 * Function: get_id
 * 
 * Return the id if extant, null otherwise.
 * 
 * Parameters: n/a
 * 
 * Returns: string or null
 */
html.list.prototype.get_id = function () {
  return this._ul_stack.get_id();
};

/*
 * Namespace: html.input
 * 
 * Constructor: input
 * 
 * Create a form input.
 * 
 * Parameters:
 *  attrs - *[optional]* the typical attributes to add
 * 
 * Returns:
 *  html.input object
 */
html.input = function (attrs) {
  this._is_a = 'bbop-widget-set.html.input';

  // Arg check--attrs should be defined as something.
  if (!attrs) {
    attrs = {};
  }
  this._attrs = attrs;

  // Internal stack always starts with a ul.
  this._input_stack = new html.tag('input', this._attrs);
};

/*
 * Function: to_string
 * 
 * Convert an input into a html-ized string.
 * 
 * Parameters: n/a
 * 
 * Returns:
 *  string
 */
html.input.prototype.to_string = function () {
  return this._input_stack.to_string();
};

/*
 * Function: add_to
 * 
 * Add content between the input tags.
 * 
 * Parameters:
 *  item - another tag object or a string (html or otherwise)
 * 
 * Returns: n/a
 */
html.input.prototype.add_to = function (item) {
  this._input_stack.add_to(bbop.to_string(item));
};

/*
 * Function: empty
 * 
 * Reset/remove all children.
 * 
 * Parameters: n/a
 * 
 * Returns: n/a
 */
html.input.prototype.empty = function () {
  this._input_stack = new html.tag('input', this._attrs);
};

/*
 * Function: get_id
 * 
 * Return the id if extant, null otherwise.
 * 
 * Parameters: n/a
 * 
 * Returns: string or null
 */
html.input.prototype.get_id = function () {
  return this._input_stack.get_id();
};

/*
 * Namespace: html.anchor
 * 
 * Constructor: anchor
 * 
 * Create an anchor object. Note: href, title, etc. go through
 * in_attrs.
 * 
 * Parameters:
 *  in_cont - the contents between the "a" tags
 *  in_attrs - *[optional]* the typical attributes to add
 * 
 * Returns:
 *  html.anchor object
 */
html.anchor = function (in_cont, in_attrs) {
  this._is_a = 'bbop-widget-set.html.anchor';

  // Arg check--attrs should be defined as something.
  this._attrs = in_attrs || {};

  // Internal stack always starts with a ul.
  this._anchor_stack = new html.tag('a', this._attrs, in_cont);
};

/*
 * Function: to_string
 * 
 * Convert an anchor object into a html-ized string.
 * 
 * Parameters: n/a
 * 
 * Returns:
 *  string
 */
html.anchor.prototype.to_string = function () {
  return this._anchor_stack.to_string();
};

/*
 * Function: add_to
 * 
 * Add content between the tags. Order of addition is order of output.
 * 
 * Parameters:
 *  item - another tag object or a string (html or otherwise)
 * 
 * Returns: n/a
 */
html.anchor.prototype.add_to = function (item) {
  this._anchor_stack.add_to(item);
};

/*
 * Function: empty
 * 
 * Remove all content between the tags.
 * 
 * Parameters: n/a
 * 
 * Returns: n/a
 */
html.anchor.prototype.empty = function () {
  this._anchor_stack.empty();
};

/*
 * Function: get_id
 * 
 * Return the id if extant, null otherwise.
 * 
 * Parameters: n/a
 * 
 * Returns: string or null
 */
html.anchor.prototype.get_id = function () {
  return this._anchor_stack.get_id();
};

/*
 * Namespace: html.image
 * 
 * Constructor: image
 * 
 * Create an image (img) object. Note: alt, title, etc. go through
 * in_attrs.
 * 
 * Parameters:
 *  in_attrs - *[optional]* the typical attributes to add
 * 
 * Returns:
 *  html.image object
 */
html.image = function (in_attrs) {
  this._is_a = 'bbop-widget-set.html.image';

  // Arg check--attrs should be defined as something.
  this._attrs = in_attrs || {};

  // Internal stack always starts with a ul.
  this._image_stack = new html.tag('img', this._attrs);
};

/*
 * Function: to_string
 * 
 * Convert an image object into a html-ized string.
 * 
 * Parameters: n/a
 * 
 * Returns:
 *  string
 */
html.image.prototype.to_string = function () {
  return this._image_stack.to_string();
};

/*
 * Function: add_to
 * 
 * Add content between the tags. Order of addition is order of output.
 * 
 * Parameters:
 *  item - another tag object or a string (html or otherwise)
 * 
 * Returns: n/a
 */
html.image.prototype.add_to = function (item) {
  this._image_stack.add_to(item);
};

/*
 * Function: empty
 * 
 * Remove all content between the tags.
 * 
 * Parameters: n/a
 * 
 * Returns: n/a
 */
html.image.prototype.empty = function () {
  this._image_stack.empty();
};

/*
 * Function: get_id
 * 
 * Return the id if extant, null otherwise.
 * 
 * Parameters: n/a
 * 
 * Returns: string or null
 */
html.image.prototype.get_id = function () {
  return this._image_stack.get_id();
};

/*
 * Namespace: html.table
 * 
 * Constructor: table
 * 
 * Create a simple table structure.
 * in_headers is necessary, but can be empty.
 * in_entries is necessary, but can be empty.
 * 
 * Parameters:
 *  in_headers - ordered list of headers
 *  in_entries - lists of lists of entry items
 *  in_attrs - *[optional]* the typical attributes to add to the table
 * 
 * Returns:
 *  html.table object
 */
html.table = function (in_headers, in_entries, in_attrs) {
  this._is_a = 'bbop-widget-set.html.table';

  // Arg check--attrs should be defined as something.
  var headers = in_headers || [];
  var entries = in_entries || [];
  this._attrs = in_attrs || {};

  // Row class count.
  this._count = 0;

  // Internal stack always starts with a table.
  this._table_stack = new html.tag('table', this._attrs);

  // Only add headers if they exist.
  if (!us.isEmpty(headers)) {
    var head_row = new html.tag('tr');
    us.each(headers, function (header) {
      var th = new html.tag('th');
      th.add_to(header);
      head_row.add_to(th);
    });
    var head_stack = new html.tag('thead');
    head_stack.add_to(head_row);
    this._table_stack.add_to(head_stack);
  }

  // Add incoming rows to the body. Keep the body stack around for
  // bookkeeping.
  this._body_stack = new html.tag('tbody');
  this._table_stack.add_to(this._body_stack);
  var this_table = this;
  us.each(entries, function (item) {
    this_table.add_to(item);
  });
};

/*
 * Function: to_string
 * 
 * Convert a table object into a html-ized string.
 * 
 * Parameters: n/a
 * 
 * Returns:
 *  string
 */
html.table.prototype.to_string = function () {
  return this._table_stack.to_string();
};

/*
 * Function: add_to
 * 
 * Add data row. The entries argument is coerced into an array of tds.
 * 
 * Parameters:
 *  entries - lists of lists of entry items
 * 
 * Returns: n/a
 */
html.table.prototype.add_to = function (entries) {
  //this._body_stack = new html.tag('tbody');

  // Get the class for the row.
  var row_class = 'odd_row';
  if (this._count % 2 === 0) {
    row_class = 'even_row';
  }
  this._count = this._count + 1;
  var tr = new html.tag('tr', {
    'class': row_class
  });

  // Array or not, add everything as tds.
  if (!us.isArray(entries)) {
    entries = [entries];
  }
  us.each(entries, function (entry) {
    var td = new html.tag('td');
    td.add_to(entry);
    tr.add_to(td);
  });
  this._body_stack.add_to(tr);
};

/*
 * Function: empty
 * 
 * Headers do not get wiped, just the data rows in the tbody.
 * 
 * Parameters: n/a
 * 
 * Returns: n/a
 */
html.table.prototype.empty = function () {
  this._count = 0;
  this._body_stack.empty();
};

/*
 * Function: get_id
 * 
 * Return the id if extant, null otherwise.
 * 
 * Parameters: n/a
 * 
 * Returns: string or null
 */
html.table.prototype.get_id = function () {
  return this._table_stack.get_id();
};

/*
 * Namespace: html.button
 * 
 * Constructor: button
 * 
 * Create a button object.
 * For after-the-fact decoration, take a look at:
 * <https://jquery-ui.googlecode.com/svn/tags/1.6rc5/tests/static/icons.html>
 * 
 * Parameters:
 *  in_label - label
 *  in_attrs - *[optional]* the typical attributes to add
 * 
 * Returns:
 *  html.button object
 */
html.button = function (in_label, in_attrs) {
  this._is_a = 'bbop-widget-set.html.button';

  // Arg check--attrs should be defined as something.
  this._attrs = in_attrs || {};

  // Internal stack is just the top-level button.
  this._button_stack = new html.tag('button', this._attrs, in_label);
};

/*
 * Function: to_string
 * 
 * Convert a button object into a html-ized string.
 * 
 * Parameters: n/a
 * 
 * Returns:
 *  string
 */
html.button.prototype.to_string = function () {
  return this._button_stack.to_string();
};

/*
 * Function: add_to
 * 
 * Add content between the tags. Order of addition is order of output.
 * Not really worth much as it just equates to changing the label.
 * 
 * Parameters:
 *  item - another tag object or a string (html or otherwise)
 * 
 * Returns: n/a
 */
html.button.prototype.add_to = function (item) {
  this._button_stack.add_to(item);
};

/*
 * Function: empty
 * 
 * Remove all content between the tags. This equates to removing the
 * label.
 * 
 * Parameters: n/a
 * 
 * Returns: n/a
 */
html.button.prototype.empty = function () {
  this._button_stack.empty();
};

/*
 * Function: get_id
 * 
 * Return the id if extant, null otherwise.
 * 
 * Parameters: n/a
 * 
 * Returns: string or null
 */
html.button.prototype.get_id = function () {
  return this._button_stack.get_id();
};

/*
 * Namespace: html.span
 * 
 * Constructor: span
 * 
 * Create a span object.
 * Fun for calling live bits after the fact.
 * 
 * Parameters:
 *  in_label - label
 *  in_attrs - *[optional]* the typical attributes to add
 * 
 * Returns:
 *  html.span object
 */
html.span = function (in_label, in_attrs) {
  this._is_a = 'bbop-widget-set.html.span';

  // Arg check--attrs should be defined as something.
  this._attrs = in_attrs || {};

  // Internal stack is just the top-level span.
  this._span_stack = new html.tag('span', this._attrs, in_label);
};

/*
 * Function: to_string
 * 
 * Convert a span object into a html-ized string.
 * 
 * Parameters: n/a
 * 
 * Returns:
 *  string
 */
html.span.prototype.to_string = function () {
  return this._span_stack.to_string();
};

/*
 * Function: add_to
 * 
 * Add content between the tags. Order of addition is order of output.
 * Not really worth much as it just equates to changing the label.
 * 
 * Parameters:
 *  item - another tag object or a string (html or otherwise)
 * 
 * Returns: n/a
 */
html.span.prototype.add_to = function (item) {
  this._span_stack.add_to(item);
};

/*
 * Function: empty
 * 
 * Remove all content between the tags. This equates to removing the
 * label.
 * 
 * Parameters: n/a
 * 
 * Returns: n/a
 */
html.span.prototype.empty = function () {
  this._span_stack.empty();
};

/*
 * Function: get_id
 * 
 * Return the id if extant, null otherwise.
 * 
 * Parameters: n/a
 * 
 * Returns: string or null
 */
html.span.prototype.get_id = function () {
  return this._span_stack.get_id();
};

/*
 * Namespace: html.collapsible
 * 
 * Constructor: collapsible
 * 
 * Create the a frame for the functional part of a jQuery collapsible
 * structure.
 * 
 * :Input:
 * : [[title, string/*.to_string()], ...]
 * :
 * :Output:
 * :<div class="panel-group" id="accordion">
 * : <div class="panel panel-default">
 * :  <div class="panel-heading">
 * :   <h4 class="panel-title">
 * :    <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne">
 * :     ...
 * :    </a>
 * :   </h4>
 * :  </div>
 * :  <div id="collapseOne" class="panel-collapse collapse in">
 * :   <div class="panel-body">
 * :    ...
 * :   </div>
 * :  </div>
 * : </div>
 * : ...
 * 
 * Parameters:
 *  in_list - collapsible frame headers: [[title, string/*.to_string()], ...]
 *  attrs - *[serially optional]* attributes to apply to the new top-level div
 * 
 * Returns:
 *  html.collapsible object
 * 
 * Also see: <tag>
 */
html.collapsible = function (in_list, attrs) {
  this._is_a = 'bbop-widget-set.html.collapsible';

  // Arg check--attrs should be defined as something.
  this._attrs = attrs || {};

  // We must add 'panel-group' to the class list.
  if (this._attrs['class']) {
    this._attrs['class'] = this._attrs['class'] + ' panel-group';
  } else {
    this._attrs['class'] = 'panel-group';
  }

  // An id is necessary, and needs to be generated up front for
  // reference.
  this._cid = null;
  if (!this._attrs['id']) {
    this._attrs['id'] = 'gen_id-bbop-html-clps-' + bbop.randomness(20);
  }
  this._cid = this._attrs['id'];

  // Internal stack always starts with a div.
  this._div_stack = new html.tag('div', this._attrs);
  this._section_id_to_content_id = {};

  // Iterate over the incoming argument list.
  var collapsible_this = this;
  us.each(in_list, function (item) {
    var sect_title = item[0];
    var content = item[1];
    collapsible_this.add_to(sect_title, content);
  });
};

/*
 * Function: to_string
 * 
 * Convert the collapsible object into a html-ized string.
 * 
 * Parameters: n/a
 * 
 * Returns:
 *  string
 */
html.collapsible.prototype.to_string = function () {
  return this._div_stack.to_string();
};

/*
 * Function: add_to
 * 
 * Add a contect section to the collapsible.
 * 
 * Parameters:
 *  section_info - a string or a hash with 'id', 'label', and 'description'
 *  content_blob - string or html object to put in a section
 * 
 * Returns: n/a
 */
html.collapsible.prototype.add_to = function (section_info, content_blob) {
  // If section_info isn't an object, assume it is a string and
  // use it for everything.
  var section_id = null;
  var section_label = null;
  var section_desc = null;
  if (_typeof(section_info) !== 'object') {
    // is a string
    section_id = section_info;
    section_label = section_info;
  } else {
    if (section_info['id']) {
      section_id = section_info['id'];
    }
    if (section_info['label']) {
      section_label = section_info['label'];
    }
    if (section_info['description']) {
      section_desc = section_info['description'];
    }
  }

  // Section ID and bookkeeping.
  var coll_id = 'collapsible-' + section_id + '-' + bbop.randomness(20);
  var cont_id = 'content-' + section_id + '-' + bbop.randomness(20);
  this._section_id_to_content_id[section_id] = cont_id;

  // Inner-most header structure: label.
  //    <a data-toggle="collapse" data-parent="#this._cid" href="#cont_id">
  var title_a_attrs = {
    'data-toggle': 'collapse',
    'data-parent': '#' + this._cid,
    'href': '#' + coll_id
  };
  // Cannot be null in assembly.
  if (section_desc) {
    title_a_attrs['title'] = section_desc;
  }
  var title_a = new html.tag('a', title_a_attrs, section_label);

  //   <h4 class="panel-title">
  var h4_attrs = {
    'class': 'panel-title'
  };
  var h4 = new html.tag('h4', h4_attrs, title_a);

  // Complete the panel heading.
  //  <div class="panel-heading">
  var divh_attrs = {
    'class': 'panel-heading'
  };
  var divh = new html.tag('div', divh_attrs, h4);

  // Add the panel body.
  //    <div class="panel-body">
  var body_attrs = {
    'class': 'panel-body',
    'style': 'overflow-x: auto;',
    // emergency overflow scrolling
    'id': cont_id
  };
  var body = new html.tag('div', body_attrs, content_blob);

  // Add the collapsing frame around the panel body.
  //  <div id="collapseOne" class="panel-collapse collapse in">
  var divb_attrs = {
    'class': 'panel-collapse collapse',
    'id': coll_id
  };
  var divb = new html.tag('div', divb_attrs, body);

  // Add both to the local panel container.
  // <div class="panel panel-default">
  var divp_attrs = {
    'class': 'panel panel-default'
  };
  var divp = new html.tag('div', divp_attrs, [divh, divb]);

  //
  this._div_stack.add_to(divp);
};

/*
 * Function: empty
 * 
 * Empty all sections from the collapsible.
 * 
 * Parameters: n/a
 * 
 * Returns: n/a
 */
html.collapsible.prototype.empty = function () {
  this._div_stack = new html.tag('div', this._attrs);
  this._section_id_to_content_id = {};
};

/*
 * Function: get_id
 * 
 * Return the id if extant, null otherwise.
 * 
 * Parameters: n/a
 * 
 * Returns: string or null
 */
html.collapsible.prototype.get_id = function () {
  return this._div_stack.get_id();
};

/*
 * Function: get_section_id
 * 
 * Get the "real" section id by way of the "convenience" section id?
 * 
 * Parameters:
 *  sect_id - TODO ???
 * 
 * Returns: TODO ???
 */
html.collapsible.prototype.get_section_id = function (sect_id) {
  return this._section_id_to_content_id[sect_id];
};

///
/// Exportable body.
///

module.exports = html;

},{"bbop-core":26,"underscore":108}],18:[function(require,module,exports){
(function (global){(function (){
/*
 * Package: live_filters.js
 * 
 * Namespace: bbop-widget-set.live_filters
 * 
 * BBOP JS object to allow the live probing of a GOlr personality.
 * 
 * Very much like a separated accordion and filter from the search
 * pane.
 * 
 * This is a Bootstrap 3 widget.
 * 
 * See Also:
 *  <search_pane.js>
 *  <live_search.js>
 */

var us = require('underscore');
var bbop = require('bbop-core');
var html = require('./html');
var display = require('./display');
var generators = require('./generators');
//var clickable_object_generator = require('./display/clickable_object_generator');

// Code here will be ignored by JSHint, as we are technically
// "redefining" jQuery (although we are not).
/* jshint ignore:start */
var jQuery = typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null;
//require('jquery-ui');
/* jshint ignore:end */

/*
 * Constructor: live_filters
 * 
 * Contructor for the bbop-widget-set.live_filters object.
 * 
 * Widget interface to interactively explore a search personality with
 * no direct side effects.
 *
 * Arguments:
 *  interface_id - string id of the element to build on
 *  manager - the shared GOlr manager to use
 *  golr_conf_obj - the profile of the specific 
 *  in_argument_hash - *[optional]* optional hash of optional arguments
 * 
 * Returns:
 *  this object
 */
var live_filters = function live_filters(interface_id, manager, golr_conf_obj, in_argument_hash) {
  this._is_a = 'bbop-widget-set.live_filters';
  var anchor = this;
  var each = us.each;

  // TODO/BUG: Remove the need for these.
  var ui_icon_positive_label = '&plus;';
  var ui_icon_positive_source = null;
  var ui_icon_negative_label = '&minus;';
  var ui_icon_negative_source = null;
  var ui_icon_remove_label = '&minus;';
  var ui_icon_remove_source = null;
  var ui_spinner_shield_source = null;
  var ui_spinner_shield_message = '';

  // Per-UI logger.
  var logger = new bbop.logger();
  logger.DEBUG = false;
  //logger.DEBUG = true;
  function ll(str) {
    logger.kvetch('LF: ' + str);
  }

  ///
  /// Deal with incoming arguments.
  ///

  // this._class_conf = golr_conf_obj;

  // Our argument default hash.
  var default_hash = {
    'meta_label': 'Documents:&nbsp;',
    'display_meta_p': true,
    'display_free_text_p': true,
    'free_text_placeholder': 'Free-text filter',
    'display_accordion_p': true,
    'on_update_callback': function on_update_callback() {}
  };
  var folding_hash = in_argument_hash || {};
  var arg_hash = bbop.fold(default_hash, folding_hash);
  // 
  this._interface_id = interface_id;
  this._display_meta_p = arg_hash['display_meta_p'];
  this._meta_label = arg_hash['meta_label'];
  this._display_free_text_p = arg_hash['display_free_text_p'];
  this._free_text_placeholder = arg_hash['free_text_placeholder'];
  this._display_accordion_p = arg_hash['display_accordion_p'];
  this._on_update_callback = arg_hash['on_update_callback'];

  ///
  /// Prepare the interface and setup the div hooks.
  ///

  anchor._established_p = false;

  // Mangle everything around this unique id so we don't collide
  // with other instances on the same page.
  var ui_div_id = this._interface_id;
  var mangle = ui_div_id + '_ui_element_' + bbop.uuid() + '_';

  // Main div id hooks to the easily changable areas of the display.
  var container_div_id = mangle + 'container-id';
  // Meta hooks.
  var meta_div_id = mangle + 'meta-id';
  var meta_count_id = mangle + 'meta-count-id';
  var meta_wait_id = mangle + 'meta-wait-id';
  // Query hooks
  var query_input_div_id = mangle + 'query-id';
  // Sticky hooks.
  var sticky_filters_div_id = mangle + 'sticky_filters-id';
  var sticky_title_id = mangle + 'sticky_filters-title-id';
  var sticky_content_id = mangle + 'sticky_filters-content-id';
  // Current hooks.
  var current_filters_div_id = mangle + 'current_filters-id';
  var current_title_id = mangle + 'current_filters-title-id';
  var current_content_id = mangle + 'current_filters-content-id';
  var clear_user_filter_span_id = mangle + 'clear-user-filter-id';
  // Accordion hooks.
  var filters_div_id = mangle + 'ui-filters-wrapper';
  var clear_query_span_id = mangle + 'clear-query-id';
  // var ui_user_button_div_id = mangle + 'user-button-id';
  // var ui_results_table_div_id = mangle + 'results-table-id';
  // var ui_count_control_div_id = mangle + 'count_control-id';

  // Blow away whatever was there completely.
  // Render a control section into HTML. This includes the accordion
  // and current filter sections.
  // Get the user interface hook and remove anything that was there.
  var container_div = new html.tag('div', {
    'id': container_div_id
  });
  jQuery('#' + ui_div_id).empty();
  jQuery('#' + ui_div_id).append(container_div.to_string());

  // // Globally declared (or not) icons.
  // var ui_spinner_search_source = '';
  // var ui_spinner_shield_source = '';
  // var ui_spinner_shield_message = null;
  // var ui_icon_positive_label = '';
  // var ui_icon_positive_source = '';
  // var ui_icon_negative_label = '';
  // var ui_icon_negative_source = '';
  // var ui_icon_remove_label = '';
  // var ui_icon_remove_source = '';

  // // The spinner, if it exists, needs to be accessible by everybody
  // // and safe to use.
  // var spinner = null;
  // function _spinner_gen(elt_id){
  // 	var spinner_args = {
  // 	    //timeout: 5,
  // 	    //timeout: 500,
  // 	    timeout: 10,
  // 	    //classes: 'bbop-widget-search_pane-spinner',
  // 	    visible_p: false
  // 	};
  // 	spinner = new widget.spinner(elt_id,
  // 					  ui_spinner_search_source,
  // 					  spinner_args);
  // }

  // // Additional id hooks for easy callbacks. While these are not as
  // // easily changable as the above, we use them often enough and
  // // across functions to have a hook.
  // var accordion_div_id = mangle + 'filter-accordion-id';

  // // These pointers are used in multiple functions (e.g. both
  // // *_setup and *_draw).
  var filter_accordion_widget = null;
  var spinner_div = null;
  // //var current_filters_div = null;

  function _spin_up() {
    if (spinner_div) {
      jQuery('#' + spinner_div.get_id()).removeClass('hidden');
      jQuery('#' + spinner_div.get_id()).addClass('active');
    }
  }
  function _spin_down() {
    if (spinner_div) {
      jQuery('#' + spinner_div.get_id()).addClass('hidden');
      jQuery('#' + spinner_div.get_id()).removeClass('active');
    }
  }

  /*
   * Function: spin_up
   * 
   * Turn on the spinner.
   * 
   * Parameters:
   *  n/a
   * 
   * Returns
   *  n/a
   */
  this.spin_up = function () {
    _spin_up();
  };

  /*
   * Function: spin_down
   * 
   * Turn off the spinner.
   * 
   * Parameters:
   *  n/a
   * 
   * Returns
   *  n/a
   */
  this.spin_down = function () {
    _spin_down();
  };

  /*
   * Function: established_p
   * 
   * Return whether or not the display has actually been
   * established.
   * 
   * Parameters:
   *  n/a
   * 
   * Returns
   *  boolean
   */
  this.established_p = function () {
    return anchor._established_p;
  };

  /*
   * Function: establish_display
   * 
   * Completely redraw the display.
   * 
   * Required to display after setting up the manager.
   * 
   * Also may be useful after a major change to the manager to reset
   * it.
   * 
   * Parameters:
   *  n/a
   * 
   * Returns
   *  n/a
   */
  this.establish_display = function () {
    // Can only make a display if there is a set
    // personality--there is no general default and it is an
    // error.
    var personality = manager.get_personality();
    var cclass = golr_conf_obj.get_class(personality);
    if (!personality || !cclass) {
      ll('ERROR: no usable personality set: ' + personality);
      throw new Error('ERROR: no useable personality set: ' + personality);
    }

    ///
    /// Setup the UI base.
    ///

    // Holder for things like spinner and current number of
    // results.
    this.setup_meta = function () {
      ll('setup_meta for: ' + meta_div_id);

      // Count area.
      var ms_attrs = {
        id: meta_count_id,
        //'class': 'label label-default pull-right'
        //'class': 'label label-default'
        'class': 'badge'
      };
      var ms = new html.tag('span', ms_attrs, 'n/a');

      // Get a progress bar assembled.
      var inspan = new html.tag('span', {
        'class': 'sr-only'
      }, '...');
      var indiv = new html.tag('div', {
        'class': 'progress-bar',
        'role': 'progressbar',
        'aria-valuenow': '100',
        'aria-valuemin': '0',
        'aria-valuemax': '100',
        'style': 'width: 100%;'
      }, inspan);
      spinner_div = new html.tag('div', {
        'generate_id': true,
        'class': 'progress progress-striped active pull-right',
        'style': 'width: 3em;'
      }, indiv);

      // The container area; add in the label and count.
      var mdiv_args = {
        'class': 'well well-sm',
        'id': meta_div_id
      };
      var mdiv = new html.tag('div', mdiv_args, [this._meta_label, ms, spinner_div]);
      jQuery('#' + container_div.get_id()).append(mdiv.to_string());
    };
    if (this._display_meta_p) {
      this.setup_meta();
    }

    // Setup the free text query display under contructed tags for
    // later population.
    // 
    // If no icon_clear_source is defined, icon_clear_label will be
    // used as the defining text.
    this.setup_query = function () {
      ll('setup_query for: ' + query_input_div_id);

      // // Some defaults.
      // if( ! label_str ){ label_str = ''; }
      // // if( ! icon_clear_label ){ icon_clear_label = ''; }
      // // if( ! icon_clear_source ){ icon_clear_source = ''; }

      // The incoming label.
      var query_label_attrs = {
        //'class': 'bbop-js-search-pane-query-label'
      };
      var query_label_div = new html.tag('div', query_label_attrs);

      // The text area.
      var ta_args = {
        //'class': 'bbop-js-search-pane-textarea',
        'placeholder': this._free_text_placeholder,
        'class': 'form-control bbop-js-live-filters-textarea',
        //'style': 'height: 1em;',
        'rows': '1',
        'id': query_input_div_id
      };
      var query_area = new html.tag('textarea', ta_args);

      // Figure out an icon or a label.
      var clear_query_obj = generators.clickable_object(null);

      // And a div to put it in.
      var clear_div_attrs = {
        //'class': 'bbop-js-search-pane-clear-button',
        'generate_id': true
      };
      var clear_div = new html.tag('div', clear_div_attrs, clear_query_obj);

      // General container div.
      // NOTE/TODO: this is just a half panel--just wanted spacing.
      var gen_div_attrs = {
        'class': 'panel panel-default',
        'generate_id': true
      };
      var gen_div = new html.tag('div', gen_div_attrs);

      // Add to display.
      query_label_div.add_to(clear_div.to_string());
      gen_div.add_to(query_label_div.to_string());
      gen_div.add_to(query_area.to_string());
      jQuery('#' + container_div.get_id()).append(gen_div.to_string());
    };
    if (this._display_free_text_p) {
      this.setup_query();
    }

    // Setup sticky filters display under contructed tags for later
    // population. The seeding information is coming in through the
    // GOlr conf class.
    this.setup_sticky_filters = function () {
      ll('setup_sticky_filters UI for class configuration: ' + cclass.id());

      // var stitle_attrs = {
      // 	'class': 'panel panel-heading',
      // 	'id': sticky_title_id
      // };
      // var stitle =
      // 	new html.tag('div', stitle_attrs,
      // 			  'No applied sticky filters');

      var scont_attrs = {
        'class': 'panel-body',
        'id': sticky_content_id
      };
      var scont = new html.tag('div', scont_attrs, 'No applied sticky filters');
      var sticky_filters_attrs = {
        'class': 'panel panel-default',
        'id': sticky_filters_div_id
      };
      var sticky_filters_div =
      //new html.tag('div', sticky_filters_attrs, [stitle, scont]);
      new html.tag('div', sticky_filters_attrs, scont);

      // Add the output to the page.
      var sticky_filters_str = sticky_filters_div.to_string();
      jQuery('#' + container_div.get_id()).append(sticky_filters_str);
    };
    // Setup current filters display under contructed tags for later
    // population. The seeding information is coming in through the
    // GOlr conf class.
    // 
    // Add in the filter state up here.
    // 
    // If no icon_reset_source is defined, icon_reset_label will be
    // used as the defining text.
    this.setup_current_filters = function () {
      ll('setup_current_filters UI for class configuration: ' + cclass.id());
      var ccont_attrs = {
        'class': 'panel-body',
        'id': current_content_id
      };
      var ccont = new html.tag('div', ccont_attrs, 'No applied user filters');
      var current_filters_attrs = {
        'class': 'panel panel-default',
        'id': current_filters_div_id
      };
      var current_filters_div =
      //new html.tag('div', current_filters_attrs, [stitle, scont]);
      new html.tag('div', current_filters_attrs, ccont);

      // Add the output to the page.
      var current_filters_str = current_filters_div.to_string();
      jQuery('#' + container_div.get_id()).append(current_filters_str);
    };
    // Setup the accordion skeleton under contructed tags for later
    // population. The seeding information is coming in through the
    // GOlr conf class.
    // Start building the accordion here. Not an updatable part.
    // 
    // If no icon_*_source is defined, icon_*_label will be
    // used as the defining text.
    this.setup_accordion = function () {
      ll('setup_accordion UI for class configuration: ' + cclass.id());
      var filter_accordion_attrs = {
        id: filters_div_id
      };
      filter_accordion_widget =
      // heavy lifting by special widget
      new html.collapsible([], filter_accordion_attrs);

      // Add the sections with no contents as a skeleton to be
      // filled by draw_accordion.
      var field_list = cclass.field_order_by_weight('filter');
      each(field_list, function (in_field) {
        ll('saw field: ' + in_field);
        var ifield = cclass.get_field(in_field);
        var in_attrs = {
          id: in_field,
          label: ifield.display_name(),
          description: ifield.description()
        };
        filter_accordion_widget.add_to(in_attrs, '', true);
      });

      // Add the output from the accordion to the page.
      var accordion_str = filter_accordion_widget.to_string();
      jQuery('#' + container_div_id).append(accordion_str);
    };
    if (this._display_accordion_p) {
      this.setup_current_filters();
      this.setup_sticky_filters();
      this.setup_accordion();
    }

    ///
    /// Define the drawing callbacks, as well as the action hooks.
    ///

    /*
     * Function: draw_meta
     *
     * Draw meta results. Includes selector for drop down.
     * 
     * (Re)draw the count control with the current information in the
     * manager. This also tries to set the selector to the response
     * number (to keep things in sync), unbinds any current "change"
     * event, and adds a new change event.
     * 
     * Parameters:
     *  response - the <bbop.golr.response> returned from the server
     *  manager - <bbop.golr.manager> that we initially registered with
     *
     * Returns:
     *  n/a
     */
    this.draw_meta = function (response, manager) {
      ll('draw_meta for: ' + meta_div_id);

      // Collect numbers for display.
      var total_c = response.total_documents();

      // Draw meta; the current numbers and page--the same for
      // every type of return.
      // var ms_attrs = {
      // 	//'class': 'label label-default pull-right'
      // 	'class': 'label label-default'
      // };
      // var ms = new html.tag('div', ms_attrs, total_c);
      jQuery('#' + meta_count_id).empty();
      jQuery('#' + meta_count_id).append(total_c);
      // if( total_c === 0 ){
      // 	jQuery('#' + meta_div_id).append('No results found.');
      // }else{
      // }
      // jQuery('#' + meta_div_id).append(ms.to_string());
    };
    if (this._display_meta_p) {
      manager.register('search', this.draw_meta, -1, 'meta_first');
    }

    // Detect whether or not a keyboard event is ignorable.
    function _ignorable_event(event) {
      var retval = false;
      if (event) {
        var kc = event.keyCode;
        if (kc) {
          if (kc === 39 ||
          // right
          kc === 37 ||
          // left
          kc === 32 ||
          // space
          kc === 20 ||
          // ctl?
          kc === 17 ||
          // ctl?
          kc === 16 ||
          // shift
          kc === 0) {
            // super
            ll('ignorable key event: ' + kc);
            retval = true;
            // }else if( kc ===  8 ){ // delete; special handling
            //     if( anchor.query_field_text().length < 3 ){
            // 	retval = false;
            //     }
          }
        }
      }
      return retval;
    }

    /*
     * Function: draw_query
     *
     * Draw the query widget. This function makes it active
     * as well.
     * 
     * Clicking the reset button will reset the query to ''.
     * 
     * NOTE: Since this is part of the "persistant" interface (i.e. it
     * does not get wiped after every call), we make sure to clear the
     * event listeners when we redraw the function to prevent them from
     * building up.
     * 
     * Parameters:
     *  response - the <bbop.golr.response> returned from the server
     *  manager - <bbop.golr.manager> that we initially registered with
     *
     * Returns:
     *  n/a
     */
    this.draw_query = function (response, manager) {
      ll('draw_query for: ' + query_input_div_id);

      // Add a smartish listener.
      jQuery('#' + query_input_div_id).unbind('keyup');
      jQuery('#' + query_input_div_id).keyup(function (event) {
        // If we're left with a legitimate event, handle it.
        if (!_ignorable_event(event)) {
          // Can't ignore it anymore, so it goes into the
          // manager for testing.
          var tmp_q = manager.get_query();
          var input_text = jQuery(this).val();
          manager.set_query(input_text);

          // If the manager feels like it's right, trigger.
          if (manager.sensible_query_p()) {
            ll('keeping set query: ' + input_text);
            // Set the query to be more "usable" just
            // before triggering (so the tests can't be
            // confused by our switch).
            if (input_text === '') {
              manager.set_comfy_query(manager.get_fundamental_query());
            } else {
              manager.set_comfy_query(input_text);
            }
            manager.search();

            // We are now searching--show it.
            _spin_up();
          } else {
            ll('rolling back query: ' + tmp_q);
            manager.set_query(tmp_q);
          }
        }
      });

      // Now reset the clear button and immediately set the event.
      jQuery('#' + clear_query_span_id).unbind('click');
      jQuery('#' + clear_query_span_id).click(function () {
        manager.reset_query();
        //anchor.set_query_field(manager.get_query());
        manager.set_query_field('');
        manager.search();
        // We are now searching--show it.
        _spin_up();
      });
    };
    if (this._display_free_text_p) {
      manager.register('search', this.draw_query, 0, 'query_first');
    }

    /*
     * Function: draw_accordion
     *
     * (Re)draw the information in the accordion controls/filters.
     * This function makes them active as well.
     * 
     * Parameters:
     *  response - the <bbop.golr.response> returned from the server
     *  manager - <bbop.golr.manager> that we initially registered with
     *
     * Returns:
     *  n/a
     */
    this.draw_accordion = function (response, manager) {
      ll('draw_accordion for: ' + filters_div_id);

      //
      // Make sure that accordion has already been inited.
      if (typeof filter_accordion_widget === 'undefined') {
        throw new Error('Need to init accordion widget to use it.');
      }

      // We'll need this in a little bit for calculating when to
      // display the "more" option for the field filters.
      var real_facet_limit = manager.get_facet_limit();
      var curr_facet_limit = real_facet_limit - 1; // the facets we'll show

      // We want this so we can filter out any facets that have the
      // same count as the current response total--these facets are
      // pretty much information free.
      var total_docs = response.total_documents();

      // A helper function for when no filters are
      // displayed.
      function _nothing_to_see_here(in_field) {
        var section_id = filter_accordion_widget.get_section_id(in_field);
        jQuery('#' + section_id).empty();
        jQuery('#' + section_id).append('Nothing to filter.');
      }

      // Hash where we collect our button information.
      // button_id -> [source, filter, count, polarity];
      var button_hash = {};

      // And a hash to store information to be able to generate the
      // complete filter shields.
      // span_id -> filter_id
      var overflow_hash = {};

      // Cycle through each facet field; all the items in each,
      // create the lists and buttons (while collectong data useful
      // in creating the callbacks) and put them into the accordion.
      each(response.facet_field_list(), function (in_field) {
        var facet_bd = response.facet_field(in_field);
        if (us.isEmpty(facet_bd)) {
          // No filters means nothing in the box.
          _nothing_to_see_here(in_field);
        } else {
          // Create ul lists of the facet contents.
          var tbl_id = mangle + 'filter-list-' + in_field;
          var facet_list_tbl_attrs = {
            'class': 'table table-hover table-striped table-condensed bbop-widget-set-live-filters-table',
            'id': tbl_id
          };
          var facet_list_tbl = new html.table([], [], facet_list_tbl_attrs);
          ll("consider:" + in_field + ": " + response.facet_field(in_field).length);

          // BUG/TODO:
          // Count the number of redundant (not shown)
          // facets so we can at least give a face to this
          // bug/problem.
          // Also filter out "empty filters".
          var redundant_count = 0;
          // Now go through and get filters and counts.
          var good_count = 0; // only count when good
          var overflow_p = false; // true when at 24 -> 25
          each(response.facet_field(in_field), function (ff_field, ff_index) {
            // Pull out info early so we can test it
            // for information content.
            var f_name = ff_field[0];
            var f_count = ff_field[1];

            // ll(in_field + ": " + f_name + ": " +
            // 	 [f_count,
            // 	  total_docs,
            // 	  ff_index,
            // 	  good_count,
            // 	  redundant_count,
            // 	  real_facet_limit].join(', '));

            // TODO: The field is likely redundant
            // (BUG: not always true in closures),
            // so eliminate it.
            if (f_count === total_docs) {
              //ll("\tnothing here");
              redundant_count++;
            } else if (!f_name || f_name === "") {
              // Straight out skip if it is an
              // "empty" facet field.
            } else if (ff_index < real_facet_limit - 1) {
              //ll("\tgood row");
              good_count++;

              // Create buttons and store them for later
              // activation with callbacks to
              // the manager.
              var b_plus = new html.button(ui_icon_positive_label, {
                'generate_id': true,
                'type': 'button',
                'class': 'btn btn-success btn-xs'
              });
              var b_minus = new html.button(ui_icon_negative_label, {
                'generate_id': true,
                'type': 'button',
                'class': 'btn btn-danger btn-xs'
              });

              // Store in hash for later keying to
              // event.
              button_hash[b_plus.get_id()] = [in_field, f_name, f_count, '+'];
              button_hash[b_minus.get_id()] = [in_field, f_name, f_count, '-'];

              // // Add the label and buttons to the
              // // appropriate ul list.
              //facet_list_ul.add_to(
              // fstr,b_plus.to_string(),
              //   b_minus.to_string());
              // Add the label and buttons to the table.
              facet_list_tbl.add_to([b_plus.to_string(), b_minus.to_string(), '(' + f_count + ')', f_name]);
            }

            // This must be logically separated from
            // the above since we still want to show
            // more even if all of the top 25 are
            // redundant.
            if (ff_index === real_facet_limit - 1) {
              // Add the more button if we get up to
              // this many facet rows. This should
              // only happen on the last possible
              // iteration.

              overflow_p = true;
              //ll( "\tadd [more]");

              // Since this is the overflow item,
              // add a span that can be clicked on
              // to get the full filter list.
              //ll("Overflow for " + in_field);
              var b_over = new html.button('more...', {
                'generate_id': true,
                'type': 'button',
                'title': 'Display the complete list',
                'class': 'btn btn-primary btn-xs'
              });
              facet_list_tbl.add_to([b_over.to_string(), '', '']);
              overflow_hash[b_over.get_id()] = in_field;
            }
          });

          // There is a case when we have filtered out all
          // avilable filters (think db source).
          if (good_count === 0 && !overflow_p) {
            _nothing_to_see_here(in_field);
          } else {
            // Otherwise, now add the ul to the
            // appropriate section of the accordion in
            // the DOM.
            var sect_id = filter_accordion_widget.get_section_id(in_field);
            jQuery('#' + sect_id).empty();

            // TODO/BUG:
            // Give warning to the redundant facets.
            var warn_txt = null;
            if (redundant_count === 1) {
              warn_txt = "field is";
            } else if (redundant_count > 1) {
              warn_txt = "fields are";
            }
            if (warn_txt) {
              jQuery('#' + sect_id).append("<small> The top (" + redundant_count + ") redundant " + warn_txt + " not shown" + "</small>");
            }

            // Add facet table.
            var final_tbl_str = facet_list_tbl.to_string();
            jQuery('#' + sect_id).append(final_tbl_str);
          }
        }
      });

      // Okay, now introducing a function that we'll be using a
      // couple of times in our callbacks. Given a button id (from
      // a button hash) and the [field, filter, count, polarity]
      // values from the props, make a button-y thing an active
      // filter.
      function filter_select_live(create_time_button_props, button_id) {
        //var bid = button_id;
        //var in_field = create_time_button_props[0];	 
        //var in_filter = create_time_button_props[1];
        //var in_count = create_time_button_props[2];
        var in_polarity = create_time_button_props[3];

        // Decide on the button graphical elements.
        var b_ui_icon = 'ui-icon-plus';
        if (in_polarity === '-') {
          b_ui_icon = 'ui-icon-minus';
        }
        var b_ui_props = {
          icons: {
            primary: b_ui_icon
          },
          text: false
        };

        // Create the button and immediately add the event.
        //jQuery('#' + button_id).button(b_ui_props).click(
        jQuery('#' + button_id).click(function () {
          var tid = jQuery(this).attr('id');
          var call_time_button_props = button_hash[tid];
          var call_field = call_time_button_props[0];
          var call_filter = call_time_button_props[1];
          //var in_count = button_props[2];
          var call_polarity = call_time_button_props[3];

          // Change manager and fire.
          // var bstr =call_field+' '+call_filter+' '+call_polarity;
          // alert(bstr);
          manager.add_query_filter(call_field, call_filter, [call_polarity]);
          manager.search();
          // We are now searching--show it.
          _spin_up();
        });
      }

      // Now let's go back and add the buttons, styles,
      // events, etc. in the main accordion section.
      each(button_hash, filter_select_live);

      // Next, tie the events to the "more" spans.
      each(overflow_hash, function (filter_name, button_id) {
        jQuery('#' + button_id).click(function () {
          // On click, set that one field to limitless in
          // the manager, setup a shield, and wait for the
          // callback.

          // Recover the field name.
          var tid = jQuery(this).attr('id');
          var call_time_field_name = overflow_hash[tid];
          //alert(call_time_field_name);

          // Set the manager to no limit on that field and
          // only rturn the information that we want.
          manager.set_facet_limit(0);
          manager.set_facet_limit(call_time_field_name, -1);
          var curr_row = manager.get('rows');
          manager.set('rows', 0);

          // Create the shield and pop-up the
          // placeholder.
          var filter_shield = new display.filter_shield(ui_spinner_shield_source, ui_spinner_shield_message);
          filter_shield.start_wait();

          // Open the populated shield.
          function draw_shield(resp) {
            // ll("shield what: " + bbop.what_is(resp));
            // ll("shield resp: " + bbop.dump(resp));

            // First, extract the fields from the minimal
            // response.
            var fina = call_time_field_name;
            var flist = resp.facet_field(call_time_field_name);

            // Draw the proper contents of the shield.
            filter_shield.draw(fina, flist, manager);
          }
          var draw_promise = manager.search();
          draw_promise.then(function (resp) {
            draw_shield(resp);
          });

          // Reset the manager to more sane settings.
          manager.reset_facet_limit();
          manager.set('rows', curr_row);
        });
      });
      ll('Done current accordion for: ' + filters_div_id);
    };

    /*
     * Function: draw_current_filters
     *
     * (Re)draw the information on the current filter set.
     * This function makes them active as well.
     * 
     * Parameters:
     *  response - the <bbop.golr.response> returned from the server
     *  manager - <bbop.golr.manager> that we initially registered with
     *
     * Returns:
     *  n/a
     */
    this.draw_current_filters = function (response, manager) {
      ll('draw_current_filters for: ' + current_filters_div_id);

      ///
      /// Add in the actual HTML for the filters and buttons. While
      /// doing so, tie a unique id to the filter--we'll use that
      /// later on to add buttons and events to them.
      ///

      // First, we need to make the filter clear button for the top
      // of the table.
      var b_cf = new html.button('&times;', {
        'type': 'button',
        'id': clear_user_filter_span_id,
        'class': 'btn btn-danger btn-xs',
        'title': 'Clear all user filters'
      });
      var in_query_filters = response.query_filters();
      //var sticky_query_filters = manager.get_sticky_query_filters();
      ll('filters: ' + bbop.dump(in_query_filters));
      var fq_list_tbl = new html.table(['', 'User filters', b_cf.to_string()], [],
      // {'class': 'bbop-js-search-pane-filter-table'});
      {
        'class': 'table table-hover table-striped table-condensed'
      });
      var has_fq_p = false; // assume there are no filters to begin with
      var button_hash = {};
      each(in_query_filters, function (field_vals, field) {
        each(field_vals, function (polarity, field_val) {
          // Make note of stickiness, skip adding if sticky.
          var qfp = manager.get_query_filter_properties(field, field_val);
          if (!qfp || qfp['sticky_p'] === false) {
            // Note the fact that we actually have a
            // query filter to work with and display.
            has_fq_p = true;

            // Boolean value to a character.
            var polstr = '&minus;';
            if (polarity) {
              polstr = '&plus;';
            }

            // Argh! Real jQuery buttons are way too slow!
            // var b = new html.button('remove filter',
            // 		  {'generate_id': true});

            // Generate a button with a unique id.
            var b = new html.button(ui_icon_remove_label, {
              'generate_id': true,
              'type': 'button',
              'title': 'Remove filter',
              'class': 'btn btn-danger btn-xs'
            });

            // Tie the button it to the filter for
            // jQuery and events attachment later on.
            var bid = b.get_id();
            button_hash[bid] = [polstr, field, field_val];

            //ll(label_str +' '+ bid);
            //fq_list_tbl.add_to(label_str +' '+ b.to_string());
            fq_list_tbl.add_to(['<strong>' + polstr + '</strong>', field + ': ' + field_val, b.to_string()]);
            //label_str +' '+ b.to_string());
          }
        });
      });

      // Either add to the display, or display the "empty" message.
      var cfid = '#' + current_content_id;
      jQuery(cfid).empty();
      if (!has_fq_p) {
        jQuery(cfid).append("No current user filters.");
      } else {
        // With this, the buttons will be attached to the
        // DOM...
        jQuery(cfid).append(fq_list_tbl.to_string());

        // First, lets add the reset for all of the filters.
        jQuery('#' + b_cf.get_id()).click(function () {
          manager.reset_query_filters();
          manager.search();
          // We are now searching--show it.
          _spin_up();
        });

        // Now let's go back and add the buttons, styles,
        // events, etc. to the filters.
        each(button_hash, function (pass, button_id) {
          var bid = button_id;

          // // Get the button.
          // var bprops = {
          // 	 icons: { primary: "ui-icon-close"},
          // 	 text: false
          // };
          // Create the button and immediately add the event.
          //jQuery('#' + bid).button(bprops).click(
          jQuery('#' + bid).click(function () {
            var tid = jQuery(this).attr('id');
            var button_props = button_hash[tid];
            var polstr = button_props[0];
            var field = button_props[1];
            var value = button_props[2];

            // Change manager and fire.
            // var lstr = polstr +' '+ field +' '+ value;
            // alert(lstr);
            // manager.remove_query_filter(field,value,
            // 				 [polstr, '*']);
            manager.remove_query_filter(field, value);
            manager.search();
            // We are now searching--show it.
            _spin_up();
          });
        });
      }
    };

    /*
     * Function: draw_sticky_filters
     *
     * (Re)draw the information on the sticky filter set.
     * 
     * Parameters:
     *  response - the <bbop.golr.response> returned from the server
     *  manager - <bbop.golr.manager> that we initially registered with
     *
     * Returns:
     *  n/a
     */
    this.draw_sticky_filters = function (response, manager) {
      ll('draw_sticky_filters for: ' + sticky_filters_div_id);

      // Add in the actual HTML for the pinned filters and buttons.
      var sticky_query_filters = manager.get_sticky_query_filters();
      ll('sticky filters: ' + bbop.dump(sticky_query_filters));
      var fq_list_tbl = new html.table(['', 'Your search is pinned to these filters'], [], {
        'class': 'table table-hover table-striped table-condensed'
      });
      // [{'filter': A, 'value': B, 'negative_p': C, 'sticky_p': D}, ...]
      each(sticky_query_filters, function (fset) {
        //
        var sfield = fset['filter'];
        var sfield_val = fset['value'];

        // Boolean value to a character.
        var polarity = fset['negative_p'];
        var polstr = '&minus;';
        if (polarity) {
          polstr = '&plus;';
        }

        // Generate a button with a unique id.
        var label_str = polstr + ' ' + sfield + ':' + sfield_val;
        fq_list_tbl.add_to(['<b>' + polstr + '</b>', sfield + ': ' + sfield_val]);
      });

      // Either add to the display, or display the "empty" message.
      //var sfid = '#' + sticky_filters_div_id;
      var sfid = '#' + sticky_content_id;
      jQuery(sfid).empty();
      if (sticky_query_filters.length === 0) {
        jQuery(sfid).append("No sticky filters.");
      } else {
        // Attach to the DOM...
        jQuery(sfid).append(fq_list_tbl.to_string());
      }
    };

    /*
     * Function: query_field_text
     * 
     * Push text into the search box. Does not affect the state of the
     * manager in any way.
     * 
     * NOTE: Does not function until the display is established.
     * 
     * Parameters:
     *  query - the text to put into the search box
     *
     * Returns
     *  string
     */
    this.query_field_text = function (query) {
      var retval = '';
      if (anchor.established_p() && us.isString(query)) {
        var input_text = jQuery('#' + query_input_div_id).val(query);
        if (input_text) {
          retval = input_text;
        }
      }
      return retval;
    };

    ///
    /// 
    ///

    if (this._display_accordion_p) {
      manager.register('search', this.draw_accordion, 1, 'accordion_first');
      manager.register('search', this.draw_current_filters, 2, 'current_first');
      manager.register('search', this.draw_sticky_filters, 3, 'sticky_first');
    }

    /*
     * Function: draw_error
     *
     * Somehow report an error to the user.
     * 
     * Parameters:
     *  error_message - a string(?) describing the error
     *  manager - <bbop.golr.manager> that we initially registered with
     *
     * Returns:
     *  n/a
     */
    this.draw_error = function (error_message, manager) {
      ll("draw_error: " + error_message);
      alert("Runtime error: " + error_message);
      _spin_down();
    };
    manager.register('error', this.draw_error, 0, 'error_first');

    // 
    function spin_down_wait() {
      _spin_down();
    }
    manager.register('search', spin_down_wait, -100, 'donedonedone');

    // Start the ball with a reset event.
    //manager.search();

    // The display has been established.
    anchor._established_p = true;
  };
};

///
/// Exportable body.
///

module.exports = live_filters;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./display":14,"./generators":15,"./html":17,"bbop-core":26,"underscore":108}],19:[function(require,module,exports){
(function (global){(function (){
/*
 * Package: live_geospatial.js
 * 
 * Namespace: bbop-widget-set.live_geospatial
 * 
 * BBOP JS object to allow the live probing of a GOlr personality via
 * maps, etc.
 * 
 * This is a OMS/Leaflet widget..
 */

var us = require('underscore');
var bbop = require('bbop-core');
var html = require('./html');
var display = require('./display');
var generators = require('./generators');
//var clickable_object_generator = require('./display/clickable_object_generator');

/* global L */
// Code here will be ignored by JSHint, as we are technically
// "redefining" jQuery (although we are not).
/* jshint ignore:start */
var jQuery = typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null;
//require('jquery-ui');
/* jshint ignore:end */

/*
 * Constructor: live_filters
 * 
 * Contructor for the bbop-widget-set.live_filters object.
 * 
 * Widget interface to interactively explore a search personality with
 * no direct side effects.
 *
 * Arguments:
 *  interface_id - string id of the element to build on
 *  manager - the shared GOlr manager to use
 *  in_argument_hash - *[optional]* optional hash of optional arguments
 * 
 * Returns:
 *  this object
 */
var live_geospatial = function live_geospatial(interface_id, manager, in_argument_hash) {
  this._is_a = 'bbop-widget-set.live_geospatial';
  var anchor = this;
  var each = us.each;

  // Per-UI logger.
  var logger = new bbop.logger();
  logger.DEBUG = false;
  //logger.DEBUG = true;
  function ll(str) {
    logger.kvetch('GS: ' + str);
  }

  ///
  /// Deal with incoming arguments.
  ///

  // Our argument default hash.
  var default_hash = {
    height: 180,
    latitude: 0.0,
    longitude: 0.0,
    zoom: 0.0
    // 'meta_label': 'Documents:&nbsp;',
    // 'display_meta_p': true,
    // 'display_free_text_p': true,
  };
  var folding_hash = in_argument_hash || {};
  var arg_hash = bbop.fold(default_hash, folding_hash);

  ///
  /// Class variables.
  ///

  anchor._interface_id = interface_id;
  anchor._height = arg_hash['height'];
  anchor._latitude = arg_hash['latitude'];
  anchor._longitude = arg_hash['longitude'];
  anchor._zoom = arg_hash['zoom'];
  anchor._established_p = false;
  anchor._markers = [];

  ///
  /// Prepare the interface and setup the div hooks.
  ///

  jQuery('#' + interface_id).empty();

  // Prepare the d setion and add it.
  var enclosure = new html.tag('div', {
    'generate_id': true,
    'style': 'height: ' + anchor._height + 'px;'
  });
  jQuery('#' + interface_id).append(enclosure.to_string());

  // Set map into new area.
  //var ags = L.map(interface_id).setView([51.505, -0.09], 13);
  var ags = L.map(enclosure.get_id()).setView([anchor._latitude, anchor._longitude], anchor._zoom);
  L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
    attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
  }).addTo(ags);

  ///
  /// Response to map:
  /// Add currently seen markers to map.
  ///

  manager.register('search', function (resp, man) {
    // First, clear current markers.
    each(anchor._markers, function (marker) {
      //marker.remove();
      //marker.closePopup();
      //marker.unbindPopup();
      ags.removeLayer(marker);
    });
    anchor._markers = [];

    // Now add markers for all new results in table.
    // Until we have long lat loaded...
    // var _rand_lat = function(){ return Math.random() * (-90 - 90) + 90;};
    // var _rand_long = function(){ return Math.random() * (-180 - 180) + 180;};
    each(resp.documents(), function (doc) {
      console.log(doc);

      // Extract the lat/long data and convert out of integer
      // space.
      var int_long = parseInt(doc['geospatial_x']);
      var int_lat = parseInt(doc['geospatial_y']);
      var float_long = int_long / 1000000.0;
      var float_lat = int_lat / 1000000.0;
      console.log(float_long, float_lat);

      // Add to display.
      var marker = L.marker([float_lat, float_long]).addTo(ags).bindPopup(doc['annotation_class_label'] + ', ' + doc['bioentity_label']);
      //.openPopup();

      //Save for later destruction.
      anchor._markers.push(marker);
    });
  }, 1, anchor._is_a + '_marker');

  ///
  /// Map to manager:
  /// Trigger filtered searches on movement, looking at current bounds.
  ///

  function on_move(e) {
    // Get the cardinal bounds.
    if (e && e.target && e.target.getBounds) {
      var bounds = e.target.getBounds();
      if (bounds) {
        var north = Math.round(bounds.getNorth() * 1000000);
        var south = Math.round(bounds.getSouth() * 1000000);
        var west = Math.round(bounds.getWest() * 1000000);
        var east = Math.round(bounds.getEast() * 1000000);

        //console.log("Bounds set: ", bounds.toBBoxString());
        console.log("Tween x _ long _ n/s: ", south, north);
        console.log("Tween y _ lat _ w/e: ", west, east);

        // Set manager with these bounds filters.
        // manager.remove_query_filter('geospatial_x');
        // manager.remove_query_filter('geospatial_y');
        // manager.add_query_filter('geospatial_x',
        // 			 '['+ west + ' TO ' + east +']');
        // manager.add_query_filter('geospatial_y',
        // 			 '['+ south + ' TO ' + north +']');
        // TODO/BUG: Manager does not do unquoted stuff, which
        // is what we need here. Manually add and reset the extra bits.
        manager.set_extra('&fq=geospatial_x:[' + west + ' TO ' + east + ']' + '&fq=geospatial_y:[' + south + ' TO ' + north + ']');

        // Trigger search with new filters.
        manager.search();
      }
    }
  }
  ags.on('moveend', on_move);

  ///
  /// ...
  ///

  // The display has been established.
  anchor._established_p = true;
};

///
/// Exportable body.
///

module.exports = live_geospatial;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./display":14,"./generators":15,"./html":17,"bbop-core":26,"underscore":108}],20:[function(require,module,exports){
(function (global){(function (){
/*
 * Package: live_pager.js
 * 
 * Namespace: bbop-widget-set.live_pager
 * 
 * BBOP JS object to allow the the paging/downloading etc. of a GOlr
 * manager.
 * 
 * Very much like a separated pager from the search pane.
 * 
 * This is a Bootstrap 3 widget.
 * 
 * See Also:
 *  <search_pane.js>
 *  <live_search.js>
 *  <live_filters.js>
 */

var us = require('underscore');
var bbop = require('bbop-core');
var html = require('./html');

// Code here will be ignored by JSHint, as we are technically
// "redefining" jQuery (although we are not).
/* jshint ignore:start */
var jQuery = typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null;
//require('jquery-ui');
/* jshint ignore:end */

/*
 * Constructor: live_pager
 * 
 * Contructor for the bbop-widget-set.live_pager object.
 * 
 * Display a manager response. Not a manager itself, but can use the
 * argument manager to page, download, etc.
 *
 * Arguments:
 *  interface_id - string id of the element to build on
 *  manager - a manager object to probe for display and use for remoting
 *  in_argument_hash - *[optional]* optional hash of optional arguments
 * 
 * Returns:
 *  this object
 */
var live_pager = function live_pager(interface_id, manager, in_argument_hash) {
  this._is_a = 'bbop-widget-set.live_pager';
  var anchor = this;
  var each = us.each;
  function ll(str) {
    console.log(str);
  }

  // Some top-level variable defined.
  var ui_count_control_div_id = interface_id + '_countctl_div_' + bbop.uuid();
  var external_button_location_id = 'pager_button_holder_' + bbop.uuid();

  // Handle incoming arguements.
  var default_hash = {
    'callback_priority': 0,
    'selection_counts': [10, 25, 50, 100],
    'results_title': 'Total: '
  };
  var folding_hash = in_argument_hash || {};
  var arg_hash = bbop.fold(default_hash, folding_hash);
  //
  var callback_priority = arg_hash['callback_priority'];
  var selection_counts = arg_hash['selection_counts'];
  var results_title = arg_hash['results_title'];

  // Last things last, bind to the manager.
  // TODO/BUG: Should this actually happen outside the widget? How
  // complicated is this really?
  var fun_id = bbop.uuid();
  manager.register('search', _repaint_on_callback, callback_priority, fun_id);

  // Add the "disabled" property to a button if the boolean
  // value says so.
  function _disable_if(bttn, disbool) {
    if (disbool) {
      jQuery('#' + bttn.get_id()).attr('disabled', 'disabled');
    }
  }

  // (Re)draw the count control with the current information in the
  // manager. This also tries to set the selector to the response
  // number (to keep things in sync), unbinds any current "change"
  // event, and adds a new change event.
  function _repaint_on_callback(response, manager) {
    //ll('draw live_pager at: ' + interface_id);

    ///
    /// Section 1: the numbers display.
    ///

    // Collect numbers for display.
    var total_c = response.total_documents();
    var first_d = response.start_document();
    var last_d = response.end_document();

    // Draw meta; the current numbers and page--the same for
    // every type of return.
    jQuery('#' + interface_id).empty();
    if (total_c === 0) {
      jQuery('#' + interface_id).append('No results found.');
    } else {
      // A top-level div to contain the literal meta results, and the count
      // selector next to them.
      var mdiv_attrs = {
        'class': 'row',
        'generate_id': true
      };
      var mdiv = new html.tag('div', mdiv_attrs);

      // The literal return metadata.
      var dmeta_attrs = {
        //'class': 'bbop-js-search-pane-meta'
        'generate_id': true,
        'class': 'col-xs-6 col-sm-6 col-md-4 col-lg-4'
      };
      var dmeta = new html.tag('div', dmeta_attrs);
      dmeta.add_to('<div>' + results_title + total_c + '; showing: ' + first_d + '-' + last_d + '</div>');
      mdiv.add_to(dmeta);

      ///
      /// Section 2: results count control.
      ///

      // Create a text label.
      var sel_label_attrs = {
        //'for': ui_count_control_div_id,
        // 'generate_id': true,
        //'class': 'control-label'
      };
      var sel_label = new html.tag('span', sel_label_attrs, 'Results&nbsp;count&nbsp;&nbsp;');

      // Create inputs (the current order is important for proper
      // for/id creation).
      var cinputs = [];
      each(selection_counts, function (num, cindex) {
        // Create and store the option.
        var sel_input_attrs = {
          'generate_id': true,
          'value': num
        };
        var sel_input = new html.tag('option', sel_input_attrs, num);
        var sel_input_id = sel_input.get_id();
        cinputs.push(sel_input);
      });
      // Option container div.
      var sel_attrs = {
        'id': ui_count_control_div_id,
        //'class': 'form-control',
        'style': 'width: 5em;'
      };
      var sel = new html.tag('select', sel_attrs, cinputs);

      // Container div.
      var sel_div_attrs = {
        'generate_id': true
        //'class': 'col-xs-6 col-sm-6 col-md-3 col-lg-3'
        //'class': 'form-group'
        //'style': 'width: 7em;'
      };
      var sel_div = new html.tag('div', sel_div_attrs);

      // Assemble these elements into the UI.
      sel_div.add_to(sel_label);
      sel_div.add_to(sel);
      //mdiv.add_to(sel_div);
      dmeta.add_to(sel_div);

      // Render out the last two sections.
      jQuery('#' + interface_id).append(mdiv.to_string());

      ///
      /// Section 3: results count activity, setting.
      ///

      // First, unbind so we don't accidentally trigger with any
      // changes and don't pile up event handlers.
      jQuery('#' + ui_count_control_div_id).unbind('change');

      // Next, pull out the number of rows requested.
      var step = response.row_step();

      // Set the value to the number.
      jQuery('#' + ui_count_control_div_id).val(step);

      // Finally, reactivate the event handler on the select.
      jQuery('#' + ui_count_control_div_id).change(function (event, ui) {
        var sv = jQuery('#' + ui_count_control_div_id).val();
        if (bbop.is_defined(sv)) {
          // Convert to a number.
          var si = parseInt(sv);

          // Set manager and to the search.
          manager.set_results_count(si);
          manager.search();
          // We are now searching--show it.
          //_spin_up();
        }
      });

      ///
      /// Section 4: the paging buttons.
      ///

      var bdiv_attrs = {
        'class': 'col-xs-12 col-sm-12 col-md-8 col-lg-8',
        'generate_id': true
      };
      var bdiv = new html.tag('div', bdiv_attrs);
      //jQuery('#' + interface_id).append(bdiv.to_string());
      jQuery('#' + mdiv.get_id()).append(bdiv.to_string());
      var bdiv_id = bdiv.get_id();

      // Now add the raw buttons to the interface, and after this,
      // activation and adding events.
      var bopts = {
        'generate_id': true,
        'class': 'btn btn-primary'
      };
      var b_first = new html.button('&laquo;First', bopts);
      //jQuery('#' + interface_id).append(b_first.to_string());
      jQuery('#' + bdiv_id).append(b_first.to_string());
      var b_back = new html.button('&lt;Prev', bopts);
      //jQuery('#' + interface_id).append(b_back.to_string());
      jQuery('#' + bdiv_id).append(b_back.to_string());
      var b_forward = new html.button('Next&gt;', bopts);
      //jQuery('#' + interface_id).append(b_forward.to_string());
      jQuery('#' + bdiv_id).append(b_forward.to_string());
      var b_last = new html.button('Last&raquo;', bopts);
      //jQuery('#' + interface_id).append(b_last.to_string());
      jQuery('#' + bdiv_id).append(b_last.to_string());

      // Do the math about what buttons to activate.
      var b_first_disabled_p = false;
      var b_back_disabled_p = false;
      var b_forward_disabled_p = false;
      var b_last_disabled_p = false;

      // Only activate paging if it is necessary to the returns.
      if (!response.paging_p()) {
        b_first_disabled_p = true;
        b_back_disabled_p = true;
        b_forward_disabled_p = true;
        b_last_disabled_p = true;
      }

      // Don't activate back on the first page.
      if (!response.paging_previous_p()) {
        b_first_disabled_p = true;
        b_back_disabled_p = true;
      }

      // Don't activate next on the last page.
      if (!response.paging_next_p()) {
        b_forward_disabled_p = true;
        b_last_disabled_p = true;
      }

      // First page button.
      _disable_if(b_first, b_first_disabled_p);
      jQuery('#' + b_first.get_id()).click(function () {
        // Cheat and trust reset by proxy to work.
        manager.page_first();
        // We are now searching--show it.
        //_spin_up();
      });

      // Previous page button.
      _disable_if(b_back, b_back_disabled_p);
      jQuery('#' + b_back.get_id()).click(function () {
        manager.page_previous();
        // We are now searching--show it.
        //_spin_up();
      });

      // Next page button.
      _disable_if(b_forward, b_forward_disabled_p);
      jQuery('#' + b_forward.get_id()).click(function () {
        manager.page_next();
        // We are now searching--show it.
        //_spin_up();
      });

      // Last page button.
      _disable_if(b_last, b_last_disabled_p);
      jQuery('#' + b_last.get_id()).click(function () {
        // A little trickier.
        manager.page_last(total_c);
        // We are now searching--show it.
        //_spin_up();
      });

      ///
      /// Section 5: make a place for external buttons.
      ///

      var holder_attrs = {
        'id': external_button_location_id,
        'class': 'bbop-widget-set-live-pager-argument-button-set'
      };
      var holder = new html.tag('span', holder_attrs);
      jQuery('#' + bdiv_id).append('&nbsp;' + holder.to_string());
    }
  }

  /*
   * Function: button_span_id
   * 
   * Returns the location of a place to add external buttons if you
   * want.
   * 
   * Parameters:
   *  n/a
   * 
   * Returns
   *  string rep of place to put external buttons (span tag)
   */
  anchor.button_span_id = function () {
    return external_button_location_id;
  };
};

///
/// Exportable body.
///

module.exports = live_pager;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./html":17,"bbop-core":26,"underscore":108}],21:[function(require,module,exports){
(function (global){(function (){
/*
 * Package: live_results.js
 * 
 * Namespace: bbop-widget-set.live_results
 * 
 * BBOP JS widget to display the results of a search on callback.
 * 
 * TODO: Button insertion in other non-internal places.
 * 
 * This is a Bootstrap 3 widget.
 */

var us = require('underscore');
var bbop = require('bbop-core');
var html = require('./html');
var display = require('./display');

// Code here will be ignored by JSHint, as we are technically
// "redefining" jQuery (although we are not).
/* jshint ignore:start */
var jQuery = typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null;
//require('jquery-ui');
/* jshint ignore:end */

/*
 * Constructor: live_results
 * 
 * Contructor for the bbop-widget-set.live_results object.
 * 
 * Results table and optional buttons.
 *
 * Optional options looks like:
 *  callback_priority - default 0
 *  user_buttons - default [], should be any passable renderable button
 *  user_buttons_div_id - default null
 *  selectable_p - have selectable side buttons (default true)
 *
 * Arguments:
 *  interface_id - string id of the element to build on
 *  manager - the shared GOlr manager to use
 *  conf_class - the profile of the specific conf to use
 *  handler - handler to use in rendering
 *  linker - linker to use in rendering
 *  in_argument_hash - *[optional]* optional hash of optional arguments, described above
 * 
 * Returns:
 *  this object
 */
var live_results = function live_results(interface_id, manager, conf_class, handler, linker, in_argument_hash) {
  this._is_a = 'bbop-widget-set.live_results';
  var anchor = this;
  var each = us.each;

  // Per-UI logger.
  var logger = new bbop.logger();
  logger.DEBUG = false;
  //logger.DEBUG = true;
  function ll(str) {
    logger.kvetch('LR: ' + str);
  }
  var results_table = null;

  // Capture the last response for downstream widgets.
  var last_response = null;

  // Some top-level variable defined.
  // Special id and names for optional select column.
  var local_mangle = bbop.uuid();
  var select_column_id = 'rtbcc_select_' + local_mangle;
  var select_item_name = 'rtbcc_select_name_' + local_mangle;

  ///
  /// Deal with incoming arguments.
  ///

  // Our argument default hash.
  var default_hash = {
    'callback_priority': 0,
    'user_buttons': [],
    'user_buttons_div_id': null,
    'selectable_p': true
  };
  var folding_hash = in_argument_hash || {};
  var arg_hash = bbop.fold(default_hash, folding_hash);
  // 
  var callback_priority = arg_hash['callback_priority'];
  var user_buttons = arg_hash['user_buttons'];
  var user_buttons_div_id = arg_hash['user_buttons_div_id'];
  var selectable_p = arg_hash['selectable_p'];

  //
  var fun_id = bbop.uuid();

  ///
  /// Set the callbacks.
  ///

  // Add the "disabled" property to a button if the boolean
  // value says so.
  function _disable_if(bttn, disbool) {
    if (disbool) {
      jQuery('#' + bttn.get_id()).attr('disabled', 'disabled');
    }
  }

  // (Re)draw the user-defined buttons in the meta
  // information area.  Will naturally fail if there is no
  // meta div that has been nested with the user button
  // element.
  function _draw_user_buttons(button_definitions, loc_id) {
    function _button_rollout(button_def_hash) {
      var default_hash = {
        label: '?',
        disabled_p: false,
        click_function_generator: function click_function_generator(anchor, manager) {
          return function (anchor, manager) {
            alert('No callback defined for this button--' + 'the generator may have been empty!');
          };
        }
      };
      var folding_hash = button_def_hash || {};
      var arg_hash = bbop.fold(default_hash, folding_hash);
      var label = arg_hash['label'];
      var disabled_p = arg_hash['disabled_p'];
      var click_function_generator = arg_hash['click_function_generator'];

      /// Add button to DOM.
      var b_props = {
        'generate_id': true,
        'class': 'btn btn-primary'
      };
      var b = new html.button(label, b_props);
      jQuery('#' + loc_id).append(b.to_string());
      _disable_if(b, disabled_p);

      // Bind function to action.
      var click_fun = click_function_generator(anchor, manager);
      jQuery('#' + b.get_id()).click(click_fun);
    }

    // Check that we're not about to do the impossible.
    if (!jQuery('#' + loc_id)) {
      alert('cannot refresh buttons without a place to draw them');
    } else {
      jQuery('#' + loc_id).empty();
      each(button_definitions, _button_rollout);
    }
  }

  // Draw a table at the right place or an error message.
  function _draw_table_or_something(resp, manager) {
    // Wipe interface.
    jQuery('#' + interface_id).empty();

    // Vary by what we got.
    if (!resp.success() || resp.total_documents() === 0) {
      jQuery('#' + interface_id).append('<em>No results given your input and search fields. Please refine and try again.</em>');
      last_response = null;
    } else {
      last_response = resp;

      // Render the buttons.
      //console.log('user_buttons: ', user_buttons);
      if (user_buttons && user_buttons.length && user_buttons.length > 0) {
        // Ensure we have somewhere to put our buttons. If not
        // supplied with an injection id, make our own and use
        // it.
        var insert_div_id = user_buttons_div_id;
        if (!user_buttons_div_id) {
          // Generate new dic and add it to the display.
          var ubt_attrs = {
            'generate_id': true
          };
          var ubt = new html.tag('div', ubt_attrs);
          jQuery('#' + interface_id).append(ubt.to_string());

          // Ensure the id.
          insert_div_id = ubt.get_id();
        }

        // Add all of the defined buttons after the spacing.
        _draw_user_buttons(user_buttons, insert_div_id);
      }

      // Display results.
      var results_table_bc = display.results_table_by_class_conf;
      results_table = new results_table_bc(conf_class, resp, linker, handler, interface_id, selectable_p, select_column_id, select_item_name);
    }
  }
  manager.register('search', _draw_table_or_something, callback_priority, fun_id);

  // Somehow report an error to the user.
  //  error_message - a string(?) describing the error
  //  manager - <bbop.golr.manager> that we initially registered with
  function _draw_error(error_message, manager) {
    ll("draw_error: " + error_message);
    alert("Runtime error: " + error_message);
    //_spin_down();
  }
  manager.register('error', _draw_error, callback_priority, fun_id);

  ///
  /// External API.
  ///

  /*
   * Function: item_name
   *
   * Return a string of the name attribute used by the checkboxes if
   * we selected for checkboxes to be displayed.
   * 
   * Parameters:
   *  n/a
   *
   * Returns:
   *  string or null if displaying checkboxes was false
   */
  this.item_name = function () {
    return select_item_name;
  };

  /*
   * Function: toggle_id
   *
   * Return a string of the id of the checkbox in the header if we
   * selected for checkboxes to be displayed.
   * 
   * Parameters:
   *  n/a
   *
   * Returns:
   *  string or null if displaying checkboxes was false
   */
  this.toggle_id = function () {
    return select_column_id;
  };

  /*
   * Function: last_response
   *
   * The response for the last call. If the call was not successful
   * or returned no documents, this will be null.
   *
   * Parameters:
   *  n/a
   *
   * Returns:
   *  response or null
   */
  this.last_response = function () {
    return last_response;
  };

  /*
   * Function: get_selected_items
   * 
   * The idea is to return a list of the items selected (with
   * checkboxes) in the display. This means that there are three
   * possibilities. 1) We are not using checkboxes or the display
   * has not been established, so we return null; 2) no or all items
   * have been selected, so we get back an empty list (all === none
   * in our view); 3) a subset list of strings (ids).
   * 
   * NOTE: Naturally, does not function until the display is established.
   * 
   * Parameters:
   *  n/a
   *
   * Returns
   *  string list or null
   */
  this.get_selected_items = function () {
    var retval = null;

    // 
    if (selectable_p) {
      retval = [];

      // Cycle through and pull out the values of the checked
      // ones.
      var total_count = 0;
      var nstr = 'input[name=' + select_item_name + ']';
      jQuery(nstr).each(function () {
        if (this.checked) {
          var val = jQuery(this).val();
          retval.push(val);
        }
        total_count++;
      });

      // If we are selecting all of the items on this page, that
      // is the same as not selecting any in our world, so reset
      // and warn.
      if (total_count > 0 && total_count === retval.length) {
        alert('You can "select" all of the items on a results page by not selecting any (all being the default). This will also get your results processed faster and cause significantly less overhead on the servers.');
        retval = [];
      }
    }
    return retval;
  };
};

///
/// Exportable body.
///

module.exports = live_results;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./display":14,"./html":17,"bbop-core":26,"underscore":108}],22:[function(require,module,exports){
/*
 * Package: repl.js
 *
 * Namespace: bbop-widget-set.repl
 *
 * A self-contained flexible REPL to use as a base to explore the BBOP
 * environment that you setup.
 *
 * This is a completely self-contained UI and manager.
 *
 * WARNING: This widget cannot display any kind of HTML tags in the
 * log.
 */

var us = require('underscore');
var bbop = require('bbop-core');
var html = require('./html');
var display = require('./display');
var generators = require('./generators');

/*
 * Constructor: repl
 *
 * Contructor for the bbop-widget.repl object.
 *
 * The in_argument_hash has the following options.
 *
 *  buffer_id - the id of the evaluation buffer textarea (default: null/random)
 *  cli_id - the id of the CLI textarea (default: null/random)
 *  display_initial_commands_p - (default true)
 *
 * If you do not specify ids for the inputs, random ones will be
 * generated.
 *
 * Arguments:
 *  interface_id - string id of the element to build on
 *  initial_commands - a list of initial commands to feed the interpreter
 *  in_argument_hash - *[optional]* optional hash of optional arguments
 *
 * Returns:
 *  this object
 */
var repl = function repl(interface_id, initial_commands, in_argument_hash) {
  this._is_a = 'bbop-widget-set.repl';

  // Aliases.
  var anchor = this;
  var loop = bbop.each;

  // Our argument default hash.
  var default_hash = {
    'buffer_id': null,
    'cli_id': null,
    'display_initial_commands_p': true
  };
  var folding_hash = in_argument_hash || {};
  var arg_hash = bbop.fold(default_hash, folding_hash);
  var in_buffer_id = arg_hash['buffer_id'];
  var in_cli_id = arg_hash['cli_id'];
  var display_initial_commands_p = arg_hash['display_initial_commands_p'];

  // Get no commands if nothing else.
  var init_buffer = initial_commands || [];

  // The main div we'll work with.
  var repl_id = interface_id;
  jQuery('#' + repl_id).empty();

  // Save our CLI history as we go.
  var history_pointer = 0;
  var history_list = [''];

  ///
  /// Setup the HTML and layout on the page.
  ///

  // Env into work buffer.
  var command_buffer_args = {
    'rows': '12',
    cols: '80'
  };
  if (in_buffer_id) {
    command_buffer_args['id'] = in_buffer_id;
  } else {
    command_buffer_args['generate_id'] = true;
  }
  var command_buffer = new html.tag('textarea', command_buffer_args, init_buffer.join("\n"));
  jQuery('#' + repl_id).append(command_buffer.to_string());
  jQuery('#' + repl_id).append('<br />');

  // Command buffer eval button.
  var command_buffer_button = new html.button('Evaluate buffer', {
    'generate_id': true
  });
  jQuery('#' + repl_id).append(command_buffer_button.to_string());

  // Clear buffer button.
  var clear_buffer_button = new html.button('Clear buffer', {
    'generate_id': true
  });
  jQuery('#' + repl_id).append(clear_buffer_button.to_string());

  // Clear log button.
  var clear_log_button = new html.button('Clear log', {
    'generate_id': true
  });
  jQuery('#' + repl_id).append(clear_log_button.to_string());
  jQuery('#' + repl_id).append('<br />');

  // Log (+ clear botton).
  // //var logging_console_id = 'bbop-logger-console-text';
  // var logging_console_id = 'bbop-logger-console-textarea';
  // var logging_console = new html.tag('textarea',
  // 					    {'rows': '7', cols:'80',
  // 					     'readonly': 'readonly',
  // 					     'id': logging_console_id});
  var logging_console_id = 'bbop-logger-console-html';
  var logging_console = new html.tag('div', {
    'id': logging_console_id,
    'class': 'nowrap',
    'style': 'height: 7em; width: 40em; border: 1px solid #888888; overflow: auto;'
  });
  jQuery('#' + repl_id).append(logging_console.to_string());

  //jQuery('#' + repl_id).append('<br />');

  // A usage message.
  var cli_msg = new html.tag('span', {}, "[eval: return; ctrl+up/down: history]:");
  jQuery('#' + repl_id).append(cli_msg.to_string());
  jQuery('#' + repl_id).append('<br />');

  // Command line.
  var command_line_args = {
    'rows': '1',
    cols: '80'
  };
  if (in_cli_id) {
    command_line_args['id'] = in_cli_id;
  } else {
    command_line_args['generate_id'] = true;
  }
  var command_line = new html.tag('textarea', command_line_args);
  jQuery('#' + repl_id).append(command_line.to_string());

  ///
  /// Core helper functions.
  ///

  // Per-UI logger. Notice that we waited until after the log div
  // was added to run this to make sure we bind to the right spot.
  var rlogger = new bbop.logger();
  rlogger.DEBUG = true;
  //function log(str){ rlogger.kvetch('repl (pre): ' + str); }
  function log(str) {
    rlogger.kvetch(str);
  }

  // Advance the log to the bottom.
  function _advance_log_to_bottom() {
    // var cons = jQuery('#' + logging_console_id);
    // var foo = cons.scrollTop(cons[0].scrollHeight);
  }
  ;

  // Eval!
  function _evaluate(to_eval) {
    var retval = null;
    var retval_str = '';
    var okay_p = true;
    try {
      // If we get through this, things have gone well.
      // Global eval actually kind of tricky:
      //  http://perfectionkills.com/global-eval-what-are-the-options/
      //var ret = eval(to_eval);
      //var ret = jQuery.globalEval(to_eval);
      retval = window.eval(to_eval);
      if (bbop.is_defined(retval)) {
        //log('// in def if');
        if (bbop.what_is(retval) == 'string') {
          // // log('// in str if');
          // retval_str = retval;
          // // var gt_re = new RegExp("/\>/", "gi");
          // // var lt_re = new RegExp("/\</", "gi");
          // retval_str.replace(">", "&gt;");
          // retval_str.replace("<", "&lt;");
          // //retval_str = '<pre>' + retval_str + '</pre>';
          // // log('// end: (' + retval_str + ')');
          // retval_str = '<code>' + retval_str + '</code>';
          // retval_str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
          retval_str = '"' + retval + '"';
        } else {
          retval_str = retval; // worth a try at least
        }
      } else {
        // Maybe undefined, but probably just no return value.
        //retval_str = '[undefined]';
        retval_str = '';
      }
    } catch (x) {
      // Bad things happened.
      retval = null;
      retval_str = '[n/a]';
      okay_p = false;
    }
    return [retval, retval_str, okay_p];
  }

  // Update the CLI to the current point in the history.
  function _update_cli() {
    var item = history_list[history_pointer];
    jQuery('#' + command_line.get_id()).val(item);
    //log('// [history]: ' + item);
    //log('// history: '+history_pointer+', '+history_list.length);
    //_advance_log_to_bottom();
  }

  ///
  /// Build callbacks.
  ///

  // A lot of cases for button presses when reading from the command
  // line.
  function read_cli(event) {
    var which = event.which;
    var ctrl_p = event.ctrlKey;
    //log('cli: ' + which + ', ' + ctrl_p);

    if (which == 13) {
      // return

      // Stop events.
      event.preventDefault();

      // Get and ensure nice JS, wipe CLI clean.
      var to_eval = jQuery('#' + command_line.get_id()).val();
      if (to_eval != '') {
        jQuery('#' + command_line.get_id()).val('');

        // Enter the new command into our history and bump the
        // index to the last thing pushed on.
        history_list.pop(); // pop the empty ''
        history_list.push(to_eval);
        history_list.push(''); // push new empty ''
        history_pointer = history_list.length - 1;
        //log('// history: '+history_pointer+', '+history_list.length);

        // Log, eval, log.
        to_eval = bbop.ensure(to_eval, ';', 'back');
        log(to_eval);
        var evals = _evaluate(to_eval);
        log('// ' + evals[1]);
        _advance_log_to_bottom();
        return false;
      }
    } else if (ctrl_p && which == 38) {
      // ctrl + up

      // Stop stuff?
      event.preventDefault();
      if (history_pointer == 0) {
        _update_cli();
      } else if (history_pointer > 0) {
        history_pointer--;
        _update_cli();
      }
      return false;
    } else if (ctrl_p && which == 40) {
      // ctrl + down

      // Stop stuff?
      event.preventDefault();
      if (history_pointer < history_list.length - 1) {
        history_pointer++;
        _update_cli();
      }
      return false;
    }
    return true;
  }
  jQuery('#' + command_line.get_id()).keydown(read_cli);

  // Bind buffer eval.
  function read_buffer() {
    var to_eval = jQuery('#' + command_buffer.get_id()).val();
    if (to_eval != '') {
      log('// Evaluating buffer...');
      var evals = _evaluate(to_eval);
      log('// ' + evals[1]);
      _advance_log_to_bottom();
    }
  }
  var cbbid = '#' + command_buffer_button.get_id();
  var command_buffer_button_props = {
    icons: {
      primary: "ui-icon-play"
    },
    disabled: false,
    text: true
  };
  jQuery(cbbid).button(command_buffer_button_props).click(read_buffer);

  // Bind buffer clear.
  function clear_buffer() {
    //jQuery('#' + logging_console_id).val('');
    //alert('to clear: ' + command_buffer.get_id());
    // FF, at least, does something weird here and empty() does
    // not always work--doubling seems to be file.
    jQuery('#' + command_buffer.get_id()).val('');
    //jQuery('#' + command_buffer.get_id()).empty();
  }
  var cbuid = '#' + clear_buffer_button.get_id();
  var clear_buffer_button_props = {
    icons: {
      primary: "ui-icon-trash"
    },
    disabled: false,
    text: true
  };
  jQuery(cbuid).button(clear_buffer_button_props).click(clear_buffer);

  // Bind log clear.
  function clear_log() {
    //jQuery('#' + logging_console_id).val('');
    jQuery('#' + logging_console_id).empty();
  }
  var clbid = '#' + clear_log_button.get_id();
  var clear_log_button_props = {
    icons: {
      primary: "ui-icon-trash"
    },
    disabled: false,
    text: true
  };
  jQuery(clbid).button(clear_log_button_props).click(clear_log);

  ///
  /// Bootstrap session.
  ///

  // Evaluate what we initially put in the command buffer.
  jQuery(cbbid).click(); // run the stuff in the buffer
  if (display_initial_commands_p == false) {
    // maybe make it disappear
    clear_buffer();
    clear_log();
  }
  log('// [Session start.]');

  ///
  /// External use methods.
  ///

  /*
   * Function: get_id
   *
   * Get the id of different components in the REPL.
   *
   * Currently supported arguments are:
   *  - 'buffer'
   *
   * Arguments:
   *  str - the item you want to check
   *
   * Returns:
   *  string or null
   */
  this.get_id = function (str) {
    var retval = null;
    if (str) {
      if (str == 'buffer') {
        retval = command_buffer.get_id();
      }
    }
    return retval;
  };

  /*
   * Function: replace_buffer_text
   *
   * Replace the buffer text with new text.
   *
   * Arguments:
   *  str - the new text for the command buffer
   *
   * Returns:
   *  n/a
   */
  this.replace_buffer_text = function (str) {
    clear_buffer();
    //jQuery('#' + command_buffer.get_id()).append(str);
    jQuery('#' + command_buffer.get_id()).val(str);
  };

  /*
   * Function: advance_log_to_bottom
   *
   * Can't be bothered to check now, but this needs to be done
   * separately from the log because of an initial race condition.
   *
   * Arguments:
   *  n/a
   *
   * Returns:
   *  n/a
   */
  this.advance_log_to_bottom = function () {
    _advance_log_to_bottom();
  };

  /*
   * Function: destroy
   *
   * Remove the autocomplete and functionality from the DOM.
   *
   * Arguments:
   *  n/a
   *
   * Returns:
   *  n/a
   */
  this.destroy = function () {
    jQuery('#' + anchor._interface_id).val('');
  };
};

///
/// Exportable body.
///

module.exports = repl;

},{"./display":14,"./generators":15,"./html":17,"bbop-core":26,"underscore":108}],23:[function(require,module,exports){
/*
 * The framework to hang the rest of the ol' BBOP widgets on.
 *
 * @module: bbop-widget-set
 */

var us = require('underscore');
var bbop = require('bbop-core');

/**
 * "Constructor" for bbop-widget-set.
 *
 * Parameters:
 *  n/a
 *
 * @constructor
 * @returns {Object} bbop-widget-set object
 */
var set = function set(more_dispatch) {
  this._is_a = 'bbop-widget-set';
  var anchor = this;

  // // The (TODO: now unused?) API lib.
  // this.api = require('./api');

  // // TODO: No longer necessary w/NPM switch.
  // this.version = require('./version');

  // // TODO: Not entirely sure what this was doing anyways.
  //this.data.statistics = require('./data/statistics');
};

///
/// Exportable body.
///

module.exports.set = set;

// html subsection is safe.
module.exports.html = require('./html');
// generators subsection is safe.
module.exports.generators = require('./generators');
// graph tools are safe
module.exports.graph_tools = require('./graph_tools');
try {
  // not so safe subsets
  module.exports.display = require('./display');
  // actual final widgets
  module.exports.autocomplete_simple = require('./autocomplete_simple');
  module.exports.live_filters = require('./live_filters');
  module.exports.live_geospatial = require('./live_geospatial');
  module.exports.live_pager = require('./live_pager');
  module.exports.live_results = require('./live_results');
  module.exports.browse = require('./browse');
  module.exports.repl = require('./repl');
} catch (e) {
  //console.error(e);
  console.error('vvvvv');
  console.error('WARNING/BUG/TODO: Testing (?), so caught error when trying to pull in jQuery, as it fails on 1.9.1. This is solved for deployment using browserify. At some point need to upgrade to have an actually usable jQuery version in a node/npm environment, or at least a better behaved one.');
  console.error('^^^^^');
}

},{"./autocomplete_simple":12,"./browse":13,"./display":14,"./generators":15,"./graph_tools":16,"./html":17,"./live_filters":18,"./live_geospatial":19,"./live_pager":20,"./live_results":21,"./repl":22,"bbop-core":26,"underscore":108}],24:[function(require,module,exports){
(function (global){(function (){
////
//// A general set to get the search box at the top of most pages
//// going.
////

// Code here will be ignored by JSHint, as we are technically
// "redefining" jQuery (although we are not).
/* jshint ignore:start */
var jQuery = typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null;
//require('jquery-ui');
/* jshint ignore:end */

var bbop = require('bbop-core');
var bbop_widget_set = require("bbop-widget-set");

// Config.
var amigo = new (require('amigo2-instance-data'))(); // no overload
var golr_conf = require('golr-conf');
var gconf = new golr_conf.conf(amigo.data.golr);
var gserv = amigo.data.server.golr_base;
// Linker.
var linker = amigo.linker;
// Management.
var jquery_engine = require('bbop-rest-manager').jquery;
var golr_manager = require('bbop-manager-golr');
var golr_response = require('bbop-response-golr');
function GeneralSearchForwardingInit() {
  // For debugging.
  var logger = new bbop.logger('GSF: ');
  logger.DEBUG = true;
  function ll(str) {
    logger.kvetch(str);
  }
  var wired_name = 'gsf-query';

  // Use jQuery UI to tooltip-ify doc.
  var tt_args = {
    'position': {
      'my': 'left+5 top',
      'at': 'right top'
    },
    'tooltipClass': 'amigo-searchbar-tooltip-style'
  };
  jQuery('.bbop-js-tooltip').tooltip(tt_args);

  ///
  /// This next section is dedicated getting the autocomplete (and
  /// associated toggle) working.
  ///

  //
  jQuery('input:submit').prop('disabled', false);

  // Widget, default personality and filter.
  function forward(doc) {
    if (doc && doc['entity'] && doc['category']) {
      // Erase any val, change the placeholder (to try and
      // prevent races where the user selects and then hits
      // "search" before the forwarding finishes).
      jQuery('#' + wired_name).val('');
      jQuery('#' + wired_name).attr('placeholder', 'Forwarding to ' + doc['entity'] + '...');

      // Forward to the new doc.
      if (doc['category'] === 'ontology_class') {
        window.location.href = linker.url(doc['entity'], 'term');
      } else if (doc['category'] === 'bioentity') {
        window.location.href = linker.url(doc['entity'], 'gp');
      }
    }
  }

  // Set for the initial search box autocompleter.
  var general_args = {
    'fill_p': false,
    'label_template': '{{{entity_label}}} ({{entity}})',
    'value_template': '{{entity}}',
    'list_select_callback': forward
  };

  // Manager setup.
  var engine = new jquery_engine(golr_response);
  engine.method('GET');
  engine.use_jsonp(true);
  var manager = new golr_manager(gserv, gconf, engine, 'async');
  manager.set_personality('general'); // profile in gconf
  manager.add_query_filter('document_category', 'general');
  manager.add_query_filter('category', 'family', ['-']);

  // Actually initialize the widget.
  var auto = new bbop_widget_set.autocomplete_simple(manager, gserv, gconf, wired_name, general_args);
}

// Embed the jQuery setup runner.
(function () {
  jQuery(document).ready(function () {
    GeneralSearchForwardingInit();
  });
})();

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"amigo2-instance-data":1,"bbop-core":26,"bbop-manager-golr":29,"bbop-response-golr":32,"bbop-rest-manager":34,"bbop-widget-set":23,"golr-conf":57}],25:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],26:[function(require,module,exports){
/**
 * BBOP language extensions to JavaScript, complimenting Underscore.js.
 * Purpose: Helpful basic utilities and operations to fix common needs in JS.
 *
 * @module bbop-core 
 */

var us = require('underscore');
var each = us.each;

///
///
///

/**
 * Return the best guess (true/false) for whether or not a given
 * object is being used as a hash.
 *
 * @function
 * @name module:bbop-core#is_hash
 * @param {} in_thing - the thing in question
 * @returns {boolean} boolean
 */
function _is_hash(in_thing){
    var retval = false;
    if( in_thing && us.isObject(in_thing) &&
	! us.isArray(in_thing) &&
	! us.isFunction(in_thing) ){
	retval = true;
    }
    return retval;
}

/**
 * Return the string best guess for what the input is, null if it
 * can't be identified. In addition to the _is_a property convention,
 * current core output strings are: 'null', 'array', 'boolean',
 * 'number', 'string', 'function', and 'object'.
 * 
 * @function
 * @name module:bbop-core#what_is
 * @param {any} in_thing - the thing in question
 * @returns {string} string
 */
function _what_is(in_thing){
    var retval = null;
    if( typeof(in_thing) != 'undefined' ){
	
	// If it's an object, try and guess the 'type', otherwise, let
	// typeof.
	if( in_thing == null ){
	    retval = 'null';
	}else if( typeof(in_thing) == 'object' ){
	    
	    // Look for the 'is_a' property that I should be using.
	    if( typeof(in_thing._is_a) != 'undefined' ){
		retval = in_thing._is_a;
	    }else{
		if( us.isArray(in_thing) ){
		    retval = 'array';
		}else{
		    retval = 'object';
		}		
	    }
	}else{
	    retval = typeof(in_thing);
	}
    }
    return retval;
}

/**
 * Dump an object to a string form as best as possible. More meant for
 * debugging. This is meant to be an Object walker. For a slightly
 * different take (Object identification), see <to_string>.
 *
 * @see module:bbop-core.to_string
 * @function
 * @name module:bbop-core#dump
 * @param {} in_thing - something
 * @returns {string} string
 */
function _dump(thing){

    var retval = '';
    
    var what = _what_is(thing);
    if( what == null ){
	retval = 'null';
    }else if( what == 'null' ){
	retval = 'null';
    }else if( what == 'string' ){
	retval = '"' + thing + '"';
    }else if( what == 'boolean' ){
	if( thing ){
	    retval = "true";
	}else{
	    retval = "false";
	}
    }else if( what == 'array' ){
	
	var astack = [];
	each(thing, function(item, i){
	    astack.push(_dump(item));
	});
	retval = '[' + astack.join(', ') + ']';
	
    }else if( what == 'object' ){
	
	var hstack = [];
	each(thing, function(val, key){
	    hstack.push('"'+ key + '": ' + _dump(val));
	});
	retval = '{' + hstack.join(', ') + '}';
	
    }else{
	retval = thing;
    }
    
    return retval;
}

/**
 * (Deep) clone an object down to its atoms.
 *
 * @function
 * @name module:bbop-core#clone
 * @param {any} thing - whatever
 * @returns {any} a new whatever
 */
function _clone(thing){

    var clone = null;
    
    if( typeof(thing) === 'undefined' ){
	// Nothin' doin'.
	//print("looks undefined");
    }else if( typeof(thing) === 'function' ){
	// Dunno about this case...
	//print("looks like a function");
	clone = thing;
    }else if( typeof(thing) === 'boolean' ||
	      typeof(thing) === 'number' ||
	      typeof(thing) === 'string' ){
		  // Atomic types can be returned as-is (i.e. assignment in
		  // JS is the same as copy for atomic types).
		  //print("cloning atom: " + thing);
		  clone = thing;
	      }else if( typeof(thing) === 'object' ){
		  // Is it a null, hash, or an array?
		  if( thing == null ){
		      clone = null;
		  }else if( Array.isArray(thing) ){
		      // Looks like an array!
		      //print("looks like an array");
		      clone = [];
		      for(var i = 0; i < thing.length; i++){
			  clone[i] = _clone(thing[i]);
		      }
		  }else{
		      // Looks like a hash!
		      //print("looks like a hash");
		      clone = {};
		      for(var h in thing){
			  clone[h] = _clone(thing[h]);
		      }
		  }
	      }else{
		  // Then I don't know what it is--might be platform dep.
		  //print("no idea what it is");
	      }
    return clone;
}

/**
 * Attempt to return a two part split on the first occurrence of a
 * character.
 *
 * Returns '' for parts not found.
 * 
 * Unit tests make the edge cases clear.
 * 
 * @function
 * @name module:bbop-core#first_split
 * @param {String} character - the character to split on
 * @param {String} string - the string to split
 * @returns {Array} list of first and second parts
 */
function _first_split(character, string){

    var retlist = null;
    
    var eq_loc = string.indexOf(character);
    if( eq_loc == 0 ){
	retlist = ['', string.substr(eq_loc +1, string.length)];
    }else if( eq_loc > 0 ){
	var before = string.substr(0, eq_loc);
	var after = string.substr(eq_loc +1, string.length);
	retlist = [before, after];
    }else{
	retlist = ['', ''];
    }
    
    return retlist;
}

// Exportable body.
module.exports = {

    clone: _clone,
    dump: _dump,
    first_split: _first_split,
    is_hash: _is_hash,
    what_is: _what_is,

    /**
     * Crop a string nicely.
     * 
     * Returns: Nothing. Side-effects: throws an error if the namespace
     * defined by the strings is not currently found.
     * 
     * @param {} str - the string to crop
     * @param {} lim - the final length to crop to (optional, defaults to 10)
     * @param {} suff - the string to add to the end (optional, defaults to '')
     * @returns {string} cropped string
     */
    crop: function(str, lim, suff){
	var ret = str;
	
	var limit = 10;
	if( lim ){ limit = lim; }

	var suffix = '';
	if( suff ){ suffix = suff; }
	
	if( str.length > limit ){
	    ret = str.substring(0, (limit - suffix.length)) + suffix;
	}
	return ret;
    },

    /**
     * Fold a pair of hashes together, using the first one as an initial
     * template--only the keys in the default hash will be defined in the
     * final hash--and the second hash getting precedence.
     * 
     * The can be quite useful when defining functions--essentially
     * allowing a limited default value system for arguments.
     * 
     * @see module:bbop-core.merge
     * @param {object} default_hash - Template hash.
     * @param {object} arg_hash - Argument hash to match.
     * @returns {object} a new hash
     */
    fold: function(default_hash, arg_hash){

	if( ! default_hash ){ default_hash = {}; }
	if( ! arg_hash ){ arg_hash = {}; }

	var ret_hash = {};
	for( var key in default_hash ){
	    if( ! us.isUndefined(arg_hash[key]) ){
		ret_hash[key] = arg_hash[key];
	    }else{
		ret_hash[key] = default_hash[key];
	    }
	}
	return ret_hash;
    },

    /**
     * Merge a pair of hashes together, the second hash getting
     * precedence. This is a superset of the keys both hashes.
     * 
     * @see module:bbop-core.fold
     * @param {} older_hash - first pass
     * @param {} newer_hash - second pass
     * @returns {object} a new hash
     */
    merge: function(older_hash, newer_hash){

	if( ! older_hash ){ older_hash = {}; }
	if( ! newer_hash ){ newer_hash = {}; }

	var ret_hash = {};
	function _add (val, key){
	    ret_hash[key] = val;
	}
	each(older_hash, _add);
	each(newer_hash, _add);
	return ret_hash;
    },

    /**
     * Get the hash keys from a hash/object, return as an array.
     *
     * @param {} arg_hash - the hash in question
     * @returns {Array} an array of keys
     */
    get_keys: function(arg_hash){

	if( ! arg_hash ){ arg_hash = {}; }
	var out_keys = [];
	for (var out_key in arg_hash) {
	    if (arg_hash.hasOwnProperty(out_key)) {
		out_keys.push(out_key);
	    }
	}
	
	return out_keys;
    },

    /**
     * Returns a hash form of the argument array/list. For example ['a',
     * 'b'] would become {'a': true, 'b': true} or [['a', '12'], ['b',
     * '21']] would become {'a': '12', 'b': '21'}. Using mixed sub-lists
     * is undefined.
     *
     * @param {Array} list - the list to convert
     * @returns {object} a hash
     */
    hashify: function(list){
	var rethash = {};

	if( list && list[0] ){
	    if( us.isArray(list[0]) ){
		each(list, function(item){
		    var key = item[0];
		    var val = item[1];
		    if( ! us.isUndefined(key) ){
			rethash[key] = val;
		    }
		});
	    }else{
		each(list, function(item){
		    rethash[item] = true;
		});
	    }
	}

	return rethash;
    },

    // /**
    //  * Returns true if it things the two incoming arguments are value-wise
    //  * the same.
    //  * 
    //  * Currently only usable for simple (atomic single layer) hashes,
    //  * atomic lists, boolean, null, number, and string values. Will return
    //  * false otherwise.
    //  * 
    //  * @param {} thing1 - thing one
    //  * @param {} thing2 - thing two
    //  *
    //  * Returns: boolean
    //  */
    // is_same: function(thing1, thing2){

    // 	var retval = false;

    // 	// If is hash...steal the code from test.js.
    // 	if( _is_hash(thing1) && _is_hash(thing2) ){
    
    // 	    var same_p = true;
    
    // 	    // See if the all of the keys in hash1 are defined in hash2
    // 	    // and that they have the same ==.
    // 	    for( var k1 in thing1 ){
    // 		if( typeof thing2[k1] === 'undefined' ||
    // 		    thing1[k1] !== thing2[k1] ){
    // 			same_p = false;
    // 			break;
    // 		    }
    // 	    }

    // 	    // If there is still no problem...
    // 	    if( same_p ){
    
    // 		// Reverse of above.
    // 		for( var k2 in thing2 ){
    // 		    if( typeof thing1[k2] === 'undefined' ||
    // 			thing2[k2] !== thing1[k2] ){
    // 			    same_p = false;
    // 			    break;
    // 			}
    // 		}
    // 	    }

    // 	    retval = same_p;

    // 	}else if( bbop.core.is_array(thing1) && bbop.core.is_array(thing2) ){
    // 	    // If it's an array convert and pass it off to the hash function.
    // 	    retval = bbop.core.is_same(bbop.core.hashify(thing1),
    // 				       bbop.core.hashify(thing2));
    // 	}else{
    
    // 	    // So, we're hopefully dealing with an atomic type. If they
    // 	    // are the same, let's go ahead and try.
    // 	    var t1_is = _what_is(thing1);
    // 	    var t2_is = _what_is(thing2);
    // 	    if( t1_is == t2_is ){
    // 		if( t1_is == 'null' ||
    // 		    t1_is == 'boolean' ||
    // 		    t1_is == 'null' ||
    // 		    t1_is == 'number' ||
    // 		    t1_is == 'string' ){
    // 			if( thing1 == thing2 ){
    // 			    retval = true;
    // 			}
    // 		    }
    // 	    }
    // 	}

    // 	return retval;
    // },

    /**
     * Return the best guess (true/false) for whether or not a given
     * object is being used as an array.
     *
     * @param {} in_thing - the thing in question
     * @returns {boolean} boolean
     */
    is_array: function(in_thing){
	var retval = false;
	if( in_thing &&
	    Array.isArray(in_thing) ){
	    retval = true;
	}
	return retval;
    },

    /**
     * Return true/false on whether or not the object in question has any
     * items of interest (iterable?).
     *
     * @param {} in_thing - the thing in question
     * @returns {boolean} boolean
     */
    is_empty: function(in_thing){
	var retval = false;
	if( us.isArray(in_thing) ){
	    if( in_thing.length == 0 ){
		retval = true;
	    }
	}else if( _is_hash(in_thing) ){
	    var in_hash_keys = us.keys(in_thing);
	    if( in_hash_keys.length == 0 ){
		retval = true;
	    }
	}else{
	    // TODO: don't know about this case yet...
	    //throw new Error('unsupported type in is_empty');	
	    retval = false;
	}
	return retval;
    },

    /**
     * Return true/false on whether or not the passed object is defined.
     *
     * @param {} in_thing - the thing in question
     * @returns {boolean} boolean
     */
    is_defined: function(in_thing){
	var retval = true;
	if( typeof(in_thing) === 'undefined' ){
	    retval = false;
	}
	return retval;
    },

    /**
     * Take an array or hash and pare it down using a couple of functions
     * to what we want.
     * 
     * Both parameters are optional in the sense that you can set them to
     * null and they will have no function; i.e. a null filter will let
     * everything through and a null sort will let things go in whatever
     * order.
     *
     * @param {Array|Object} in_thing - hash or array
     * @param {Function} filter_function - hash (function(key, val)) or array (function(item, i)); this function must return boolean true or false.
     * @param {Function} sort_function - function to apply to elements: function(a, b); this function must return an integer as the usual sort functions do.
     * @returns {Array} array
     */
    pare: function(in_thing, filter_function, sort_function){

	var ret = [];
	
	// Probably an not array then.
	if( typeof(in_thing) === 'undefined' ){
	    // this is a nothing, to nothing....
	}else if( typeof(in_thing) != 'object' ){
	    throw new Error('Unsupported type in bbop.core.pare: ' +
			    typeof(in_thing) );
	}else if( us.isArray(in_thing) ){
	    // An array; filter it if filter_function is defined.
	    if( filter_function ){	
		each(in_thing, function(item, index){
		    if( filter_function(item, index) ){
			// filter out item if true
		    }else{
			ret.push(item);
		    }
		});
	    }else{
		each(in_thing, function(item, index){ ret.push(item); });
	    }
	}else if( us.isFunction(in_thing) ){
	    // Skip is function (which is also an object).
	}else if( us.isObject(in_thing) ){
	    // Probably a hash; filter it if filter_function is defined.
	    if( filter_function ){	
		each(in_thing, function(val, key){
		    if( filter_function(key, val) ){
			// Remove matches to the filter.
		    }else{
			ret.push(val);
		    }
		});
	    }else{
		each(in_thing, function(val, key){ ret.push(val); });
	    }
	}else{
	    // No idea what this is--skip.
	}

	// For both: sort if there is anything.
	if( ret.length > 0 && sort_function ){
	    ret.sort(sort_function);	    
	}

	return ret;
    },

    /**
     * Essentially add standard 'to string' interface to the string class
     * and as a stringifier interface to other classes. More meant for
     * output--think REPL. Only atoms, arrays, and objects with a
     * to_string function are handled.
     *
     * @see module:bbop-core.dump
     * @param {any} in_thing - something
     * @returns {string} string
     */
    to_string: function(in_thing){

	// First try interface, then the rest.
	if( in_thing &&
	    typeof(in_thing.to_string) !== 'undefined' &&
	    typeof(in_thing.to_string) == 'function' ){
		return in_thing.to_string();
	    }else{
		
		var what = _what_is(in_thing);
		if( what == 'number' ){
		    return in_thing.toString();
		}else if( what == 'string' ){
		    return in_thing;
		}else if( what == 'array' ){
		    return _dump(in_thing);
		    // }else if( what == 'object' ){
		    //     return bbop.core.dump(in_thing);
		    // }else{
		    //     return '[unsupported]';
		}else{
		    return in_thing;
		}
	    }
    },

    /**
     * Check to see if all top-level objects in a namespace supply an
     * "interface".
     * 
     * Mostly intended for use during unit testing.
     *
     * TODO: Unit test this to make sure it catches both prototype (okay I
     * think) and uninstantiated objects (harder/impossible?).
     *
     * @param {} iobj - the object/constructor in question
     * @param {} interface_list - the list of interfaces (as a strings) we're looking for
     * @returns {boolean} boolean
     */
    has_interface: function(iobj, interface_list){
	var retval = true;
	each(interface_list, function(iface){
	    //print('|' + typeof(in_key) + ' || ' + typeof(in_val));
	    //print('|' + in_key + ' || ' + in_val);
	    if( typeof(iobj[iface]) == 'undefined' &&
		typeof(iobj.prototype[iface]) == 'undefined' ){
		    retval = false;
		    throw new Error(_what_is(iobj) +
				    ' breaks interface ' + iface);
                }
	});
	return retval;
    },

    /**
     * Assemble an object into a GET-like query. You probably want to see
     * the tests to get an idea of what this is doing.
     * 
     * The last argument of double hashes gets quoted (Solr-esque),
     * otherwise not. It will try and avoid adding additional sets of
     * quotes to strings.
     *
     * This does nothing to make the produced "URL" in any way safe.
     * 
     * WARNING: Not a hugely clean function--there are a lot of special
     * cases and it could use a good (and safe) clean-up.
     * 
     * @param {} qargs - hash/object
     * @returns {string} string
     */
    get_assemble: function(qargs){

	var mbuff = [];
	for( var qname in qargs ){
	    var qval = qargs[qname];

	    // null is technically an object, but we don't want to render
	    // it.
	    if( qval != null ){
		if( typeof qval == 'string' || typeof qval == 'number' ){
		    // Is standard name/value pair.
		    var nano_buffer = [];
		    nano_buffer.push(qname);
		    nano_buffer.push('=');
		    nano_buffer.push(encodeURIComponent(qval));
		    mbuff.push(nano_buffer.join(''));
		}else if( typeof qval == 'object' ){
		    if( typeof qval.length != 'undefined' ){
			// Is array (probably).
			// Iterate through and double on.
			for(var qval_i = 0; qval_i < qval.length ; qval_i++){
			    var nano_buff = [];
			    nano_buff.push(qname);
			    nano_buff.push('=');
			    nano_buff.push(encodeURIComponent(qval[qval_i] || ''));
			    mbuff.push(nano_buff.join(''));
			}
		    }else{
			// // TODO: The "and" case is pretty much like
			// // the array, the "or" case needs to be
			// // handled carefully. In both cases, care will
			// // be needed to show which filters are marked.
			// Is object (probably).
			// Special "Solr-esque" handling.
			for( var sub_name in qval ){
			    var sub_vals = qval[sub_name];

			    // Since there might be an array down there,
			    // ensure that there is an iterate over it.
			    if( _what_is(sub_vals) != 'array' ){
				sub_vals = [sub_vals];
			    }

			    each(sub_vals, function(sub_val){
				var nano_buff = [];
				nano_buff.push(qname);
				nano_buff.push('=');
				nano_buff.push(sub_name);
				nano_buff.push(':');
				if( typeof sub_val !== 'undefined' && sub_val ){
				    // Do not double quote strings.
				    // Also, do not requote if we already
				    // have parens in place--that
				    // indicates a complicated
				    // expression. See the unit tests.
				    var val_is_a = _what_is(sub_val);
				    if( val_is_a == 'string' &&
					sub_val.charAt(0) == '"' &&
					sub_val.charAt(sub_val.length -1) == '"' ){
					    nano_buff.push(encodeURIComponent(sub_val));
					}else if( val_is_a == 'string' &&
						  sub_val.charAt(0) == '(' &&
						  sub_val.charAt(sub_val.length -1) == ')' ){
						      nano_buff.push(encodeURIComponent(sub_val));
						  }else{
						      nano_buff.push(encodeURIComponent('"' + sub_val + '"'));
						  }
				}else{
				    nano_buff.push(encodeURIComponent('""'));
				}
				mbuff.push(nano_buff.join(''));
			    });
			}
		    }
		}else if( typeof qval == 'undefined' ){
		    // This happens in some cases where a key is tried, but no
		    // value is found--likely equivalent to q="", but we'll
		    // let it drop.
		    // var nano_buff = [];
		    // nano_buff.push(qname);
		    // nano_buff.push('=');
		    // mbuff.push(nano_buff.join(''));
		}else{
		    throw new Error("bbop.core.get_assemble: unknown type: " +
				    typeof(qval));
		}
	    }
	}

	return mbuff.join('&');
    },

    /**
     * Random number generator of fixed length. Return a random number
     * string of length len.
     *
     * @param {} len - the number of random character to return.
     * @returns {string} string
     */
    randomness: function(len){

	var random_base = [
	    '1', '2', '3', '4', '5', '6', '7', '8', '9', '0',
	    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
	    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
	];
	var length = len || 10;
	var cache = new Array();
	for( var ii = 0; ii < length; ii++ ){
	    var rbase_index = Math.floor(Math.random() * random_base.length);
	    cache.push(random_base[rbase_index]);
	}
	return cache.join('');
    },

    /**
     * Return the parameters part of a URL.
     *
     * Unit tests make the edge cases clear.
     * 
     * @param {} url - url (or similar string)
     * @returns {Array} list of part lists
     */
    url_parameters: function(url){

	var retlist = [];

	// Pull parameters.
	var tmp = url.split('?');
	var path = '';
	var parms = [];
	if( ! tmp[1] ){ // catch bad url--nothing before '?'
	    parms = tmp[0].split('&');
	}else{ // normal structure
	    path = tmp[0];
	    parms = tmp[1].split('&');
	}

	// Decompose parameters.
	each(parms, function(p){
	    var c = _first_split('=', p);
	    if( ! c[0] && ! c[1] ){
		retlist.push([p]);
	    }else{
		retlist.push(c);		  
	    }
	});
	
	return retlist;
    },

    /**
     * Convert a string into something consistent for urls (getting icons,
     * etc.). Return a munged/hashed-down version of the resource.
     * Assembles, converts spaces to underscores, and all lowercases.
     * 
     * @param {} base - base url for the resource(s)
     * @param {} resource - the filename or whatever to be transformed
     * @param {} extension - *[optional]* the extension of the resource
     * @returns {string} string
     */
    resourcify: function(base, resource, extension){

	var retval = base + '/' + resource;

	// Add the extension if it is there.
	if( extension ){
	    retval += '.' + extension;	
	}

	// Spaces to underscores and all lowercase.
	//return retval.replace(/\ /g, "_", "g").toLowerCase();
	return retval.replace(/\ /g, "_").toLowerCase();
    },

    /**
     * RFC 4122 v4 compliant UUID generator.
     * From: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523
     *
     * @returns {string} string
     */
    uuid: function(){

	// Replace x (and y) in string.
	function replacer(c) {
	    var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
	    return v.toString(16);
	}
	var target_str = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';
	return target_str.replace(/[xy]/g, replacer);
    },

    /**
     * A sort function to put numbers in ascending order.
     * 
     * Useful as the argument to .sort().
     * 
     * See: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/sort
     * 
     * @param {number} a - the first number
     * @param {number} b - the second number
     * @returns {number} number of their relative worth
     */
    numeric_sort_ascending: function(a, b){
	return a - b;
    },

    /**
     * A sort function to put numbers in descending order.
     * 
     * Useful as the argument to .sort().
     * 
     * See: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/sort
     * 
     * @param {number} a - the first number
     * @param {number} b - the second number
     * @returns {number} number of their relative worth
     */
    numeric_sort_descending: function(a, b){
	return b - a;
    },

    /**
     * Remove the quotes from a string.
     * 
     * @param {string} str - the string to dequote
     * @returns {string} the dequoted string (or the original string)
     */
    dequote: function(str){
	var retstr = str;

	if( ! us.isUndefined(str) && str.length > 2 ){
	    var end = str.length -1;
	    if( str.charAt(0) == '"' && str.charAt(end) == '"' ){
		retstr = str.substr(1, end -1);
	    }
	}

	return retstr;
    },

    /**
     * Make sure that a substring exists at the beginning or end (or both)
     * of a string.
     * 
     * @param {} str - the string to ensure that has the property
     * @param {} add - the string to check for (and possibly add)
     * @param {} place - *[optional]* "front"|"back", place to ensure (defaults to both)
     * @returns {string} a new string with the property enforced
     */
    ensure: function(str, add, place){

	// 
	var do_front = false;
	var do_back = false;
	if( us.isUndefined(place) ){
	    do_front = true;
	    do_back = true;
	}else if( place == 'front' ){
	    do_front = true;
	}else if( place == 'back' ){
	    do_back = true;
	}else{
	    // Don't know what it is, not doing anything.
	}

	//
	var strlen = str.length;
	var addlen = add.length;
	var front_substr = str.substr(0, addlen);
	var back_substr = str.substr((strlen - addlen), (strlen -1));

	//
	var front_add = '';
	if( do_front && front_substr != add ){
	    front_add = add;
	}
	var back_add = '';
	if( do_back && back_substr != add ){
	    back_add = add;
	}

	// console.log('do_front: ' + do_front);
	// console.log('do_back: ' + do_back);
	// console.log('str.length: ' + strlen);
	// console.log('add.length: ' + addlen);
	// console.log('front_substr: ' + front_substr);
	// console.log('back_substr: ' + back_substr);
	// console.log('front_add: ' + front_add);
	// console.log('back_add: ' + back_add);

	return front_add + str + back_add;
    },

    /**
     * Trim the leading and trailing whitespace from a string.
     * Named differently so as not to confuse with JS 1.8.1's trim().
     * 
     * @param {string} str - the string to ensure that has the property
     * @returns {string} the trimmed string
     */
    chomp: function(str){

	var retstr = '';

	retstr = str.replace(/^\s+/,'');
	retstr = retstr.replace(/\s+$/,'');

	return retstr;
    },

    /**
     * Break apart a string on certain delimiter.
     * 
     * @param {} str - the string to ensure that has the property
     * @param {} delimiter - *[optional]* either a string or a simple regexp; defaults to ws
     *
     * @returns {Array} a list of separated substrings
     */
    splode: function(str, delimiter){

	var retlist = null;

	if( ! us.isUndefined(str) ){
	    if( us.isUndefined(delimiter) ){
		delimiter = /\s+/;
	    }
	    
	    retlist = str.split(delimiter);
	}

	return retlist;
    },

    // // Giving up on this for now: the general case seems too hard to work with 
    // // in so many different, contradictory, and changing environments.
    // /**
    //  * Getting a cross-platform that can evaluate to the global namespace
    //  * seems a little bit problematic. This is an attempt to wrap that all
    //  * away.
    //  * 
    //  * This is not an easy problem--just within browsers there are a lot
    //  * of issues:
    //  * http://perfectionkills.com/global-eval-what-are-the-options/ After
    //  * that, the server side stuff tries various ways to keep you from
    //  * affecting the global namespace in certain circumstances.
    //  * 
    //  * @param {} to_eval - the string to evaluate
    //  * 
    //  * Returns:
    //  *  A list with the following fields: retval, retval_str, okay_p, env_type.
    //  */
    // evaluate: function(to_eval){

    //     var retval = null;
    //     var retval_str = '';
    //     var okay_p = true;
    //     var env_type = 'server';

    //     // Try and detect our environment.
    //     try{
    // 	if( bbop.core.is_defined(window) &&
    // 	    bbop.core.is_defined(window.eval) &&
    // 	    bbop.core.what_is(window.eval) == 'function' ){
    // 		env_type = 'browser';
    // 	    }
    //     } catch (x) {
    // 	// Probably not a browser then, right? Hopefully all the
    // 	// servers that we'll run into are the same (TODO: check
    // 	// nodejs).
    //     }
    //     print('et: ' + env_type);

    //     // Now try for the execution.
    //     try{
    // 	// Try and generically evaluate.
    // 	if( env_type == 'browser' ){
    // 	    print('eval as if (browser)');
    // 	    retval = window.eval(to_eval);
    // 	}else{
    // 	    // TODO: Does this work?
    // 	    print('eval as else (server)');
    // 	    //retval = this.eval(to_eval);		
    // 	    retval = bbop.core.global.eval(to_eval);
    // 	}
    //     }catch (x){
    // 	// Bad things happened.
    // 	print('fail on: (' + retval +'): ' + to_eval);
    // 	retval_str = '[n/a]';
    // 	okay_p = false;
    //     }
    
    //     // Make whatever the tmp_ret is prettier for the return string.
    //     if( bbop.core.is_defined(retval) ){
    // 	if( bbop.core.what_is(retval) == 'string' ){
    // 	    retval_str = '"' + retval + '"';
    // 	}else{
    // 	    retval_str = retval;
    // 	}
    //     }else{
    // 	// Return as-is.
    //     }

    //     return [retval, retval_str, okay_p, env_type];
    // };

    /**
     * What seems to be a typical idiom for subclassing in JavaScript.
     * 
     * This attempt has been scraped together from bits here and there and
     * lucid explanations from Mozilla:
     * 
     * https://developer.mozilla.org/en-US/docs/JavaScript/Introduction_to_Object-Oriented_JavaScript
     * https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Details_of_the_Object_Model
     * https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Inheritance_Revisited
     * https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/new
     * 
     * @param {} subclass - the subclass object
     * @param {} superclass - the superclass object
     */
    extend: function(subclass, baseclass){

	// Create a temporary nothing so that we don't fiddle the
	// baseclass's(?) with what we do to subclass later on.
	function tmp_object(){}

	// This nothings prototype gets the base class's.
	tmp_object.prototype = baseclass.prototype;

	// We instantiate the tmp_object, whose prototype is the
	// baseclass's; we make subclass's prototype this object, giving
	// us something that is very much like baseclass.
	subclass.prototype = new tmp_object; // same as: "new tmp_object();"

	// Now we go back and make the constructor of subclass actually
	// subclass again--we blew it away in the last step. Now we have a
	// subclass constructor with the protoype of baseclass.
	subclass.prototype.constructor = subclass;

	// // Create a property to allow access to the constructor of
	// // baseclass. This is useful when subclass needs access to
	// // baseclass's constructor for property setting.
	// subclass.base_constructor = baseclass;

	// // Create a property to
	// subclass.parent_class = baseclass.prototype;
    },

    /**
     * BBOP JS logger object. Using .kvetch(), you can automatically log a
     * message in almost any environment you find yourself in--browser,
     * server wherever. Also, if you have jQuery available and an element
     * with the id "bbop-logger-console-textarea",
     * "bbop-logger-console-text", or "bbop-logger-console-html", the
     * logger will append to that element (with a "\n" (autoscroll), "\n",
     * or "<br />" terminator respectively) instead.
     *
     * @constructor
     * @param {string} initial_context - (optional) initial context as string.
     */
    logger: function(initial_context){

	/**
	 * Different debugging available per object. Externally toggle
	 * between true and false to switch on and off the logging.
	 *
	 * @variable {boolean}
	 */
	this.DEBUG = false;

	var anchor = this;

	// Define an optional context to tag onto the front of messages.
	this._context = [];
	if( initial_context ){
	    this._context = [initial_context];
	}

	/**
	 * Define the ability to reset the contex.
	 * 
	 * @param {string} new_initial_context - (optional) new context to start with
	 */
	this.reset_context = function(new_initial_context){
	    if( new_initial_context ){
		this._context = [new_initial_context];
	    }else{
		this._context = [];	    
	    }
	};

	/**
	 * Add an additional logging context to the stack.
	 * 
	 * @param {string} new_context - New context to add to the context stack.
	 */
	this.push_context = function(new_context){
	    this._context.push(new_context);
	};

	/**
	 * Remove the last context if it's there.
	 */
	this.pop_context = function(){
	    var popped_context = null;
	    if( this._context.length > 0 ){
		popped_context = this._context.pop();
	    }
	    return popped_context;
	};

	// Generalizer console (or whatever) printing.
	this._console_sayer = function(){};

	if( typeof(jQuery) != 'undefined' && jQuery('#' + 'bbop-logger-console-html') != 'undefined' && jQuery('#' + 'bbop-logger-console-html').length ){
	    // Our own logging console takes precedence. 
	    this._console_sayer = function(msg){
		var area = jQuery('#'+ 'bbop-logger-console-html');
		area.append(msg + "<br />");
		try{
    		    area.scrollTop(area[0].scrollHeight);
		} catch (x) {
		    // could scroll
		}
		//jQuery('#'+'bbop-logger-console-html').append(msg + "<br />");
	    };
	}else if( typeof(console) != 'undefined' && typeof(console.log) == 'function' ){
	    // This may be okay for Chrome and a subset of various
	    // console loggers. This should now include FF's Web
	    // Console and NodeJS.  this._console_sayer =
	    // function(msg){ console.log(msg + "\n"); }; These
	    // usually seem to have "\n" incorporated now.
	    this._console_sayer = function(msg){ console.log(msg); };
	}else if( typeof(opera) != 'undefined' && typeof(opera.postError) == 'function' ){
	    // If Opera is in there, probably Opera.
	    this._console_sayer = function(msg){ opera.postError(msg + "\n"); };
	}else if( typeof(window) != 'undefined' && typeof(window.dump) == 'function' ){
	    // From developer.mozilla.org: To see the dump output you
	    // have to enable it by setting the preference
	    // browser.dom.window.dump.enabled to true. You can set
	    // the preference in about:config or in a user.js
	    // file. Note: this preference is not listed in
	    // about:config by default, you may need to create it
	    // (right-click the content area -> New -> Boolean).
	    this._console_sayer = function(msg){ dump( msg + "\n"); };
	}else if( typeof(window) != 'undefined' && typeof(window.console) != 'undefined' && typeof(window.console.log) == 'function' ){
	    // From developer.apple.com: Safari's "Debug" menu allows
	    // you to turn on the logging of JavaScript errors. To
	    // display the debug menu in Mac OS X, open a Terminal
	    // window and type: "defaults write com.apple.Safari
	    // IncludeDebugMenu 1" Need the wrapper function because
	    // safari has personality problems.
	    this._console_sayer = function(msg){ window.console.log(msg + "\n"); };
	}else if( typeof(build) == 'function' && typeof(getpda) == 'function' && typeof(pc2line) == 'function' && typeof(print) == 'function' ){
	    // This may detect SpiderMonkey on the comand line.
	    this._console_sayer = function(msg){ print(msg); };
	}else if( typeof(org) != 'undefined' && typeof(org.rhino) != 'undefined' && typeof(print) == 'function' ){
	    // This may detect Rhino on the comand line.
	    this._console_sayer = function(msg){ print(msg); };
	}
	
	/**
	 * Log a string to somewhere. Also return a string to (mostly for
	 * the unit tests).
	 * 
	 * @param {string} initial_context - (optional) initial context as string
	 * @returns {string} string to print out to wherever we found
	 */
	this.kvetch = function(string){
	    var ret_str = null;
	    if( anchor.DEBUG == true ){

		// Make sure there is something there no matter what.
		if( typeof(string) == 'undefined' ){ string = ''; }

		// Redefined the string a little if we have contexts.
		if( anchor._context.length > 0 ){
		    var cstr = anchor._context.join(':');
		    string = cstr + ': '+ string;
		}

		// Actually log to the console.
		anchor._console_sayer(string);

		// Bind for output.
		ret_str = string;
	    }
	    return ret_str;
	};
    }

};

},{"underscore":108}],27:[function(require,module,exports){
/** 
 * Purpose: Basic edged graph and operations.
 * 
 * NOTE: A model instance may not be the whole graph, just a
 * subgraph--this is the difference between nodes and
 * named_nodes. nodes are real things, while named_nodes are things
 * referenced by edges.
 * 
 * Check TODOs, we would like everything as linear as possible.
 * 
 * TODO: memoize everything but add_*. Functional enough that it
 * should work if we just empty the caches after every add_* op.
 * 
 * @module bbop-graph
 */

var us = require('underscore');
var each = us.each;
var keys = us.keys;
var bbop = require('bbop-core');

///
/// Okay, first off, definitions and prototypes of everything we need
/// to work.
///

// Common point for assigning the default predicate in here.
var default_predicate = 'points_at';

///
/// Node sub-object.
///

/**
 * Contructor for a BBOP graph model node.
 * 
 * @constructor
 * @param {string} new_id - a unique id for the node
 * @param {string} new_label - (optional) a user-friendly description of the node
 * @returns {this} new bbop model node
 */
function node(new_id, new_label){
    this._is_a = 'bbop-graph.node';
    this._id = new_id || null;
    this._label = new_label || null;

    // Only have a real type if the constructor went properly.
    this._type = 'node';

    this._metadata = null;
}

/**
 * Getter/setter for node id.
 *
 * @param {string} value - (optional) new value for this property to take
 * @returns {string} string
 */
node.prototype.id = function(value){
    if(value){ this._id = value; }
    return this._id;
};

/**
 * Getter/setter for node type.
 *
 * @param {string} value - (optional) new value for this property to take
 * @returns {string} string
 */
node.prototype.type = function(value){
    if(value){ this._type = value; }
    return this._type; };

/**
 * Getter/setter for node label.
 *
 * @param {string} value - (optional) new value for this property to take
 * @returns {string} string
 */
node.prototype.label = function(value){
    if(value){ this._label = value; }
    return this._label;
 };

/**
 * Getter/setter for node metadata.
 * 
 * The metadata value does not necessarily have to be an atomic type.
 *
 * @param {Object} value - (optional) new value for this property to take; only objects (not Arrays)
 * @returns {Object|null} value
 */
node.prototype.metadata = function(value){
    if( us.isObject(value) && ! us.isArray(value) ){
	this._metadata = value;
    }
    return this._metadata;
 };

/**
 * Get a fresh new copy of the current node (using bbop.clone for
 * metadata object). This includes copying the ID--you'd have to
 * change it on your own.
 *
 * @returns {node} node
 */
node.prototype.clone = function(){

    // Base.
    var new_clone = new node();

    // ID.
    new_clone.id(this.id());

    // Label.
    new_clone.label(this.label());

    // Type.
    new_clone.type(this.type());

    // Meta.
    new_clone.metadata(bbop.clone(this.metadata()));

    return new_clone;
};

///
/// Edge sub-object.
///

/**
 * Contructor for a BBOP graph model edge.
 * 
 * If no predicate is given, <default_predicate> is used.
 * Predicates are currently treated as raw strings.
 * 
 * Note that these edges have no ID associated with them.
 * 
 * @constructor
 * @param {string} subject - node id string or node
 * @param {string} object - node id string or node
 * @param {string} predicate - (optional) a user-friendly description of the node
 * @returns {edge} bbop model edge
 */
function edge(subject, object, predicate){
    this._is_a = 'bbop-graph.edge';

    if( ! subject || ! object ){
	throw new Error('incomplete arguments for new edge');
    }

    /**
     * The predicate we'll use when none other is defined. You can
     * probably safely ignore this if all of the edges in your graph are
     * the same.
     *
     * @variable
     */
    this.default_predicate = default_predicate;

    // Either a string or a node.
    if( typeof(subject) === 'string' ){
	this._subject_id = subject;	
    }else if( subject.id && typeof(subject.id) === 'function' ){
	this._subject_id = subject.id();
    }else{
	throw new Error('cannot parse subject argument for edge');
    }

    // Either a string or a node.
    if( typeof(object) === 'string' ){
	this._object_id = object;	
    }else if( object.id && typeof(object.id) === 'function' ){
	this._object_id = object.id();
    }else{
	throw new Error('cannot parse object argument for edge');
    }

    // Predicate default or incoming.
    this._predicate_id = this.default_predicate;
    if( predicate ){
	this._predicate_id = predicate;
    }

    // Only have a real type if the constructor went properly.
    this._type = 'edge';

    //
    this._metadata = null;
}

/**
 * Getter/setter for edge subject id.
 *
 * @returns {string} string
 */
edge.prototype.subject_id = function(){
    return this._subject_id;
};

/**
 * Getter/setter for edge object id.
 *
 * @returns {string} string
 */
edge.prototype.object_id = function(){
    return this._object_id;
};

/**
 * Getter/setter for edge predicate id.
 *
 * @returns {string} string
 */
edge.prototype.predicate_id = function(){
    return this._predicate_id;
};

/**
 * Getter/setter for edge type.
 *
 * @param {String} value - (optional) new value for this property to take
 * @returns {String} string
 */
edge.prototype.type = function(value){
    if( typeof(value) !== 'undefined' ){
	this._type = value;
    }
    return this._type;
};

/**
 * Getter/setter for edge metadata.
 * 
 * The metadata value does not necessarily have to be an atomic type.
 *
 * @param {Object} value - (optional) new value for this property to take; only objects (not Arrays)
 * @returns {Object|null} value
 */
edge.prototype.metadata = function(value){
    if( us.isObject(value) && ! us.isArray(value) ){
	this._metadata = value;
    }
    return this._metadata;
 };

/**
 * Get a fresh new copy of the current edge (using bbop.clone for
 * metadata object).
 *
 * @returns {edge} - new copy of edge
 */
edge.prototype.clone = function(){

    // Base.
    var new_clone = new edge(this.subject_id(),
			     this.object_id(),
			     this.predicate_id());

    // Predicate.
    new_clone.default_predicate = this.default_predicate;

    // Type.
    new_clone.type(this.type());

    // Metadata.
    new_clone.metadata(bbop.clone(this.metadata()));

    return new_clone;
};

///
/// Graph sub-object.
///

/**
 * Contructor for a BBOP graph model graph.
 * 
 * TODO: make compilation piecewise with every added node and edge.
 * 
 * @constructor
 * @returns {graph} bbop model graph
 */
function graph(){
    this._is_a = 'bbop-graph.graph';

    /**
     * The predicate we'll use when none other is defined. You can
     * probably safely ignore this if all of the edges in your graph are
     * the same.
     *
     * @variable
     */
    this.default_predicate = default_predicate;

    this._id = null;
    this._metadata = null;

    // A per-graph logger.
    this._logger = new bbop.logger(this._is_a);
    this._logger.DEBUG = true;
    //this._logger.DEBUG = false;
    //function ll(str){ anchor._logger.kvetch(str); }

    // For node and edge (hash not possible for edges--only relation,
    // not "real").
    this._nodes = {}; // node_id -> node
    this._edge_list = []; // just an easy access list (hard to pull from sop)
    this._predicates = {}; // reference count

    // Useful for things like leaves, roots, dangling, and
    // singletons--all things referenced by edges.
    this._subjects = {}; // reference count
    this._objects = {}; // reference count

    // New parallel structures to for our simplified graph.
    this._so_table = {}; // reference count
    this._os_table = {}; // reference count
    this._sop_table = {}; // [sub][obj][pred] = edge

    // Table structures for quick lookups of node properties.
    this._is_a_singleton_lookup = {}; // node_id -> true
}

/**
 * Create an edge for use in internal operations.
 *
 * @param {string} subject - node id string or node
 * @param {string} object - node id string or node
 * @param {string} predicate - (optional) a user-friendly description of the node
 * @returns {edge} bbop model edge
 */
graph.prototype.create_edge = function(subject, object, predicate){
    return new edge(subject, object, predicate);
};

/**
 * Create a node for use in internal operations.
 *
 * @param {string} new_id - a unique id for the node
 * @param {string} new_label - (optional) a user-friendly description of the node
 * @returns {node} new bbop model node
 */
graph.prototype.create_node = function(new_id, new_label){
    return new node(new_id, new_label);
};

/**
 * Create a graph for use in internal operations.
 *
 * @returns {graph} bbop model graph
 */
graph.prototype.create_graph = function(){
    return new graph();
};

/**
 * Getter/setter for graph metadata.
 * 
 * The metadata value does not necessarily have to be an atomic type.
 *
 * @param {Object} value - (optional) new value for this property to take; only objects (not Arrays)
 * @returns {Object|null} value
 */
graph.prototype.metadata = function(value){
    if( us.isObject(value) && ! us.isArray(value) ){
	this._metadata = value;
    }
    return this._metadata;
 };

/**
 * Create a clone of the graph.
 *
 * @returns {graph} bbop model graph
 */
graph.prototype.clone = function(){
    var anchor = this;

    var new_graph = anchor.create_graph();

    // Collect the nodes and edges.
    each(anchor.all_nodes(), function(node){
	//console.log('nid: ' + node.id());
	new_graph.add_node(node.clone());
    });
    each(anchor.all_edges(), function(edge){
	//console.log('eid: ' + edge.subject());
	new_graph.add_edge(edge.clone());
    });

    // Collect other information.
    new_graph.default_predicate = anchor.default_predicate;
    new_graph._id = anchor._id;

    // Meta.
    new_graph.metadata(bbop.clone(this.metadata()));

    return new_graph;
};

/**
 * Getter/setter for the graph id.
 *
 * @param {string} value - (optional) new value for this property to take
 * @returns {string} string
 */
graph.prototype.id = function(value){
    if( value ){ this._id = value; }
    return this._id;
};

/**
 * See if the graph self-reports as incomplete.
 * Should be true, unless metadata has
 *
 * @returns {Boolean} whether or not all nodes/edges are represented
 */
graph.prototype.incomplete_p = function(){

    var ret = false;

    if( this._metadata ){
	if( typeof( this._metadata['incomplete-p'] !== 'undefined' ) ){
	    var inc = this._metadata['incomplete-p'];
	    if( inc === true || inc === 'true' ){
		ret = true;
	    }
	}
    }

    return ret;
};

/**
 * Return the number of self-reported nodes.
 * Should be nodes.length, unless incomplete_p, in which case it will
 * search for a count in the metadata.
 *
 * @returns {Number} number of nodes represented
 */
graph.prototype.complete_node_count = function(){

    var ret = null;

    if( this.incomplete_p() ){
	if( typeof( this._metadata['complete-node-count'] !== 'undefined' ) ){
	    var cnt = this._metadata['complete-node-count'];
	    if( us.isNumber(cnt) || us.isString(cnt) ){
		ret = parseInt(cnt);
	    }
	}
    }

    // Apparently not incomplete, or at least not structured
    // correctly. Grab the counts instead.
    if( ret === null ){
	ret = this.all_nodes().length;
    }

    return ret;
};

/**
 * Return the number of self-reported edges.
 * Should be edges.length, unless incomplete_p, in which case it will
 * search for a count in the metadata.
 *
 * @returns {Number} number of edges represented
 */
graph.prototype.complete_edge_count = function(){

    var ret = null;

    if( this.incomplete_p() ){
	if( typeof( this._metadata['complete-edge-count'] !== 'undefined' ) ){
	    var cnt = this._metadata['complete-edge-count'];
	    if( us.isNumber(cnt) || us.isString(cnt) ){
		ret = parseInt(cnt);
	    }
	}
    }

    // Apparently not incomplete, or at least not structured
    // correctly. Grab the counts instead.
    if( ret === null ){
	ret = this.all_edges().length;
    }

    return ret;
};

/**
 * Add a node to the graph.
 *
 * @param {node} node - node to add to the graph
 */
graph.prototype.add_node = function(node){

    // Check for anything funny.
    if( ! node.id() ){
	throw new Error("no anonymous nodes: " + node.id());
    }else{

	var nid = node.id();
	
	// Add it to all the concerned recall data structures.
	this._nodes[ nid ] = node;
	
	// If this does not belong to any relation so far, then it is a
	// singleton.
	if( ! this._subjects[ nid ] && ! this._objects[ nid ] ){
	    this._is_a_singleton_lookup[ nid ] = true;
	}
    }
};

/**
 * Remove a node from the graph.
 *
 * @param {String} node_id - the id for a node
 * @param {Boolean} clean_p - (optional) remove all edges connects to node (default false)
 * @returns {Boolean} true if node found and destroyed
 */
graph.prototype.remove_node = function(node_id, clean_p){
    var anchor = this;
    
    var ret = false;

    //console.log('remove node: ' + node_id);

    // Only remove extant nodes.
    if( anchor.get_node(node_id) ){
	ret = true;

	// Add it to all the concerned recall data structures.
	delete anchor._nodes[ node_id ];
	
	// Non-extant nodes are not singletons.
	delete anchor._is_a_singleton_lookup[ node_id ];

	// Dispose of any associated edges.
	if( clean_p ){

	    // Find all the possible extant edges.
	    var edge_pairs = [];
	    if( anchor._so_table[ node_id ] ){		
		each(keys(anchor._so_table[node_id] ), function(obj_id){
		    edge_pairs.push([node_id, obj_id]);
		});
	    }
	    if( anchor._os_table[ node_id ] ){		
		each(keys(anchor._os_table[node_id] ), function(sub_id){
		    edge_pairs.push([sub_id, node_id]);
		});
	    }

	    // Remove the edges from these pairs.
	    each(edge_pairs, function(pair){
		var expanded_edges = anchor.get_edges(pair[0], pair[1]);
		each(expanded_edges, function(edge){
		    anchor.remove_edge(edge.subject_id(), 
				       edge.object_id(), 
				       edge.predicate_id());
		});
	    });
	}
    }

    return ret;
};

/**
 * Add an edge to the graph.
 *
 * @param {edge} edge - edge to add to the graph
 */
graph.prototype.add_edge = function(edge){

    //
    var sub_id = edge.subject_id();
    var obj_id = edge.object_id();
    var pred_id = edge.predicate_id();

    // First, attempt to remove the edge.
    var is_new_triple = true;
    if( this.remove_edge(sub_id, obj_id, pred_id) ){
	is_new_triple = false;
    }

    // Subject -> object -> refcount.
    if( ! this._so_table[ sub_id ] ){ // ensure
	this._so_table[ sub_id ] = {};
    }
    if( typeof(this._so_table[ sub_id ][ obj_id ]) === 'undefined' ){
	this._so_table[ sub_id ][ obj_id ] = 1;
    }else{
	this._so_table[ sub_id ][ obj_id ]++;
    }

    // Object -> subject -> refcount.
    if( ! this._os_table[ obj_id ] ){ // ensure
	this._os_table[ obj_id ] = {};
    }
    if( typeof(this._os_table[ obj_id ][ sub_id ]) === 'undefined' ){
	this._os_table[ obj_id ][ sub_id ] = 1;
    }else{
	this._os_table[ obj_id ][ sub_id ]++;
    }

    // Subject -> object -> predicate -> edge.
    if( ! this._sop_table[ sub_id ] ){ // ensure
	this._sop_table[ sub_id ] = {};
    }
    if( ! this._sop_table[ sub_id ][ obj_id ] ){ // deeper ensure
	this._sop_table[ sub_id ][obj_id] = {};
    }
    // Blow away old either way--new or replacement.
    this._sop_table[ sub_id ][ obj_id ][ pred_id ] = edge;

    // If this is a new predicate, count of 1; otherwise increment
    // only if this is a new edge.
    if( ! this._predicates[ pred_id ] ){
	this._predicates[ pred_id ] = 1;
    }else{
	// Only increment if it's a new triple (pred).
	//if( is_new_triple ){ this._predicates[ pred_id ]++; }
	this._predicates[ pred_id ]++;
    }

    // Update reference counts for subjects.
    if( ! this._subjects[ sub_id ] ){
	this._subjects[ sub_id ] = 1;
    }else{
	// Only increment if it's a new triple (pred).
	//if( is_new_triple ){ this._subjects[ sub_id ]++; }
	this._subjects[ sub_id ]++;
    }

    // Update reference counts for objects.
    if( ! this._objects[ obj_id ] ){
	this._objects[ obj_id ] = 1; 
    }else{
	// Only increment if it's a new triple (pred).
	//if( is_new_triple ){ this._objects[ obj_id ]++; }
	this._objects[ obj_id ]++;
    }

    // Remove the edge's subject and object from the singleton
    // table--they are now referenced by something.
    if( this._is_a_singleton_lookup[ sub_id ] ){
	delete this._is_a_singleton_lookup[ sub_id ];
    }
    if( this._is_a_singleton_lookup[ obj_id ] ){
	delete this._is_a_singleton_lookup[ obj_id ];
    }

    // Onto the array and subject and object into named bodies.
    this._edge_list.push(edge);
};

/**
 * Remove an edge to the graph.
 * The edge as referenced.
 *
 * @param {String} subject_id - subject by ID
 * @param {String} object_id - object by ID
 * @param {String} predicate_id - (Optional) predicate ID or default
 * @returns {Boolean} true if such an edge was found and deleted, false otherwise
 */
graph.prototype.remove_edge = function(subject_id, object_id, predicate_id){
    var anchor = this;

    // Ensure predicate.
    if( ! predicate_id ){ predicate_id = this.default_predicate; }

    // First determine if such an edge exists.
    var ret = false;
    var edge = this.get_edge(subject_id, object_id, predicate_id);
    if( edge ){
	ret = true; // looks like we have it.

	// Does this subject appear elsewhere? Decrement or eliminate
	// as necessary.
	if( this._subjects[ subject_id ] === 1 ){
	    delete this._subjects[ subject_id ];
	}else{
	    this._subjects[ subject_id ]--;
	}

	// Does this object appear elsewhere? Decrement or eliminate
	// as necessary.
	if( this._objects[ object_id ] === 1 ){
	    delete this._objects[ object_id ];
	}else{
	    this._objects[ object_id ]--;
	}

	// Does this predicate appear elsewhere? Decrement or
	// eliminate as necessary.
	if( this._predicates[ predicate_id ] === 1 ){
	    delete this._predicates[ predicate_id ];
	}else{
	    this._predicates[ predicate_id ]--;
	}

	// Remove from SOP. Don't need to do more as SOP is not
	// probed, just used as a lookup.
	delete this._sop_table[ subject_id ][ object_id ][ predicate_id ];

	// Remove from edge_list.
	this._edge_list = us.reject(this._edge_list, function(edge){
	    var ret = false;
	    if( edge.subject_id() === subject_id &&
		edge.object_id() === object_id &&
		edge.predicate_id() === predicate_id ){
		ret = true;
	    }
	    return ret;
	});

	// SO rels decrement or eliminate.
	if( this._so_table[ subject_id ][ object_id ] === 1 ){
	    delete this._so_table[ subject_id ][ object_id ];
	}else{
	    this._so_table[ subject_id ][ object_id ]--;
	}
	
	// OS rels decrement or eliminate.
	if( this._os_table[ object_id ][ subject_id ] === 1 ){
	    delete this._os_table[ object_id ][ subject_id ];
	}else{
	    this._os_table[ object_id ][ subject_id ]--;
	}
	
	// Do we make any singletons with this removal?
	// Was the subject singletoned?
	if( this._nodes[subject_id] && // can't singleton if not there
	    ! this._subjects[ subject_id ] && ! this._objects[ subject_id ] ){
	    this._is_a_singleton_lookup[ subject_id ] = true;
	}
	// Was the object singletoned?
	if( this._nodes[object_id] &&  // can't singleton if not there
	    ! this._subjects[ object_id ] && ! this._objects[ object_id ] ){
	    this._is_a_singleton_lookup[ object_id ] = true;
	}

	// Anybody to be removed from the list of dangling?
	// TODO: named_nodes no more?
    }

    return ret;
};

/**
 * Returns an /original/ list of all added nodes.
 *
 * @returns {Array} array of {node}
 */
graph.prototype.all_nodes = function(){
    return us.values(this._nodes);
};

/**
 * Returns an /original/ list of all added edges.
 *
 * @returns {Array} array of {edge}
 */
graph.prototype.all_edges = function(){
    return this._edge_list;
};

/**
 * Returns an /original/ list of all added predicates.
 *
 * @returns {Array} array of predicates (strings)
 */
graph.prototype.all_predicates = function(){
    return keys(this._predicates);
};

/**
 * List all external nodes by referenced id.
 *
 * @returns {Array} array of strings: external nodes by id
 */
graph.prototype.all_dangling = function(){
    var anchor = this;

    // All named nodes, real or not (edge view).
    var named_nodes = keys(this._subjects).concat( keys(this._objects) );

    // Disjoint of named and extant.
    var unnamed = [];
    each(named_nodes, function(named_id){
	if( ! anchor._nodes[named_id] ){
	    unnamed.push(named_id);
	}
    });
    return unnamed;
};

/**
 * Any bad parts in graph? Essentially, make sure that there are no
 * weird references and nothing is dangling.
 *
 * @returns {Boolean} boolean
 */
graph.prototype.is_complete = function(){
    var retval = true;
    if( this.all_dangling().length > 0 ){
	retval = false;
    }
    return retval;
};

/**
 * Return a /copy/ of a node by id (not the original) if extant.
 *
 * @param {string} nid - the id of the node we're looking for
 * @returns {node} - copy of bbop model node
 */
graph.prototype.get_node = function(nid){
    var retnode = null;
    if( this._nodes[ nid ] ){
	var tmp_node = this._nodes[ nid ];
	retnode = tmp_node.clone();
    }
    return retnode;
};

/**
 * Return a /copy/ of an edge by ids (not the original) if extant.
 *
 * @param {string} sub_id - the subject_id of the edge we're looking for
 * @param {string} obj_id - the object_id of the edge we're looking for
 * @param {string} pred - (optional) the predicate of the edge we're looking for
 *
 * @returns {edge} - copy of bbop model edge
 */
graph.prototype.get_edge = function(sub_id, obj_id, pred){	

    if( ! pred ){ pred = this.default_predicate; }

    var ret_edge = null;
    if( this._sop_table[sub_id] &&
	this._sop_table[sub_id][obj_id] &&
	this._sop_table[sub_id][obj_id][pred] ){
	    var tmp_edge = this._sop_table[sub_id][obj_id][pred];
	    ret_edge = tmp_edge.clone();
	}
    return ret_edge; 
};

/**
 * Return all edges (copies) of given subject and object ids. Returns
 * entirely new edges.
 *
 * @param {String} sub_id - the subject_id of the edge we're looking for
 * @param {String} obj_id - the object_id of the edge we're looking for
 * @returns {Array} list of <edge>
 */
graph.prototype.get_edges = function(sub_id, obj_id){
    var anchor = this;

    var retlist = [];
    if( anchor._sop_table[sub_id] && anchor._sop_table[sub_id][obj_id] ){
	each(keys(anchor._sop_table[sub_id][obj_id]), function(pred){
	    var found_edge = anchor._sop_table[sub_id][obj_id][pred];
	    var tmp_edge = found_edge.clone();
	    retlist.push(tmp_edge);
	});
    }		

    return retlist;
};

/**
 * Return all edges (copies) of given subject id. Returns entirely new
 * edges.
 *
 * @param {String} sub_id - the subject_id of the edge we're looking for
 * @returns {Array} list of <edge>
 */
graph.prototype.get_edges_by_subject = function(sub_id){
    var anchor = this;

    var retlist = [];
    if( anchor._so_table[sub_id] ){
	each(keys(anchor._so_table[sub_id]), function(obj_id){
	    retlist = retlist.concat(anchor.get_edges(sub_id, obj_id));
	});
    }		

    return retlist;
};

/**
 * Return all edges (copies) of given object id. Returns entirely new
 * edges.
 *
 * @param {String} obj_id - the object_id of the edge we're looking for
 * @returns {Array} list of <edge>
 */
graph.prototype.get_edges_by_object = function(obj_id){
    var anchor = this;

    var retlist = [];
    if( anchor._os_table[obj_id] ){
	each(keys(anchor._os_table[obj_id]), function(sub_id){
	    retlist = retlist.concat(anchor.get_edges(sub_id, obj_id));
	});
    }		

    return retlist;
};

/**
 * Return all predicates of given subject and object ids.
 *
 * @param {String} sub_id - the subject_id of the edge we're looking for
 * @param {String} obj_id - the object_id of the edge we're looking for
 * @returns {Array} list of predicate ids (as strings)
 */
graph.prototype.get_predicates = function(sub_id, obj_id){
    var anchor = this;

    var retlist = [];
    if( anchor._sop_table[sub_id] && anchor._sop_table[sub_id][obj_id] ){
	each(keys(anchor._sop_table[sub_id][obj_id]), function(pred){
	    retlist.push(pred);
	});
    }

    return retlist;
};


/**
 * Translate an edge array into extant (node) bodies, switching on
 * either 'subject' or 'object'.
 * 
 * This will return the /original/ nodes.
 *
 * This will throw an error on any world issues that crop up.
 * 
 * @param {Array} in_edges - list if {edge} we want the subjects or objects of
 * @param {String} target - 'subject' or 'object'
 * @returns {Array} list of {node}
 */
graph.prototype.edges_to_nodes = function(in_edges, target){
    var anchor = this;
    
    // Double check.
    if( target !== 'subject' && target !== 'object'){
	throw new Error('Bad target for edges to bodies.');
    }

    // 
    var results = [];
    each(in_edges, function(in_e){

	// Switch between subject and object.
	var target_id = null;
	if( target === 'subject' ){
	    target_id = in_e.subject_id();
	}else{
	    target_id = in_e.object_id();
	}
	
	//
	if( target_id && anchor._nodes[ target_id ] ){
	    results.push(anchor._nodes[ target_id ]);
	}else{
	    throw new Error(target + ' world issue');
	}
    });

    return results;
};

/**
 * Roots are defined as nodes who are the subject of nothing,
 * independent of predicate.
 *
 * @param {string} nb_id - id of the node to check
 * @returns {boolean} - boolean
 */
graph.prototype.is_root_node = function(nb_id){
    var result = false;	
    if( this._nodes[ nb_id ] && ! this._subjects[ nb_id ] ){	    
	result = true;
    }
    return result;
};


/**
 * Return a list of /copies/ of the root nodes.
 * 
 * BUG/TODO: Could I speed this up by my moving some of the
 * calculation into the add_node and add_edge methods? O(|num(nodes)|)
 * 
 * @returns {Array} list of {node}
 */
graph.prototype.get_root_nodes = function(){
    var anchor = this;

    var results = [];
    each(keys(anchor._nodes ), function(nb_id){
	if( anchor.is_root_node(nb_id) ){
	    results.push( anchor.get_node(nb_id).clone() );
	}
    });

    return results;
};


/**
 * Leaves are defined as nodes who are the object of nothing,
 * independent of predicate.
 * 
 * @param {string} nb_id - id of the node to check
 * @returns {boolean} - boolean
 */
graph.prototype.is_leaf_node = function(nb_id){

    var result = false;
    if( this._nodes[ nb_id ] && ! this._objects[ nb_id ] ){	    
	result = true;
    }
    return result;
};

/**
 * Return a list of /copies/ of the leaf nodes.
 * 
 * BUG/TODO: Could I speed this up by my moving some of the
 * calculation into the add_node and add_edge methods? O(|num(nodes)|)
 * 
 * @returns {Array} list of {node}
 */
graph.prototype.get_leaf_nodes = function(){
    var anchor = this;

    var results = [];
    each(keys(anchor._nodes), function(nb_id){
	if( anchor.is_leaf_node(nb_id) ){
	    results.push( anchor.get_node(nb_id).clone() );
	}
    });

    return results;
};

/**
 * Find nodes that are roots and leaves over all relations. This
 * returns the /original/ node.
 * 
 * Throws an error if there is a world issue.
 *
 * @returns {Array} array of {node}
 */
graph.prototype.get_singleton_nodes = function(){
    var anchor = this;

    // Translate array into array extant bodies.
    var singleton_array = [];
    each(keys(anchor._is_a_singleton_lookup), function(singleton_id){
	if( anchor._nodes[ singleton_id ] ){
	    singleton_array.push( anchor._nodes[ singleton_id ] );
	}else{
	    throw new Error("world issue in get_singletons: " + singleton_id);
	}
    });

    return singleton_array;
};

/**
 * Return all parent edges; the /originals/. If no predicate is given,
 * use the default one.
 * 
 * TODO: it might be nice to memoize this since others depend on it.
 *
 * @param {String} nb_id - the node to consider
 * @param {String} in_pred - (optional) over this predicate, defaults to all
 * @returns {Array} array of <edge>
 */
graph.prototype.get_parent_edges = function(nb_id, in_pred){
    var anchor = this;

    var results = [];

    // Get all parents, or just parents from a specific relation.
    var preds_to_use = [];
    if( in_pred ){
	preds_to_use.push(in_pred);
    }else{
	preds_to_use = anchor.all_predicates();
    }

    // Try all of our desired predicates.
    each(preds_to_use, function(pred){

	// Scan the table for goodies; there really shouldn't be a
	// lot here.
	if( anchor._so_table[ nb_id ] ){		
	    each(keys(anchor._so_table[nb_id] ), function(obj_id){
		// If it looks like something is there, try to see
		// if there is an edge for our current pred.
		var tmp_edge = anchor.get_edge(nb_id, obj_id, pred);
		if( tmp_edge ){
		    results.push( tmp_edge );
		}
	    });
	}
    });

    return results;
};

/**
 * Return all child edges; the /originals/. If no predicate is given,
 * use the default one.
 * 
 * TODO: it might be nice to memoize this since others depend on it.
 *
 * @param {String} nb_id - the node to consider
 * @param {String} in_pred - (optional) over this predicate, defaults to all
 * @returns {Array} array of <edge>
 */
graph.prototype.get_child_edges = function(nb_id, in_pred){
    var anchor = this;

    var results = [];

    // Get all children, or just parents from a specific relation.
    var preds_to_use = [];
    if( in_pred ){
	preds_to_use.push(in_pred);
    }else{
	preds_to_use = anchor.all_predicates();
    }

    // Try all of our desired predicates.
    each(preds_to_use, function(pred){

	// Scan the table for goodies; there really shouldn't be a
	// lot here.
	if( anchor._os_table[ nb_id ] ){		
	    each(keys(anchor._os_table[nb_id] ), function(sub_id){
		// If it looks like something is there, try to see
		// if there is an edge for our current pred.
		var tmp_edge = anchor.get_edge(sub_id, nb_id, pred);
		if( tmp_edge ){
		    results.push( tmp_edge );
		}
	    });
	}
    });

    return results;
};

/**
 * Return all parent nodes; the /originals/. If no predicate is given,
 * use the default one.
 * 
 * @param {String} nb_id - the node to consider
 * @param {String} in_pred - (optional) over this predicate, defaults to all
 *
 * @returns {Array} list of {node}
 */
graph.prototype.get_parent_nodes = function(nb_id, in_pred){
    var anchor = this;

    var results = [];
    var edges = this.get_parent_edges(nb_id, in_pred);
    each(edges, function(edge){
	// Make sure that any found edges are in our
	// world.
	var obj_id = edge.object_id();
	var tmp_node = anchor.get_node(obj_id);
	if( tmp_node ){
	    results.push( tmp_node );
	}
    });

    return results;
};

/**
 * Return all child nodes; the /originals/. If no predicate is given,
 * use the default one.
 * 
 * @param {String} nb_id - the node to consider
 * @param {String} in_pred - (optional) over this predicate, defaults to all
 * @returns {Array} list of {node}
 */
graph.prototype.get_child_nodes = function(nb_id, in_pred){
    var anchor = this;

    var results = [];
    var edges = this.get_child_edges(nb_id, in_pred);
    each(edges, function(edge){
	// Make sure that any found edges are in our
	// world.
	var sub_id = edge.subject_id();
	var tmp_node = anchor.get_node(sub_id);
	if( tmp_node ){
	    results.push( tmp_node );
	}
    });
    
    return results;
};

/**
 * Return a list with two nested lists, the first is a list of nodes,
 * the second is a list of edges.
 *
 * The argument function takes a node id and 0 or 1 predicates,
 * returns a list of edges from the node in question.
 *
 * @param {Function} walking_fun - function as described above
 * @param {String|Array} nb_id_or_list - the node id(s) to consider
 * @param {String} pid - (optional) over this predicate
 * @returns {Array} as described above
 */
graph.prototype.walker = function(walking_fun, nb_id_or_list, pid){
    var anchor = this;
    
    // Shared data structure to trim multiple paths.
    // Nodes: color to get through the graph quickly and w/o cycles.
    var seen_node_hash = {};
    // Edges: just listed--hashing would be essentially the same
    // as a call to graph.add_edge (I think--benchmark?).
    var seen_edge_list = [];

    // Define recursive ascent.
    function rec_walk(nid){

	//console.log('rec_walk on: ' + nid);

    	var results = [];
    	//var new_parent_edges = anchor.get_parent_edges(nid, pid);
    	var new_area_edges = walking_fun.call(anchor, nid, pid);

	// Capture edge list for later adding.
	each(new_area_edges, function(e){
	    seen_edge_list.push(e);
	});

	// Pull extant nodes from edges. NOTE: This is a retread of
	// what happens in get_parent_nodes to avoid another call to
	// get_parent_edges (as all this is now implemented).
	var new_area_nodes = [];
	each(new_area_edges, function(edge){
	    // Make sure that any found edges are in our world.
	    var obj_id = edge.object_id();
	    var temp_node = anchor.get_node(obj_id);
	    if( temp_node ){
		new_area_nodes.push( temp_node );
	    }
	});

	// Make sure we're in there too.
	var tmp_node = anchor.get_node(nid);
	if( tmp_node ){
	    new_area_nodes.push( tmp_node );
	}

	// Recur on unseen things and mark the current as seen.
    	each(new_area_nodes, function(new_node){
    	    // Only do things we haven't ever seen before.
    	    var new_node_id = new_node.id();
    	    if( ! seen_node_hash[ new_node_id ] ){
    		seen_node_hash[ new_node_id ] = new_node;
    		rec_walk(new_node_id);	
    	    }
    	});

    	return results;
    }
    
    // Recursive call and collect data from search. Make multiple
    // ids possible.
    if( us.isArray(nb_id_or_list) ){
	each(nb_id_or_list, function(item){
	    rec_walk(item);
	});
    }else{
    	rec_walk(nb_id_or_list);
    }
    
    return [
	us.values(seen_node_hash),
	seen_edge_list
    ];
};

/**
 * Return new ancestors subgraph. Single id or id list as first
 * argument. Predicate string/id is optional.
 *
 * @param {String|Array} nb_id_or_list - the node id(s) to consider
 * @param {String} pid - (optional) over this predicate
 * @returns {graph} new bbop model graph
 */
graph.prototype.get_ancestor_subgraph = function(nb_id_or_list, pid){

    var anchor = this;

    var walk_results = 
	anchor.walker(anchor.get_parent_edges, nb_id_or_list, pid);
    var walked_nodes = walk_results[0];
    var walked_edges = walk_results[1];
    
    // Build new graph using data.
    var new_graph = anchor.create_graph();
    each(walked_nodes, function(node){
	new_graph.add_node(node.clone());
    });
    each(walked_edges, function(edge){
	new_graph.add_edge(edge.clone());
    });

    return new_graph;
};

/**
 * Return new descendents subgraph. Single id or id list as first
 * argument. Predicate string/id is optional.
 *
 * @param {String|Array} nb_id_or_list - the node id(s) to consider
 * @param {String} pid - (optional) over this predicate
 * @returns {graph} new bbop model graph
 */
graph.prototype.get_descendent_subgraph = function(nb_id_or_list, pid){

    var anchor = this;

    var walk_results = 
	anchor.walker(anchor.get_child_edges, nb_id_or_list, pid);
    var walked_nodes = walk_results[0];
    var walked_edges = walk_results[1];
    
    // Build new graph using data.
    var new_graph = anchor.create_graph();
    each(walked_nodes, function(node){
	new_graph.add_node(node.clone());
    });
    each(walked_edges, function(edge){
	new_graph.add_edge(edge.clone());
    });

    return new_graph;
};

/**
 * True or false on whether or not a graph shares the same structure
 * as the current graph. This means that the (top-level) nodes have
 * the same IDs and every edge connects in the same way.
 *
 * This does not compare things like meta information, etc.
 * 
 * BUG/TODO: This should probably be moved to the superclass. Would
 * have an easier time optimizing in there too.
 * 
 * @param {graph} comp_graph graph to compare against
 * @returns {Boolean} well is it?
 */
graph.prototype.is_topologically_equal = function(comp_graph){
    var anchor = this;
    var ret = false;

    /// We're going to use a lot of short-ciruits to get out of the
    /// comparison as quickly as possible.

    var base_nodes = anchor.all_nodes();
    var base_edges = anchor.all_edges();
    var comp_nodes = comp_graph.all_nodes();
    var comp_edges = comp_graph.all_edges();
    if( base_nodes.length === comp_nodes.length &&
	base_edges.length === comp_edges.length ){

	    // Cycle over edges first, as they should be more
	    // characteristic.
	    each(base_edges, function(base_edge){
		var edge_p = comp_graph.get_edge(base_edge.subject_id(),
						 base_edge.object_id(),
						 base_edge.predicate_id());
		if( ! edge_p ){
		    return false; // failure to find edge - done
		}
	    });

	    // Cycle over nodes next.
	    each(base_nodes, function(base_node){
		var base_node_id = base_node.id();
		var node_p = comp_graph.get_node(base_node_id);
		if( ! node_p ){
		    return false; // failure to find edge - done
		}
	    });

	    // We got through the gauntlet, I guess we're good to go
	    // now.
	    ret = true;
	}
    
    return ret;
};

/**
 * Add a graph to the current graph, without sharing any of the merged
 * in graph's structure.
 * 
 * No graph metadata is imported unless current graph and metadata are
 * empty.
 * 
 * @param {graph} - graph
 * @returns {boolean} - true; side-effects: more graph
 */
graph.prototype.merge_in = function(in_graph){

    var anchor = this;

    // If our local graph is empty of nodes, edges, and metadata,
    // attempt to load in incoming metadata.
    if( anchor.all_nodes().length === 0 && anchor.all_edges().length === 0 ){
	if( anchor.metadata() === null || us.isEmpty(anchor.metadata()) ){
	    anchor.metadata(us.clone( in_graph.metadata() ));
	}
    }	
    
    // First, load nodes; scrape out what we can.
    each(in_graph.all_nodes(), function(in_node){
	var new_node = in_node.clone();
	anchor.add_node(new_node);
    });

    // Now try to load edges; scrape out what we can.
    each(in_graph.all_edges(), function(in_edge){
	var new_edge = in_edge.clone();
	anchor.add_edge(new_edge);
    });

    return true;
};

/**
 * Load the graph from the specified JSON object (not string).
 * 
 * TODO: a work in progress 'type' not currently imported (just as not
 * exported); actually, a lot not imported.
 *
 * No graph metadata is imported unless current graph and metadata are
 * empty.
 * 
 * This is meant to be an minimal importer for a minimal
 * format. Subclasses should use something else.
 * 
 * @param {object} - JSON object
 * @returns {boolean} - true; side-effects: creates the graph internally
 */
graph.prototype.load_base_json = function(json_object){

    var anchor = this;

    // If our local graph is empty of nodes, edges, and metadata,
    // attempt to load in incoming metadata.
    if( anchor.all_nodes().length === 0 && anchor.all_edges().length === 0 ){
	if( anchor.metadata() === null || us.isEmpty(anchor.metadata()) ){
	    if( json_object.meta ){
		anchor.metadata(us.clone( json_object.meta ));
	    }
	}
    }	
    
    // First, load nodes; scrape out what we can.
    if( json_object.nodes ){
	each(json_object.nodes, function(node_raw){
	    var nid = node_raw.id;
	    var nlabel = node_raw.lbl;
	    var n = anchor.create_node(nid, nlabel);
	    if(node_raw.meta){ n.metadata(node_raw.meta); }
	    anchor.add_node(n);
	});
    }

    // Now try to load edges; scrape out what we can.
    if( json_object.edges ){
	each(json_object.edges, function(edge_raw){
	    var e =
		anchor.create_edge(edge_raw.sub, edge_raw.obj, edge_raw.pred);
	    // Copy out meta.
	    if(edge_raw.meta){ e.metadata(edge_raw.meta); } 
	    
	    anchor.add_edge(e);
	});
    }

    return true;
};

/**
 * Dump out the graph into a JSON-able object.
 * 
 * TODO: a work in progress; 'type' not currently exported (just as
 * not imported). Graph metadata is exported.
 * 
 * @returns {object} - an object that can be converted to a JSON string by dumping.
 */
graph.prototype.to_json = function(){

    var anchor = this;

    // Copy
    var nset = [];
    each(anchor.all_nodes(), function(raw_node){
	
	var node = bbop.clone(raw_node);
	var ncopy = {};
	
	var nid = node.id();
	if(nid){ ncopy['id'] = nid; }
	
	// var nt = node.type();
	// if(nt){ ncopy['type'] = nt; }
	
	var nlabel = node.label();
	if(nlabel){ ncopy['lbl'] = nlabel; }
	
	var nmeta = node.metadata();
	if(nmeta){ ncopy['meta'] = nmeta; }
	
	nset.push(ncopy);
    });
    
    var eset = [];
    var ecopy = bbop.clone(anchor._edge_list);
    each(anchor.all_edges(), function(node){
	var ecopy = {};
	
	var s = node.subject_id();
	if(s){ ecopy['sub'] = s; }
	
	var o = node.object_id();
	if(o){ ecopy['obj'] = o; }
	
	var p = node.predicate_id();
	if(p){ ecopy['pred'] = p; }
	
	eset.push(ecopy);
    });
    
    // New exportable.
    var ret_obj = {'nodes': nset, 'edges': eset};
    
    // Optional graph metadata.
    var mset = null;
    if( anchor.metadata() ){
	ret_obj['meta'] = us.clone(anchor.metadata());
    }
    
    return ret_obj;
};


// Exportable body.
module.exports = {

    node: node,
    edge: edge,
    graph: graph

};

},{"bbop-core":28,"underscore":108}],28:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"underscore":108}],29:[function(require,module,exports){
/**
 * Manager for handling communication and callbacks with GOlr
 * instances.
 *
 * @modules bbop-manager-golr
 */

var bbop = require('bbop-core');
var golr_conf = require('golr-conf');
var golr_response = require('bbop-response-golr');
var registry = require('bbop-registry');

var us = require('underscore');

// Aliasing.
var each = us.each;

/* 
 * Package: manager.js
 * 
 * Namespace: bbop.golr.manager
 * 
 * Generic BBOP manager for dealing with gross GOlr configuration and
 * management. Remember, this is actually a "subclass" of
 * <bbop.registry>. The defined events for this registry are: "reset",
 * "search", and "error".
 * 
 *  reset - functions for initializing and resetting
 *  search - functions for receiving standard search results
 *  error - functions to call when something goes very wrong
 * 
 * Both <bbop.golr.response> (or clean error data) and the manager
 * itself (this as anchor) should be passed to the callbacks.
 * 
 * TODO/BUG: <set_query> and <set_default_query> should both take
 * strings or <bbop.logic> as arguments. Those, as well as <get_query>
 * and <get_query> should only return <bbop.logic>.
 */

/*
 * Constructor: manager
 * 
 * Contructor for the GOlr query manager
 * 
 * Arguments:
 *  golr_loc - string url to GOlr server;
 *  golr_conf_obj - a <bbop.golr.conf> object
 * 
 * Returns:
 *  golr manager object
 * 
 * See also:
 *  <bbop.registry>
 *
 * A manager for handling the AJAX and registry. Initial take from
 * {module:bbop-rest-manager}.
 * 
 * @constructor
 * @param {String} barista_location - string for invariant part of API
 * @param {String} namespace - string for namespace of API to use
 * @param {String} user_token - identifying string for the user of the manager (Barista token)
 * @param {Object} engine - Remote resource manager client to use (must be an instantiated {module:bbop-rest-manager} engine)
 * @param {String} mode - whether or not to have utility methods (most besides fetch_with and start_with be in); options are "sync" and "async", which correspond to internally using fetch and start respectively
 * @returns {manager} a classic manager
 */
var manager = function (golr_loc, golr_conf_obj, engine, mode){
    registry.call(this, ['prerun',
			 'reset',
			 'search',
			 'error',
			 'postrun']);
    this._is_a = 'bbop-manager-golr';
    var anchor = this; // get a good self-reference point

    // Per-manager logger.
    this._logger = new bbop.logger(this._is_a);
    //this._logger.DEBUG = true;
    this._logger.DEBUG = false;
    function ll(str){ anchor._logger.kvetch(str); }

    // Setup right handler subsystem--either returning a direct
    // response or a promise, depending.
    anchor._engine = engine || null;
    anchor._mode = mode || null;
    anchor._runner = function(resource, payload){
	var ret = null;
	// if( typeof(anchor._engine) === 'undefined' ){
	//     throw new Error('"engine" not set in new bbop-manager-golr');
	// }
	if( anchor._mode === 'sync' ){
	    ret = anchor._engine.fetch(resource, payload);
	}else if( anchor._mode === 'async' ){
	    ret = anchor._engine.start(resource, payload);
	}else{
	    // throw new Error('"mode" not set in new bbop-manager-golr');
	    return resource;
	}
	return ret;
    };

    // The callback function called after a successful AJAX
    // intialization/reset call. First it runs some template code,
    // then it does all of the callbacks.
    anchor._run_reset_callbacks = function(response){
	ll('run reset callbacks...');
	//var response = new golr_response(json_data);
	anchor.apply_callbacks('reset', [response, anchor]);
	anchor.apply_callbacks('postrun', [response, anchor]);
    };

    // The main callback function called after a successful AJAX call in
    // the update function.
    anchor._run_search_callbacks = function(response){
	ll('run search callbacks...');
	//var response = new golr_response(json_data);
	anchor.apply_callbacks('search', [response, anchor]);
	anchor.apply_callbacks('postrun', [response, anchor]);
    };

    // This set is called when we run into a problem.
    anchor._run_error_callbacks = function(response){
	ll('run error callbacks...');
	//var response = new golr_response(json_data);
	anchor.apply_callbacks('error', [response, anchor]);
	anchor.apply_callbacks('postrun', [response, anchor]);
    };

    // The registries can only be applied if the engine is present.
    if( engine ){

	// Re-contextualize run_promise_functions().
	anchor.run_promise_functions = function(promise_function_stack, 
						accumulator_function,
						final_function,
						error_function){
	    // NOTE: Cannot sensibly use Function.call here as engine
	    // is not really the superclass of this manager.
	    return engine.run_promise_functions(promise_function_stack,
						accumulator_function,
						final_function,
						error_function);
	};

	// Setup the appropriate callbacks in the engine for success.
	anchor._engine.register('success', function(response){
	    
    	    //console.log(anchor._engine);
    	    //console.log(response._raw);
	    
            // 
            if( ! response.success() ){
		throw new Error("Unsuccessful response from golr server!");
            }else{
		var cb_type = response.callback_type();
		//console.log('okay response from server, will probe type...: '+cb_type);
		if( cb_type === 'reset' ){
                    anchor._run_reset_callbacks(response);
		}else if( cb_type === 'search' ){
                    anchor._run_search_callbacks(response);
		}else{
                    throw new Error("Unknown callback type (runner): "+cb_type);
		}
            }
	});
	
	// And, more easily, setup the appropriate callbacks in the
	// engine for failure.
	anchor._engine.register('error', function(response){
    	    anchor._run_error_callbacks(response);
	});
	
    }

    // Just want to compile these once.
    var alphanum = new RegExp(/^[a-zA-Z0-9 ]+$/);

    this.minimal_query_length = 3;

    // To help keep requests from the past haunting us. Actually doing
    // something with this number is up to the UI.
    this.last_sent_packet = 0;
    //this.last_received_packet = 0;

    // Lightly check incoming arguments.
    // There should be a string url argument.
    // There could be a hash of pinned filters argument.
    if( ! golr_loc || ! golr_conf_obj ){
	ll('ERROR: no proper arguments');
    }
    if( typeof golr_loc !== 'string' ){
	ll('ERROR: no proper golr url string argument');
    }
    if(	! golr_conf_obj._is_a || golr_conf_obj._is_a !== 'golr-conf.conf' ){
	    ll('ERROR: no proper golr-conf.conf object argument');
	    throw new Error('boink! ' + bbop.what_is(golr_conf_obj) );
	}
    
    // Whether or not to prevent ajax events from going.
    // This may not be usable, or applicable, to all backends.
    this._safety = false;

    // Our default target url.
    this._solr_url = golr_loc;

    // Settle in the configurations.
    // this._golr_conf = new bbop_golr.conf(golr_conf_var);
    this._golr_conf = golr_conf_obj;

    // The current data batches that we are storing.
    this._batch_urls = [];
    this._batch_accumulator_func = function(){};
    this._batch_final_func = function(){};

    // The current state stack.
    this._excursions = [];

    // The current class/personality that we're using. It may be none.
    this._current_class = null;

    // Our (default) query and the real deal.
    this.fundamental_query = '*:*'; // cannot be changed
    this.default_query = '*:*'; // changable
    this.query = this.default_query; // current

    // Our (default) fl and whatever we have now.
    //this.default_fl = '*%2Cscore';
    this.default_fl = '*,score';
    this.current_fl = this.default_fl;

    // We remember defaults in the case of rows and start since they
    // are the core to any paging mechanisms and may change often.
    //this.default_rows = 25;
    //this.default_rows = 100;
    this.default_rows = 10;
    this.default_start = 0;
    this.current_rows = this.default_rows;
    this.current_start = this.default_start;

    // There is a reason for this...TODO: later (25+)
    this.default_facet_limit = 25;
    this.current_facet_limit = 25;
    // {facet_field_name: value, ...}
    this.current_facet_field_limits = {};
    // TODO: paging for facets;
    this.current_facet_offset = 25;
    this.current_facet_field_offsets = {};

    // Number of snippets to return when hl is enable
    this.default_hl_snippets = 1000;

    // Our default query args, with facet fields plugged in.
    this.query_variants =
	{
	    // Our default standard search type. This means we don't
	    // have to explicitly add fields to the search (although
	    // the query fields ('qf') are still necessary to make
	    // anything real happen).
	    defType: 'edismax',
	    
	    // Things unlikely to be touched.
	    // There are unlikely to be messed with too much.
	    qt: 'standard',
	    indent: 'on',
	    wt: 'json',
	    //version: '2.2',
	    rows: anchor.current_rows,
	    start: anchor.current_start, // Solr is offset indexing
	    //fl: '*%2Cscore',
	    fl: anchor.default_fl,
    
	    // Deprecated: see query_filters
	    //fq: {},
	    
	    // Deprecated: see query_fields
	    //qf: {},
	    
	    // Deprecated: see query
	    //q: '*:*'

	    // Control of facets.
	    facet: 'true',
	    'facet.mincount': 1,
	    'facet.sort': 'count',
	    'json.nl': 'arrarr', // only in facets right now
	    'facet.limit': anchor.default_facet_limit
	    // TODO?: 'f.???.facet.limit': 50,
	    // TODO: 'json.nl': [flat|map|arrarr]

	    // Deprecated: see facet_fields
	    //'facet.field': []
	};

    // This is the 'qf' parameter. Although we keep it, it only needs
    // to be exposed when the query ('q') field is set.
    //this.query_fields = [];
    this.query_fields = {};

    // A richer way to handle the 'fq' query variant.
    // It should look like:
    // {<filter>: {<value>:{'sticky_p':(t|f), 'negative_p':(t|f)}, ...}}
    this.query_filters = {};

    // The engine for the facet.field list.
    this.facet_fields = {};

    /*
     * Function: debug
     * 
     * Turn on or off the verbose messages. Uses <bbop.logger>, so
     * they should come out everywhere.
     * 
     * Parameters: 
     *  p - *[optional]* true or false for debugging
     *
     * Returns: 
     *  boolean; the current state of debugging
     */
    this.debug = function(p){
	if( p === true || p === false ){
	    this._logger.DEBUG = p;
	    // TODO: add debug parameter a la include_highlighting
	}
	return this._logger.DEBUG;
    };

    /*
     * Function: minimal_query
     * 
     * The length of the minimal query to consider. Defaults to 3.
     * 
     * Parameters: 
     *  n - *[optional]* number, or nothing if just want current
     *
     * Returns: 
     *  number
     */
    this.minimal_query = function(n){
	if( us.isNumber(n) ){
	    anchor.minimal_query_length = n;
	}
	return this.minimal_query_length;
    };

    /*
     * Function: lite
     * 
     * Limit the returns fields (the parameter "fl") to the ones
     * defined in the set of fields defined in results, label fields
     * if available (i.e. "_label", "_map" when "_label" is
     * multi=valued), and "score" and "id".
     * 
     * The default is "false".
     * 
     * Parameters: 
     *  use_lite_p - *[optional]* true or false, none just returns current
     *
     * Returns: 
     *  boolean; the current state of lite-ness
     */
    this.lite = function(use_lite_p){

	// Adjust the current state accordingly.
	if( use_lite_p === true || use_lite_p === false ){
	    if( use_lite_p === true ){
		
		// The actual collections and adjustment.
		// First, this only works if we have a personality, so
		// check to see if we have one.
		var per = anchor.get_personality();
		if( per ){
		    // Since we have a personality, collect all of the
		    // mentioned fields.
		    var field_collection = {};
		    var union = bbop.merge;
		    var ccl = anchor._current_class;

		    // Fill field_collection with the fields
		    // in the given category.
		    //loop(['boost', 'result', 'filter'],
		    //loop(['result', 'filter'],
		    each(['result'], function(cat){
			field_collection = 
			    union(field_collection, ccl.get_weights(cat));
		    });
		    
		    // Next, flatten into a list.
		    var flist = us.keys(field_collection);

		    // Now for all the fields in these categories, see
		    // if we can find additional "special" labels to
		    // go with them.
		    each(flist, function(flist_item){
			//loop(['_label', '_label_searchable'],
			each(['_label'], function(field_suffix){
			    var new_field = flist_item + field_suffix;
			    var nf_obj = ccl.get_field(new_field);
			    if( nf_obj ){
				flist.push(new_field);
				
				// There appears to be the
				// thing label. If they are
				// both multi-valued, then
				// there will be a map as
				// well.
				if( nf_obj.is_multi() ){
				    flist.push(flist_item + '_map');
				}
			    }
			});
		    });
		    
		    // Finally, set these fields (plus score) as the
		    // new return fields.
		    flist.push('score');
		    flist.push('id');
		    //anchor.current_fl = flist.join('%2C');
		    anchor.current_fl = flist.join(',');
		    anchor.set('fl', anchor.current_fl);
		}
		
	    }else{ // else false
		// Reset.
		anchor.current_fl = anchor.default_fl;
		anchor.set('fl', anchor.current_fl);
	    }
	}

	// Return the current state.
	var retval = false;
	if( anchor.default_fl !== anchor.current_fl ){
	    retval = true;
	}
	return retval;
    };

    // An internal helper function to munge the name of a field into
    // the name of its corresponding facet field.
    function _field_to_facet_field(field){
	return 'f.' + field + '.facet.limit';
    }
    
    /*
     * Function: get_facet_limit
     * 
     * Get the limit for a specified facet or the global limit.
     * 
     * Parameters: 
     *  field - *[optional]* limit for a specific field; otherwise global value
     *
     * Returns: 
     *  integer or null
     */
    this.get_facet_limit = function(field){
	var retval = null;

	if( ! field ){
	    retval = anchor.current_facet_limit;
	}else{
	    var f = _field_to_facet_field(field);
	    var try_val = anchor.current_facet_field_limits[f];
	    if( typeof(try_val) !== 'undefined' ){
		retval = try_val;
	    }
	}

	return retval;
    };

    /*
     * Function: set_facet_limit
     * 
     * Change the number of facet values returned per call.
     * The default is likely 25.
     * 
     * Just as in Solr, a -1 argument is how to indicate unlimted
     * facet returns.
     * 
     * This setting does not survive things like <resets_facet_limit>.
     * 
     * Parameters: 
     *  arg1 - (integer) set the global limit
     *
     * Parameters: 
     *  arg1 - (string) the name of the field to check
     *  arg2 - (integer) set the limit for this field
     *
     * Returns: 
     *  boolean on whether something was set
     */
    this.set_facet_limit = function(arg1, arg2){
	var retval = false;

	// Decide which form of the function we're using.
	if( typeof(arg2) === 'undefined' &&
	    bbop.what_is(arg1) === 'number' ){ // form one
		
		// Set
		var nlimit = arg1;
		anchor.current_facet_limit = nlimit;
		anchor.set('facet.limit', anchor.current_facet_limit);
		
		retval = true;
	
	}else if( typeof(arg1) !== 'undefined' && 
		  typeof(arg2) !== 'undefined' && 
		  bbop.what_is(arg1) === 'string' &&
		  bbop.what_is(arg2) === 'number' ){
		      
		      var field = _field_to_facet_field(arg1);
		      var limit = arg2;
		      anchor.current_facet_field_limits[field] = limit;
		      
		      retval = true;
	}

	return retval;
    };

    /*
     * Function: set_default_facet_limit
     * 
     * Permanently change the default number of facet values returned
     * per call. The default's default is likely 25.
     * 
     * Just as in Solr, a -1 argument is how to indicate unlimted
     * facet returns.
     * 
     * Parameters: 
     *  lim - (integer) set the global default limit
     *
     * Returns: 
     *  old default
     */
    this.set_default_facet_limit = function(lim){

	// Capture ret.
	var retval = anchor.default_facet_limit;

	// Set
	anchor.default_facet_limit = lim;
	//anchor.set('facet.limit', anchor.default_facet_limit);
		
	return retval;
    };

    /*
     * Function: reset_facet_limit
     * 
     * Either reset the global limit to the original (likely 25)
     * and/or remove the specified filter. Sets everything back to the
     * original values or whatever was set by
     * <set_default_facet_limit>.
     * 
     * Parameters: 
     *  field - *[optional]* remove limit for a field; otherwise all and global
     *
     * Returns: 
     *  boolean on whether something was reset
     */
    this.reset_facet_limit = function(field){
	var retval = false;

	if( typeof(field) === 'undefined' ){
	    // Eliminate all fields by blowing them away.
	    anchor.current_facet_limit = anchor.default_facet_limit;
	    anchor.set('facet.limit', anchor.current_facet_limit);
	    anchor.current_facet_field_limits = {};
	    retval = true;
	}else{ // eliminate just the one field
	    var f = _field_to_facet_field(field);
	    if( typeof(anchor.current_facet_field_limits[f]) !== 'undefined' ){
		delete anchor.current_facet_field_limits[f];
		retval = true;
	    }
	}

	return retval;
    };

    /*
     * Function: get_results_count
     * 
     * Get the current number of results that will be returned.
     * 
     * Parameters: 
     *  n/a
     *
     * Returns: 
     *  integer
     */
    this.get_results_count = function(field){
	return anchor.get('rows');
    };

    /*
     * Function: set_results_count
     * 
     * Change the number of result documents returned per call.
     * The default is likely 10.
     * 
     * Parameters: 
     *  count - (integer) set the global results count
     *
     * Returns:
     *  the count set
     */
    this.set_results_count = function(count){
	anchor.set('rows', count);
	anchor.current_rows = count;
	return anchor.current_rows;
    };

    /*
     * Function: reset_results_count
     * 
     * Reset the number of documents to their original setting, likely
     * 10.
     * 
     * Parameters: 
     *  n/a
     *
     * Returns:
     *  the new count
     */
    this.reset_results_count = function(){
	anchor.set('rows', anchor.default_rows);
	anchor.current_rows = anchor.default_rows;
	return anchor.current_rows;
    };

    /*
     * Function: plist_to_property_hash
     *
     * Turn a plist to a hash containing the different properties that
     * can be defined for a query filter. Possible values are: '+'
     * (positive filter), '-' (negative filter), '*' (sticky filter),
     * '$' (transient). If mutually exclusive properties are defined
     * (e.g. both '+' and '-'), the last one will be used. Or, since
     * that is a call to silliness, let's say the behavior is
     * undefined.
     *
     * Parameters: 
     *  plist - *[optional]* a list of properties to apply to the filter
     *
     * Returns: 
     *  A hash version of the plist; otherwise, the default property hash
     */
    this.plist_to_property_hash = function(plist){

	// Let's start with the default values.
	var phash = {
	    //'positive_p': true,
	    'negative_p': false,
	    //'transient_p': true
	    'sticky_p': false
	};

	// If not defined, just return the default list.
	if( plist ){	    
	    each(plist, function(item){
		if( item === '+' ){
		    phash['negative_p'] = false;
		    //phash['positive_p'] = true;
		}else if( item === '-' ){
		    phash['negative_p'] = true;
		    //phash['positive_p'] = false;
		}else if( item === '*' ){
		    phash['sticky_p'] = true;
		    //phash['transient_p'] = false;
		}else if( item === '$' ){
		    phash['sticky_p'] = false;
		    //phash['transient_p'] = true;
		}
	    });
	}

	return phash;
    };

    /*
     * Function: add_query_filter_as_string
     *
     * Setter for query filters ('fq'). Acts as a 
     *
     * Parameters: 
     *  filter_string - filter (type) string (e.g. "-type:gene")
     *  plist - *[optional]* list of properties of the filter
     *
     * Returns: 
     *  (TODO) The current query filter hash.
     * 
     * See also:
     *  <add_query_filter>
     */
    this.add_query_filter_as_string = function(filter_string, plist){
	
	// Split the incoming filter string into its component parts.
	var f_v = bbop.first_split(':', filter_string);
	var fname = f_v[0];
	var fval = f_v[1];

	// Need to shuck the value from the quotes, as in load_url.
	fval = bbop.dequote(fval);

	var props = null;
	if( us.isArray(plist) ){
	    props = plist;
	}else{
	    props = [];
	}

	// Only continue on sensible inputs.
	var ret = {};
	if( fname !== '' && fval !== '' ){

	    // Similar to the URL loader.
	    var lead_char = fname.charAt(0);
	    if( lead_char === '-' || lead_char === '+' ){
		props.push(lead_char);
		fname = fname.substr(1, fname.length -1);
	    }
	    
	    ret = this.add_query_filter(fname, fval, props);
	}

	return ret;
    };

    /*
     * Function: add_query_filter
     *
     * Setter for query filters ('fq').
     *
     * Parameters: 
     *  filter - filter (type) string
     *  value - filter value string (or TODO: defined logic hash)
     *  plist - *[optional]* list of properties of the filter
     *
     * Returns: 
     *  (TODO) The current query filter hash.
     * 
     * See also:
     *  <plist_to_property_hash>
     */
    this.add_query_filter = function(filter, value, plist){
	
	// Make sure we've defined the group.
	if( typeof(this.query_filters[filter]) === 'undefined' ){
	    this.query_filters[filter] = {};
	}

	this.query_filters[filter][value] = this.plist_to_property_hash(plist);
	
	//ll("Current state: " + bbop.dump(this.query_filters));

	return {}; // TODO
    };

    /*
     * Function: remove_query_filter
     *
     * Remover for query filters ('fq'), is a plist is specified, it
     * will only remove if all of the listed criteria are met.
     *
     * Parameters: 
     *  filter - filter (type) string
     *  value - filter value string (TODO: or defined logic hash)
     *  plist - *[optional]* list of properties of the filter
     *
     * Returns: 
     *  boolean (on success)
     */
    this.remove_query_filter = function(filter, value, plist){

	// Default return value.
	var retval = false;

	// Internal helper to delete a low level key, and then if the
	// top-level is empty, get that one too.
	function _full_delete(hash, key1, key2){
	    if( key1 && key2 && hash &&
		hash[key1] && hash[key1][key2] ){
		    delete hash[key1][key2];
		}
	    if( us.isEmpty(hash[key1]) ){
		delete hash[key1];
	    }
	}

	// If we have a filter, a value, and it's there...
	if( filter && value &&
	    anchor.query_filters[filter] &&
	    anchor.query_filters[filter][value] ){

		// If no real plist hash been defined, just go ahead
		// and get rid of that. Otherwise, make sure that the
		// defined plist and the stored properties are the
		// same before deleting.
		if( ! plist || us.isEmpty(plist) ){
		    _full_delete(anchor.query_filters, filter, value);
		    retval = true;
		}else{
		    
		    var filter_phash = anchor.query_filters[filter][value];
		    var in_phash = anchor.plist_to_property_hash(plist);
		    
		    if( bbop.is_same(filter_phash, in_phash) ){		
			_full_delete(anchor.query_filters, filter, value);
			retval = true;
		    }
		}
	    }

	return retval;
    };

    /*
     * Function: reset_query_filters
     *
     * Reset the query filters ('fq'); but leave sticky filters alone.
     *
     * Parameters: 
     *  n/a
     * 
     * Returns: 
     *  (TODO) The current query filter hash.
     */
    this.reset_query_filters = function(){

	// Drill down and delete all non-stickies.
	each(anchor.query_filters, function(values, filter){
	    //ll('filter: ' + filter);
	    each(values, function(props, value){
		//ll('  value: ' + value);
		var sticky_p = props['sticky_p'];
		if( ! sticky_p ){
		    //ll('hit: ' + filter + ', ' + value);
		    anchor.remove_query_filter(filter, value);
		}
	    });
	});
	
	return {}; // TODO
    };

    /*
     * Function: get_query_filter_properties
     *
     * Get a hash representing a query filter ('fq').
     *
     * Parameters: 
     *  key - filter string (TODO: or defined logic hash)
     *
     * Returns: 
     *  The current query filter hash for key.
     */
    this.get_query_filter_properties = function(filter, value){

	// Default return value.
	var retobj = null;
	
	// If we have a key and it's there...
	var aqf = anchor.query_filters;
	if( filter && value && aqf[filter] && aqf[filter][value] ){
	    retobj =
		{
		    'filter' : filter,
		    'value' : value,
		    //'polarity': aqf[filter][value]['negative_p'],
		    'negative_p': aqf[filter][value]['negative_p'],
		    'sticky_p': aqf[filter][value]['sticky_p']
		};
	}

	return retobj;
    };

    /*
     * Function: get_query_filters
     *
     * Get a list of hashes representing the query filters ('fq'). The
     * return lists look like:
     *
     * : [{'filter': A, 'value': B, 'negative_p': C, 'sticky_p': D}, ...]
     *
     * Where A and B are strings and C and D are booleans.
     * 
     * Parameters: 
     *  n/a
     *
     * Returns: 
     *  A list of the current query filter hashs.
     */
    this.get_query_filters = function(){

	var retlist = [];	
	each(anchor.query_filters, function(values, f){
	    each(values, function(props, v){
		retlist.push(anchor.get_query_filter_properties(f, v));
	    });
	});

	return retlist;
    };

    /*
     * Function: get_sticky_query_filters
     *
     * Get a list of hashes representing the current stucky query
     * filters ('fq'). See <get_query_filters> for a specification of
     * what the return type looks like.
     * 
     * Parameters: 
     *  n/a
     *
     * Returns: 
     *  A list of the current sticky query filter hashs.
     * 
     * See also:
     *  <get_query_filters>
     */
    this.get_sticky_query_filters = function(){

	var retlist = [];	
	each(anchor.query_filters, function(values, f){
	    each(values, function(props, v){
		var qfp = anchor.get_query_filter_properties(f, v);
		if( qfp['sticky_p'] === true ){
		    retlist.push(qfp);			      
		}
	    });
	});

	return retlist;
    };

    // A little extra thing that we might need sometimes.
    this.query_extra = null;


    /*
     * Function: filter_list_to_assemble_hash
     *
     * Get all of our query filter variables and try and make
     * something of them that <get_assemble> can understand.
     *
     * Sticky doesn't matter here, but negativity does. However, we
     * can be pretty naive since the hashing should have already taken
     * out mutually exclusive dupes.
     * 
     * The argument is a list of query filter properties, as returned
     * by <get_query_filters> and <get_sticky_query_filters>.
     *
     * Parameters:
     *  flist - a list of query filter properties (see above)
     *
     * Returns:
     *  hash of filter names to value lists
     * 
     * See also:
     *  <get_query_filters>
     *  <get_sticky_query_filters>
     */
    this.filter_list_to_assemble_hash = function(flist){
	var h = {};
	each(flist, function(filter_property){
	    
	    // Grab only the properties that affect the
	    // URL.
	    var filter = filter_property['filter'];
	    var value = filter_property['value'];
	    var negative_p = filter_property['negative_p'];
	    
	    // We need to alter at the filter level.
	    if( negative_p ){
		filter = '-' + filter;
	    }
	    
	    // Make sure it is defined.
	    if( typeof(h[filter]) === 'undefined' ){
		h[filter] = [];
	    }
	    h[filter].push(value);
	});
	return h;
    };
    
    /*
     * Function: sensible_query_p
     * 
     * Simply ask the manager if a free text query ('q') makes sense
     * at this point.
     * 
     * This currently means that the query text ('q') is one of:
     *  1) the same as the default query
     *  2) the same as the fundamental query
     *  3) three (3) (or whatever minimal_query is set to) characters long
     *  4) the empty string ('')
     * and that query fields ('qf') are defined.
     * 
     * This is an overridable opinion of the manager.
     * 
     * Parameters:
     *  n/a
     *
     * Returns:
     *  boolean
     */
    this.sensible_query_p = function(){
	var retval = false;
	var q = anchor.get_query();
	var qf = anchor.query_field_set();

	//console.log('q', q);
	//console.log('qf', qf);

	if( qf && ! us.isEmpty(qf) ){ // first hurdle

	    if( q === anchor.get_default_query() ){
		retval = true;
	    }else if( q === anchor.get_fundamental_query() ){
		retval = true;
	    }else if( q && q.length >= anchor.minimal_query_length ){
		retval = true;
	    }else if( q === ''){
		retval = true;
	    }
	}
	return retval;
    };

    /*
     * Function: last_packet_sent
     *
     * It is up to the UI to do something interesting with this number.
     * 
     * Also remember that this number only rises through calls to
     * <update> or one of its wrappers. Calls to <get_query_url> and
     * the like will not affect this number.
     * 
     * Parameters:
     *  n/a 
     *
     * Returns:
     *  integer
     * 
     * See also:
     *  <update>
     */
    this.last_packet_sent = function(){
    	return anchor.last_sent_packet;
    };

    /*
     * Function: clear
     *
     * Clear all non-sticky query parameters to get back to a more
     * "original" state.
     * 
     * Not to be confused with <reset>.
     * 
     * Parameters: 
     *  n/a
     *
     * Returns:
     *  n/a
     */
    this.clear = function(){

	// Reset 'q'.
	anchor.query = anchor.default_query;

	// Reset 'fq', all but sticky.
	anchor.reset_query_filters();
    };

    /*
     * Function: reset
     *
     * Manually trigger the "reset" chain of events.
     *
     * This is a curried wrapper for <update> and should be preferred
     * over a direct call to update.
     *
     * Note to be confused with <clear>.
     *
     * Returns:
     *  the query url (with the jQuery callback specific parameters)
     * 
     * See also:
     *  <update>
     */
    this.reset = function(){
	return anchor.update('reset');
    };

    /*
     * Function: search
     *
     * Trigger the "search" chain of events.
     * Takes a field-keyed hash of bbop.logics as an argument.
     * 
     * This is a curried wrapper for <update> and should be preferred
     * over a direct call to update.
     * 
     * Parameters:
     *  n/a
     *
     * Returns:
     *  the query url (with the jQuery callback specific parameters)
     * 
     * See also:
     *  <update>
     */
    this.search = function(){
	return anchor.update('search');
    };

    /*
     * Function: page
     *
     * Re-trigger the "search" chain of events, but with the variables
     * set for a different section of the results.
     * 
     * Note that this operates independently of any impossibilites in
     * the results--just how such paging would look and
     * triggering. Ths UI should handle impossibilities and the like.
     * 
     * This is a wrapper for <update> and should be preferred over a
     * direct call to update.
     * 
     * Parameters: 
     *  rows - the number of rows to return
     *  start - the offset of the rows to return
     *
     * Returns:
     *  the query url (with the jQuery callback specific parameters)
     * 
     * See also:
     *  <update>
     */
    this.page = function(rows, start){
	anchor.set('rows', rows);
	anchor.set('start', start);
	return anchor.update('search', rows, start);
    };

    /*
     * Function: page_first
     *
     * Currently a convenience alias for <search>. Think about it--it
     * makes sense.
     * 
     * This is a wrapper for <page> and should be preferred over a
     * direct call to page.
     * 
     * Parameters: 
     *  n/a
     *
     * Returns:
     *  n/a
     * 
     * See also:
     *  <page>
     */
    this.page_first = anchor.search;
    
    /*
     * Function: page_previous
     * 
     * This is a wrapper for <page> and should be preferred over a
     * direct call to page.
     * 
     * Parameters: 
     *  n/a
     *
     * Returns:
     *  the query url (with the jQuery callback specific parameters)
     * 
     * See also:
     *  <page>
     */
    this.page_previous = function(){
	var do_rows = anchor.get_page_rows();
	var do_offset = anchor.get_page_start() - do_rows;
	return anchor.page(do_rows, do_offset);
    };
    
    /*
     * Function: page_next
     * 
     * This is a wrapper for <page> and should be preferred over a
     * direct call to page.
     * 
     * Parameters: 
     *  the query url (with the jQuery callback specific parameters)
     *
     * Returns:
     *  n/a
     * 
     * See also:
     *  <page>
     */
    this.page_next = function(){
	var do_rows = anchor.get_page_rows();
	var do_offset = anchor.get_page_start() + do_rows;
	return anchor.page(do_rows, do_offset);
    };
    
    /*
     * Function: page_last
     * 
     * Trigger search on last page parameters.
     * 
     * Since the manager has no idea about what is actually being
     * returned, the real world number of total documents needs to be
     * added as an argument.
     * 
     * This is a wrapper for <page> and should be preferred over a
     * direct call to page.
     * 
     * Parameters: 
     *  total_document_count - integer for the total number of docs found
     *
     * Returns:
     *  the query url (with the jQuery callback specific parameters)
     * 
     * See also:
     *  <page>
     */
    this.page_last = function(total_document_count){
	var do_rows = anchor.get_page_rows();
	var mod = total_document_count % do_rows;
	var do_offset = total_document_count - mod;
	// ll("page_last: " + total_document_count + " " +
	//    do_rows + " " + mod + " " + do_offset);
	var ret = null;
	if( mod === 0 ){
	    ret = anchor.page(do_rows, do_offset - do_rows);
	}else{
	    ret = anchor.page(do_rows, do_offset);
	}
	return ret;
    };

    /*
     * Function: get_page_rows
     *
     * Return the number of rows the manager is currently set
     * to. Useful as an argument to <page>.
     * 
     * Parameters: 
     *  n/a
     *
     * Returns:
     *  integer; the number of rows the manager is currently set to
     * 
     * See also:
     *  <page>
     */
    this.get_page_rows = function(){
	return anchor.get('rows');
    };

    /*
     * Function: get_page_start
     *
     * Return the rows offset the manager is currently set to. Useful
     * as an argument to <page>.
     * 
     * Parameters: 
     *  n/a
     *
     * Returns:
     *  integer; the offset the manager is currently set to
     * 
     * See also:
     *  <page>
     */
    this.get_page_start = function(){
	return anchor.get('start');
    };

    /*
     * Function: add_query_field
     * 
     * Add a new query field to the query. 
     * 
     * This does not go through and expand into searchable fields, for
     * that see: <query_field_set>.
     *
     * Parameters: 
     *  qf - the query field to add
     *  boost - *[optional]* defaults to 1.0
     *
     * Returns:
     *  true or false on whether or not it is a new field
     * 
     * See also:
     *  <query_field_set>
     */
    this.add_query_field = function(qf, boost){
	
	var retval = false;

	// Make sure that some boost is there.
	if( typeof(boost) === 'undefined' ){
	    boost = 1.0;
	}

	// Check.
	if( typeof(anchor.query_fields[qf]) === 'undefined' ){
	    retval = true;
	}

	// Add.
	anchor.query_fields[qf] = boost;

	return retval;
    };

    /*
     * Function: query_field_set
     *
     * Bulk getter/setter for the query fields--the fields that are
     * searched (and by what weight) when using a query ('q' or
     * set_query(), i.e. the 'qf' field).
     * 
     * This will always use searchable fields if possible,
     * automatically replacing the non-searchable versions (I can't
     * think of any reason to use non-searchable versions unless you
     * want your searches to not work) if a personality is set. If no
     * personality is set, it will just use the arguments as-is.
     * 
     * The argument replaces the current set.
     *
     * The qfs argument should be a hash like:
     * 
     *  {'field01': value01, ...}
     * 
     * Parameters: 
     *  qfs - *[optional]* query fields to set
     *
     * Returns:
     *  the current query_fields array (e.g. ["field01^value01", ...])
     */
    this.query_field_set = function(qfs){

	// Covenience.
	var cclass = anchor._current_class;

	// Only do something if we have a query field set.
	if( qfs ){
	    
	    // Only do the probing if a personality has been set.
	    if( cclass ){

		// Get the current searchable extension string from
		// the personality class.
		//var s_ext = cclass.searchable_extension();
		// Actually, we're going to make this non-variable.
		var s_ext = '_searchable';

		// Probe the input to see if there are any searchable
		// alternatives to try, use those instead.
		var searchable_qfs = {};
		each(qfs, function(value, filter){
		    // If the probe fails, just put in
		    // whatever is there.
		    var cfield = cclass.get_field(filter);
		    if( cfield && cfield.searchable() ){
			//ll('filter/value:');
			var new_f = filter + s_ext;
			searchable_qfs[new_f] = value;
		    }else{
			searchable_qfs[filter] = value;
		    }
	    	});
		qfs = searchable_qfs;
	    }	    
	    
	    // Overwrite the current.
	    anchor.query_fields = qfs;
	}
	
	// Using the original information, convert them to the
	// proper output format.
	var output_format = [];
	each(anchor.query_fields, function(value, filter){
	    output_format.push(filter + '^' + value);
	});
	return output_format;
    };

    /*
     * Function: facets
     *
     * Bulk getter/setter for facets (technically 'facet.field').
     *
     * Parameters: 
     *  key - *[optional]* facet to add to the facet list
     *
     * Parameters: 
     *  list - *[optional]* list to replace the current list with
     *
     * Returns:
     *  the current facets hash.
     */
    this.facets = function(list_or_key){
	if( list_or_key ){
	    if( bbop.what_is(list_or_key) !== 'array' ){
		// Arrayify it.
		list_or_key = [list_or_key];
	    }else{
		// When there is a list, we are replacing the whole
		// thing, so let's just poof it out of existance.
		anchor.facet_fields = {};
	    }
	    each(list_or_key, function(item){
		anchor.facet_fields[item] = true;
	    });
	}
	return us.keys(anchor.facet_fields);
    };

    /*
     * Function: set_default_query
     *
     * Setter for the default query for the query variable ('q').
     * 
     * Call <reset_query> if you want to affect query immediately.
     * 
     * Parameters: 
     *  new_default_query - new default query string (or TODO: <bbop.logic>)
     *
     * Returns:
     *  the current setting of default query for ('q')
     */
    this.set_default_query = function(new_default_query){
	anchor.default_query = new_default_query;
	return anchor.default_query;
    };

    // /*
    //  * Function: set_first_run_query
    //  *
    //  * Setter for a first run query.  Normally, when <reset_query>, or
    //  * related method, is executed, we reset back to the default
    //  * query. This method sets a one time variable so a non empty
    //  * value can be used for the first reset.
    //  * 
    //  * Call <reset_query> if you want to affect query immediately.
    //  * 
    //  * Parameters: 
    //  *  first_run_query - query_string (or TODO: <bbop.logic>)
    //  *
    //  * Returns:
    //  *  the current setting of default query for ('q')
    //  */
    // this.set_first_run_query = function(first_run_query){
    // 	anchor.default_query = new_default_query;
    // 	return anchor.default_query;
    // };

    /*
     * Function: reset_default_query
     *
     * Reset the default query back to "*:*".
     * 
     * Call <reset_query> if you want to affect query immediately.
     * 
     * Parameters:
     *  n/a
     *
     * Returns:
     *  the current setting of default query ('q')
     */
    this.reset_default_query = function(){
	anchor.default_query = anchor.fundamental_query;
	return anchor.default_query;
    };

    /*
     * Function: set_query
     *
     * Setter for the query variable ('q').
     * 
     * Parameters: 
     *  new_query - new value for the query string (or TODO: <bbop.logic>)
     *
     * Returns:
     *  the current setting of query ('q')
     * 
     * Also see:
     *  <set_comfy_query>
     */
    this.set_query = function(new_query){
	anchor.query = new_query;
	return anchor.query;
    };

    /*
     * Function: set_comfy_query
     *
     * A specialized setter for the query variable ('q'), as follows:
     *
     * If the input is all alphanum or space, the input is
     * tokenized. If there is one token, if it is at least three
     * characters, gets a wildcard '*'; if there are more tokens, the
     * last one gets a wild card.
     * 
     * This might be a more comfortable way to search for most naive
     * (non-power user) interfaces.
     * 
     * Parameters: 
     *  new_query - new value for the query string (or TODO: <bbop.logic>)
     *
     * Returns:
     *  the current setting of query ('q')
     * 
     * Also see:
     *  <set_query>
     */
    this.set_comfy_query = function(new_query){

	var comfy_query = new_query;

	// Check that there is something there.
	if( new_query && new_query.length && new_query.length > 0 ){

	    // Check if the last real input has a space after it.
	    var has_cursor_p = true;
	    if( new_query.slice(-1) === ' ' ){
		has_cursor_p = false;
	    }

	    // Now chomp it down again to get rid of whitespace.
	    new_query = bbop.chomp(new_query);

	    // Check (again) that there is something there.
	    if( new_query && new_query.length && new_query.length > 0 ){

		// That it is alphanum+space-ish and that we actually
		// might want to add a wildcard (i.e. has cursor).
		if( alphanum.test(new_query) && has_cursor_p ){
	    
		    // Break it into tokens and get the last.
		    var tokens = new_query.split(new RegExp('\\s+'));
		    var last_token = tokens[tokens.length -1];
		    //ll('last: ' + last_token);
		
		    if( tokens.length === 1 ){
			
			// If it is three or more, add the wildcard.
			if( last_token.length >= anchor.minimal_query_length ){
			    tokens[tokens.length -1] = last_token + '*';
			}
		    }else{
			tokens[tokens.length -1] = last_token + '*';
		    }
		    // And join it all back into our comfy query.
		    comfy_query = tokens.join(' ');
		}
	    }
	}

	// Kick it back to the normal set_query.
	return anchor.set_query(comfy_query);
    };

    /*
     * Function: set_id
     *
     * A limited setter, removing whatever else is on query. This is
     * for when you want to lock into one (unique) document by id
     * (essentially 'q=id:"foo"'). All other query operations behave
     * as they should around it.
     * 
     * Parameters: 
     *  new_id - string id
     *
     * Returns:
     *  the current setting of query ('q')
     * 
     * Also see:
     *  <set_ids>
     */
    this.set_id = function(new_id){
	anchor.query = 'id:' + bbop.ensure(new_id, '"');
	return anchor.query;
    };

    // Function to unwind and lock a list if identifiers onto a field.
    function _lock_map(field, id_list){
	var fixed_list = [];
	each(id_list, function(item){
	    fixed_list.push(bbop.ensure(item, '"'));
	});
	
	var base_id_list = '(' + fixed_list.join(' OR ') + ')';

	var ret_query = field + ':' + base_id_list;
	return ret_query;
	
    }

    /*
     * Function: set_ids
     *
     * Like <set_id>, a limited setter. It removes whatever else is on
     * query and replaces it with something like:
     * 
     * : gm.set_ids(['GO:1', 'GO:2'])
     * 
     * This is for when you want to lock into a set of documents by id. All
     * other query operations behave as they should around it.
     * 
     * Parameters: 
     *  id_list - a list of ids to search for
     *
     * Returns:
     *  the current setting of query ('q')
     * 
     * Also see:
     *  <set_ids>
     */
    this.set_ids = function(id_list){
	anchor.query = _lock_map('id', id_list);
	return anchor.query;
    };

    /*
     * Function: set_targets
     *
     * Like a more generalized version of <set_ids>, a limited. It
     * removes whatever else is on query and replaces it with
     * something like:
     * 
     * : gm.set_targets(['GO:1', 'GO:2'], ['field_1', 'field_2'])
     * 
     * This is for when you want to lock into a set of documents by
     * locking onto identifiers in some set of search fields. All
     * other query operations behave as they should around it.
     * 
     * Parameters: 
     *  id_list - a list of ids to search for
     *  field_list - a list of fields ids to search across
     *
     * Returns:
     *  the current setting of query ('q')
     * 
     * Also see:
     *  <set_ids>
     */
    this.set_targets = function(id_list, field_list){

	var fixed_list = [];
	each(field_list, function(field){
	    fixed_list.push(_lock_map(field, id_list));
	});

	var sum = fixed_list.join(' OR ');

	anchor.query = sum;
	return anchor.query;
    };

    /*
     * Function: get_query
     *
     * Getter for the query variable ('q').
     * 
     * Parameters: 
     *  n/a
     *
     * Returns:
     *  the current setting of extra
     */
    this.get_query = function(){
	return anchor.query;
    };

    /*
     * Function: get_default_query
     *
     * Getter for what the query variable 'q' will be set to on a
     * <reset_query>.
     * 
     * Parameters: 
     *  n/a
     *
     * Returns:
     *  the current setting of the default query
     */
    this.get_default_query = function(){
	return anchor.default_query;
    };

    /*
     * Function: get_fundamental_query
     *
     * Getter for what the query variable 'q' will be set to on a
     * <reset_default_query>.
     * 
     * Parameters: 
     *  n/a
     *
     * Returns:
     *  the current setting of the fundamental default query
     */
    this.get_fundamental_query = function(){
	return anchor.fundamental_query;
    };

    /*
     * Function: get_query
     *
     * Getter for the query variable ('q').
     * 
     * Parameters: 
     *  n/a
     *
     * Returns:
     *  the current setting of extra
     */
    this.get_query = function(){
	return anchor.query;
    };

    /*
     * Function: reset_query
     *
     * Remove/reset the query variable ('q'); this set it back to the
     * default query.
     *
     * Parameters:
     *  none
     *
     * Returns:
     *  the current value of query
     * 
     * Also see:
     *  <set_default_query>
     *  <reset_default_query>
     */
    this.reset_query = function(){
	anchor.query = anchor.default_query;
	ll('reset query to default: ' + anchor.query);
	return anchor.query;
    };

    /*
     * Function: set_extra
     *
     * Setter for the internal string variable to be appended to the
     * end of a query. For special use cases only (e.g. extend
     * functionality of the API safely).
     * 
     * Parameters: 
     *  new_extra - *[optional]* new value for the extras string
     *
     * Returns:
     *  the current setting of extra
     */
    this.set_extra = function(new_extra){
	anchor.query_extra = new_extra;
	return anchor.query_extra;
    };

    /*
     * Function: get_extra
     *
     * Getter for the internal string variable to be appended
     * to the end of a query.
     *
     * Parameters: 
     *  n/a
     *
     * Returns:
     *  the current setting of extra
     */
    this.get_extra = anchor.set_extra;

    /*
     * Function: remove_extra
     *
     * Remove/reset the extra bit.
     *
     * Parameters:
     *  none
     *
     * Returns:
     *  ""
     */
    this.remove_extra = function(){
	anchor.query_extra = "";
	return anchor.query_extra;
    };

    /*
     * Function: set
     *
     * Set an internal variable for the query. The internal variables
     * are typically things like 'qt', 'indent', etc.--things that you
     * might set and forget a while. It does /not/ include highly
     * dynamic variables (like callback and packet) or querying
     * variables like 'q' and 'fq'; for those you need to use the API.
     *
     * Parameters: 
     *  key - the name of the parameter to change
     *  new_val - what you want the new value to be
     *
     * Returns:
     *  n/a
     */
    this.set = function(key, new_val){
	anchor.query_variants[key] = new_val;
    };

    /*
     * Function: get
     *
     * Get an internal variable for the query.
     *
     * See <set> for the kinds of parameters that can be read.
     * 
     * Parameters: 
     *  key - the name of the parameter to get
     *
     * Returns:
     *  The found value of the key.
     */
    this.get = function(key){
	return anchor.query_variants[key];
    };

    /*
     * Function: unset
     *
     * Unset (remove) an internal variable for the query. Only usable on certain types of 
     * 
     * Only use is you really know what you're doing.
     *
     * Parameters: 
     *  key - the name of the parameter to unset/remove
     *
     * Returns:
     *  boolean; true false on whether the key was found
     */
    this.unset = function(key){
	var retval = false;

	if( typeof(anchor.query_variants[key]) !== 'undefined' ){
	    retval = true;
	    delete anchor.query_variants[key];
	}

	return retval;
    };

    /*
     * Function: include_highlighting
     *
     * Turn hilighting on or off (with true or false).
     * 
     * This essentially adds the parameters to the query string to
     * make sure that basic highlighting on the search is returned.
     * 
     * It starts off as false. The optional html_elt_str argument
     * defaults to:
     *  : <em class="hilite">
     *
     * Parameters: 
     *  hilite_p - *[optional]* boolean
     *  html_elt_str - *[serially optional]* the HTML element string to use
     *
     * Returns:
     *  either false or the current string being used for the return element
     */
    this.include_highlighting = function(hilite_p, html_elt_str){
	var retval = false;

	if( typeof(hilite_p) !== 'undefined' &&
	    (hilite_p === true || hilite_p === false) ){
	    if( hilite_p === true ){

		// Set the default string if necessary.
		if( ! html_elt_str ){ html_elt_str = '<em class="hilite">'; }

		// Set the parameters.
		anchor.set('hl', 'true');
		anchor.set('hl.simple.pre', html_elt_str);

        anchor.set('hl.snippets', anchor.default_hl_snippets);

		// And the retval is not longer false.
		retval = html_elt_str;

	    }else{
		
		// Unset the parameters.
		anchor.unset('hl');
		anchor.unset('hl.simple.pre');
		anchor.unset('hl.snippets');
	    }

	}else{
	    // Otherwise, just discover the current state and return
	    // it.
	    var cl_tmp = anchor.get('hl.simple.pre');
	    if( typeof(cl_tmp) !== 'undefined' ){
		retval = cl_tmp;
	    }
	}

	return retval;
    };

    /*
     * Function: set_personality
     *
     * While we are always contacting the same Solr instance, we
     * sometimes want to have different weights, facets, etc. This
     * function allows us to use the pre-set ones defined in the
     * constructor configuration argument.
     * 
     * Currently, this only sets the 'facet.field' internal variable.
     *
     * Parameters: 
     *  personality_id - string
     *
     * Returns:
     *  Will return false if personality doesn't exist
     */
    this.set_personality = function(personality_id){
	var retval = false;

	// This sets the facet.field internal variable.
	var cclass = anchor._golr_conf.get_class(personality_id);
	if( cclass ){

	    // Remember what our personality is.
	    // WARNING: this line must go before the query_field_set
	    // line below, or else we won't get the "smart" search.
	    this._current_class = cclass;

	    // Set the facets for our class.
	    anchor.facets(cclass.field_order_by_weight('filter'));

	    // Set the query field weights ('qf') necessary to make
	    // queries run properly.
	    anchor.query_field_set(cclass.get_weights('boost'));
	    
	    // Show that we did indeed set a personality.
	    retval = true;
	}

	return retval;
    };

    /*
     * Function: get_personality
     *
     * Returns the current personality, null if none.
     * 
     * Parameters: 
     *  n/a
     *
     * Returns:
     *  Returns the current personality as a string, null if none is set
     */
    this.get_personality = function(){
	var retval = null;

	if( typeof(anchor._current_class) !== 'undefined' &&
	    bbop.what_is(anchor._current_class) === 'golr-conf.conf_class'){
	    retval = anchor._current_class.id();
	}

	return retval;
    };

    /*
     * Function: get_query_url
     *
     * Get the current invariant state of the manager returned as a
     * encoded URL string (using encodeURI()).
     * 
     * This means the URL for the current query to the GOlr store, but
     * without extra information about packets, callbacks, and the
     * like.
     * 
     * This is generally appropriate for getting data, but maybe not
     * for things like high-speed autocomplete where races can
     * occur. For those, you might want to consider <update> or
     * <search>.
     *
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  URL string
     * 
     * Also see:
     *  <update>, <search>
     */
    this.get_query_url = function(){

	// Structure of the necessary invariant parts.	
	var qurl = anchor._solr_url + 'select?';

	// Filters to assemble.
	var assemf = anchor.get_query_filters();
	var fq = anchor.filter_list_to_assemble_hash(assemf);

	// Add all of our different specialized hashes.
	var things_to_add = [
	    //bbop.get_assemble(anchor.query_invariants),
	    //bbop.get_assemble(anchor.query_facets),
	    bbop.get_assemble(anchor.query_variants),
	    bbop.get_assemble(anchor.current_facet_field_limits),
	    //bbop.get_assemble({'fq': anchor.query_sticky_filters}),
	    bbop.get_assemble({'fq': fq}),
	    bbop.get_assemble({'facet.field':
			       us.keys(anchor.facet_fields)}),
	    bbop.get_assemble({'q': anchor.query}),
	    anchor.query_extra
	];
	// Add query_fields ('qf') iff query ('q') is set and it is
	// not length 0.
	if( anchor.query &&
	    anchor.query.length &&
	    anchor.query.length !== 0 &&
	    anchor.query !== anchor.fundamental_query ){
		var in_qf =
		    bbop.get_assemble({'qf': anchor.query_field_set()});
		things_to_add.push(in_qf);
	    }
	
	// Assemble the assemblies into a single URL, throw out
	// everything that seems like it isn't real to keep the URL as
	// clean a possible.
	var filtered_things =
		bbop.pare(things_to_add, function(item, index){
		    var retval = true;
		    if( item && item !== '' ){
			retval = false;
		    }
		    return retval;
		});

	var final_qurl = qurl + filtered_things.join('&');
	ll('qurl: ' + final_qurl);
    	return final_qurl;
    };

    /*
     * Function: push_excursion
     *
     * Save the current state of the manager--data and sticky filter
     * information--onto an internal stack. Batch information is not
     * stored.
     * 
     * Useful for gettinginto a state, doing something else, then
     * returning to the original state.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  the number of items on the excursion stack
     * 
     * Also see:
     *  <get_query_url>
     *  <pop_excursion>
     */
    this.push_excursion = function(){
	
	var now = {
	    // Save current state (data).
	    data_url: anchor.get_query_url(),
	    // Save current state (session).
	    session: {
		// Get the sticky filters.
		sticky_filters: anchor.get_sticky_query_filters()
	    }
	};

	// Save.
	anchor._excursions.push(now);

	// ...
    	return anchor._excursions.length;
    };

    /*
     * Function: pop_excursion
     *
     * Return to a previously pushed state. Batch items are not
     * recovered.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  boolean on whether a state was recovered
     * 
     * Also see:
     *  <get_query_url>
     *  <gpush_excursion>
     */
    this.pop_excursion = function(){
	
	var retval = false;

	var then = anchor._excursions.pop();
	if( then ){
	    retval = true;

	    // Recover data state.
	    var then_data_url = then['data_url'];
	    anchor.load_url(then_data_url);

	    // Recover the session state.
	    var then_session_stickies = then['session']['sticky_filters'];
	    // Add the sticky filters.
	    each(then_session_stickies, function(sticky){
		var flt = sticky['filter'];
		var fvl = sticky['value'];
		var fpl = [];
		if( sticky['negative_p'] === true ){
		    fpl.push('-');
		}
		if( sticky['sticky_p'] === true ){
		    fpl.push('*');
		}
		anchor.add_query_filter(flt, fvl, fpl);
	    });	    
	}
	
    	return retval;
    };

    /*
     * Function: get_download_url
     *
     * Get the current invariant state of the manager returned as a
     * URL string.
     * 
     * This differs from <get_query_url> in that the generated string
     * is intended for text-processing uses rather than computerized
     * searching uses. The idea where is to create a TSV file for
     * downloading and consumption.
     * 
     * Instead of downloading all of the results, a limited listed set
     * can be downloaded using entity_list, which identifies documents by id.
     * 
     * The optional argument hash looks like:
     *  rows - the number of rows to return; defaults to: 1000
     *  encapsulator - how to enclose whitespace fields; defaults to: ""
     *  separator - separator between fields; defaults to: "%09" (tab)
     *  header - whether or not to show headers; defaults to: "false"
     *  mv_separator - separator for multi-valued fields; defaults to: "|"
     *  entity_list - list of specific download items in results; default null
     * 
     * With the entity list, keep in mind that null and an empty list
     * are handled in pretty much the same way--they are an indication
     * that we are going after nothing specific, and so all results
     * are game.
     * 
     * Parameters:
     *  field_list - a list of fields to return
     *  in_arg_hash - *[optional]* additional optional arguments
     * 
     * Returns:
     *  URL string
     * 
     * Also see:
     *  <get_query_url>
     */
    this.get_download_url = function(field_list, in_arg_hash){
	
	// Save current state.
	anchor.push_excursion();

	// Deal with getting arguments in properly.
	var default_hash =
	    {
		rows : 1000,
		encapsulator : '',
		separator : "\t",
		header : 'false',
		mv_separator : "|",
		entity_list : [],
		golr_download_url : null
	    };
	var arg_hash = bbop.fold(default_hash, in_arg_hash);

	// Make the changes we want.
	anchor.set('wt', 'csv');
	anchor.set('start', 0);
	anchor.set('fl', field_list.join(','));
	anchor.set('rows', arg_hash['rows']);
	anchor.set('csv.encapsulator', arg_hash['encapsulator']);
	anchor.set('csv.separator', arg_hash['separator']);
	anchor.set('csv.header', arg_hash['header']);
	anchor.set('csv.mv.separator', arg_hash['mv_separator']);

	// A little more tricky, jimmy the entity list into the query
	// if it's viable.
	var entity_list = arg_hash['entity_list'];
	if( typeof(entity_list) !== 'undefined' &&
	    us.isArray(entity_list) &&
	    entity_list.length > 0 ){
		anchor.set_ids(entity_list);
	}

	// Get url.
	var returl = anchor.get_query_url();

	// If defined, switch download URL to something else.
	if( arg_hash.golr_download_url ){
	    returl = returl.replace(anchor._solr_url,
				    arg_hash.golr_download_url);
	}

	// Reset the old state.
	anchor.pop_excursion();

    	return returl;
    };

    /*
     * Function: get_filter_query_string
     *
     * Get the current state of the manager, as defined by the current
     * gross filter set--query, sticky filters, and standard filters--
     * returned as a URL query string (sans the '?').
     * 
     * This differs from <get_query_url> and <get_state_url> in that
     * the generated string is intended for applications that may want
     * just enough information to recover filter state when the
     * personality, and other types of information, are already
     * known. It is intended to be part of a light RESTy bookmarking
     * mechanism in larger application.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  query string for current filters (sans the '?')
     * 
     * Also see:
     *  <get_query_url>
     *  <get_state_url>
     */
    this.get_filter_query_string = function(){
	
	// // Save current state.
	// anchor.push_excursion();

	var q = anchor.get_query();

	// Get the filters and sort them into sticky and "normal"
	// sets.
	var filters = anchor.get_query_filters();
	var std_filters = [];
	var sticky_filters = [];
	each(filters, function(filter){
	    if( filter['sticky_p'] ){
		sticky_filters.push(filter);
	    }else{
		std_filters.push(filter);
	    }
	});
	
	var fq = anchor.filter_list_to_assemble_hash(std_filters);
	var sfq = anchor.filter_list_to_assemble_hash(sticky_filters);

	var things_to_add = [];
	if( q ){
	    things_to_add.push(bbop.get_assemble({'q': q}));
	}
	if( ! us.isEmpty(fq) ){
	    things_to_add.push(bbop.get_assemble({'fq': fq}));
	}
	if( ! us.isEmpty(sfq) ){
	    things_to_add.push(bbop.get_assemble({'sfq': sfq}));
	}
	    
	// // Reset the old state.
	// anchor.pop_excursion();

	var final_qstr = things_to_add.join('&');
    	return final_qstr;
    };

    /*
     * Function: get_state_url
     *
     * Get the current invariant state of the manager, plus the
     * current personality as a parameter, returned as a URL string.
     * 
     * This differs from <get_query_url> in that the generated string
     * is intended for applications that may want a little more
     * information and hinting over just what the current search
     * is. This method essentially parameterizes some of the "hidden
     * state" of the manager.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  URL string
     * 
     * Also see:
     *  <get_query_url>
     */
    this.get_state_url = function(){
	
	// Save current state.
	anchor.push_excursion();

	// Make the changes we want. First, physically set the
	// "personality", then set pins for jump-in recovery.
	anchor.set('personality', anchor.get_personality());

	// Explicitly set sticky pins for later recovery.
	// Do this pretty much exactly like we do for get_query_url().
	var sticky_filters = anchor.get_sticky_query_filters();
	var sfq = anchor.filter_list_to_assemble_hash(sticky_filters);
	anchor.set('sfq', sfq);
	
	// Get url.
	var returl = anchor.get_query_url();

	// Reset the old state.
	anchor.pop_excursion();

    	return returl;
    };

    /*
     * Function: load_url
     *
     * Makes a a best attempt to recover the state of a manager from
     * the clues left in a data url. This can also (and probably
     * should) be thought of as a "load bookmark"
     * function. Theoretically, you should even be able to use
     * "bookmarks" from alien installations.
     * 
     * Note that while this recovers enough to get the same data,
     * certain "session"/"preference" type things that are not encoded
     * in the url (e.g. filter stickiness, the contents of batch
     * queues, non-default base queries, etc.) will not be replayed
     * and must be recovered or guessed on an app by app basis..
     * 
     * Warning: this currently only replays a small subset of possible
     * parameters. Currently: personality, q, fq, ???. In the future,
     * this should no all non-session information.
     * 
     * Warning: Because there is more to bookmarks than just the major
     * stuff, variants not supplied in the bookmark will be removed.
     * 
     * This returns true if the parameter portions of the new and
     * bookmark urls match. However, this is often not the case--think
     * shifting personalities, etc.
     * 
     * Parameters:
     *  url - A URL string generated by a manager's get_query_url (or similar)
     * 
     * Returns:
     *  boolean
     */
    this.load_url = function(url){

	// // Some Regexps that would be nice to just compile once.
	// var regexp_url_space = /\%20/g; // '%20' === ' '
	// var regexp_url_quote = /\%22/g; // '%22' === '"'
	// var regexp_url_left_paren = /\%28/g; // '%28' === '('
	// var regexp_url_right_paren = /\%29/g; // '%29' === ')'

	// We are assuming that we are consuming our own URLs from
	// get_query_url(), so we start by attempting to decode it
	// (TODO: need a tab watch here)?
	var decoded_url = decodeURI(url);

	// Break down url.
	var in_params = us.map(bbop.url_parameters(decoded_url), function (param_pair) {
		return us.map(param_pair, function (param_component) {
			return decodeURIComponent(param_component);
		});
	});

	// First, look for the personality setting and invoke it if
	// it's there--it will dominate unless we take care of it first.
	// Also note the all the keys that we see (for later erasure
	// of excess).
	var seen_params = {};
	each(in_params, function(ip){
	    var key = ip[0];
	    var val = ip[1];
	    if( key === 'personality' && val && val !== '' ){
		anchor.set_personality(val);
	    }
	    seen_params[key] = true;
	});
	
	// Now cycle through the the parameters again and invoke the
	// appropriate functions to bring them in line.
	var sticky_cache = {};
	each(in_params, function(ip){
	    var key = ip[0];
	    var val = ip[1];
	    if( typeof(val) !== 'undefined' && val !== '' ){
		if( key === 'personality' ){
		    // Already did it, skip.
		}else if( key === 'q' ){
		    anchor.set_query(val);
		}else if( key === 'fq' || key === 'sfq' ){
		    // Split the fq (or sfq) parameter.
		    var fnv = bbop.first_split(':', val);
		    var fname = fnv[0];
		    var fval = fnv[1];
		    //ll('HERE: fname: ' + fname);
		    //ll('HERE: fval: ' + fval);
		    if( fname && fval ){
			
			var plist = [];
			
			// Remove leading sign on a filter and
			// add it to the plist.
			var lead_char = fname.charAt(0);
			if( lead_char === '-' || lead_char === '+' ){
			    plist.push(lead_char);
			    fname = fname.substr(1, fname.length -1);
			}
			
			// // TODO: 
			// // If the fval looks like it has not been
			// // decoded (like from a URL-safe
			// // bookmark), go ahead and do so.
			// fval = fval.replace(regexp_url_space, ' ');
			// fval = fval.replace(regexp_url_quote, '"');
			// fval = fval.replace(regexp_url_left_paren, '(');
			// fval = fval.replace(regexp_url_right_paren,')');
			
			// Do not allow quotes in--they will be
			// added by the assembler.
			fval = bbop.dequote(fval);
			
			// Make it sticky it it came in on "sfq".
			// Note if this is the sticky form.
			var skey = fname + '^' + fval;
			if( key === 'sfq' ){
			    sticky_cache[skey] = true;
			    plist.push('*');
			}
			
			// Add the query filter properly, but
			// only if we have not already added the
			// sticky form (prevent clobbering).
			if( ! bbop.is_defined(sticky_cache[skey]) ||
			    key === 'sfq'){
			    anchor.add_query_filter(fname, fval, plist);
			    
			}
		    }
		}else if( key === 'qf' ){
		    // qf is handles a little strangely...
		    var foo = bbop.first_split('^', val);
		    //ll('qf: key: '+ key +', val: '+ val +', foo: '+ foo);
		    anchor.add_query_field(foo[0], foo[1]);
		}else if( key === 'facet.field' ){
		    anchor.facets(val);
		}else if( key === 'start' || key === 'rows' ){
		    // Numbers need to be handled carefully.
		    if( bbop.what_is(val) === 'string' ){
			val = parseFloat(val);
		    }
		    anchor.set(key, val);
		}else{
		    // This one catches all of the non-special
		    // parameters and resets them using .set().
		    anchor.set(key, val);
		    // if( key === 'fq' ){
		    //     throw new Error("OI");			     
		    // }
		}
	    }
	});
	
	// Now go through and remove all of the query variant
	// parameters that were not seen in the bookmark.
	each(anchor.query_variants, function(val, key){
	    if( typeof(seen_params[key]) === 'undefined'){
		anchor.unset(key);
	    }
	});
	
	// Produce our own url from what we've done. If the parameters
	// match with the incoming argument's return true.
	var curr_url = anchor.get_query_url();
	var curr_params = bbop.url_parameters(curr_url);
	var differences = 0;
	if( in_params.length === curr_params.length ){
	    each(in_params, function(in_p, i){
		var curr_p = curr_params[i];
		if( in_p.length === curr_p.length ){
		    if( in_p.length === 1 ){
			if( in_p[0] === curr_p[0] ){
			    // match!
			}else{
			    differences++;
			}
		    }else if( in_p.length === 2 ){
			if( in_p[0] === curr_p[0] && in_p[1] === curr_p[1] ){
			    // match!
			}else{
			    differences++;
			}
		    }
		}else{
		    differences++;
		}
	    });
	}else{
	    differences++;
	}
	
	// Tally the differences and decides if they're the same.
	var retval = false;
	if( differences === 0 ){
	    retval = true;
	}
    	return retval;
    };

    /*
     * Function: add_to_batch
     *
     * "Save" the current manager state to run later in serial batch
     * mode.
     * 
     * The actual job of running these batches is left to the
     * implementation of the sub-managers; probably in "run_batch".
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  state url
     */
    this.add_to_batch = function(){
	var qurl = anchor.get_query_url();
	anchor._batch_urls.push(qurl);
    	return qurl;
    };

    /*
     * Function: batch_urls
     *
     * Return a pointer to the current batch urls.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  array
     */
    this.batch_urls = function(){
    	return anchor._batch_urls;
    };

    /*
     * Function: next_batch_url
     *
     * Return the next data to be processed, removing it from the
     * batch queue in the process.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  state url or null
     */
    this.next_batch_url = function(){
    	return anchor._batch_urls.shift() || null;
    };

    /*
     * Function: reset_batch
     *
     * Clear the currently queued data batch.
     * 
     * The actual job of running these batches is left to the
     * implementation of the sub-managers; probably in "run_batch".
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  the number of items cleared
     */
    this.reset_batch = function(){
	var num = anchor._batch_urls.length;
	anchor._batch_urls = [];
    	return num;
    };
};
bbop.extend(manager, registry);

/*
 * Function: to_string
 *
 * Output writer for this object/class.
 * See the documentation in <core.js> on <dump> and <to_string>.
 * 
 * Parameters: 
 *  n/a
 *
 * Returns:
 *  string
 */
manager.prototype.to_string = function (){
    return '<' + this._is_a + '>';
};

/*
 * Function: update
 *
 * The user code to select the type of update (and thus the type
 * of callbacks to be called on data return).
 * 
 * This mechanism adds a couple of variables over other methods
 * for bookkeeping: packet (incremented every time) and callback_type.
 * 
 * The currently recognized callback types are "reset" (for when you
 * are starting or starting over) and "search" (what you typically
 * want when you get new data) and "error" for when something went
 * wrong. But only "search" and "reset" manipulate the system.
 * 
 * If rows or start are not set, they will both be reset to their
 * initial values--this is to allow for paging on "current"
 * results and then getting back to the business of searching with
 * as little fuss as possible. Because of things like this, one
 * should avoid calling this directly whenever possible and prefer
 * simpler functionality of the wrapper methods: <search>,
 * <reset>, and <page>.
 * 
 * Parameters: 
 *  callback_type - callback type string; 'search', 'reset' and 'error'
 *  rows - *[optional]* integer; the number of rows to return
 *  start - *[serially optional]* integer; the offset of the returned rows
 *
 * Returns:
 *  the query url (with the jQuery callback specific parameters)
 * 
 * Also see:
 *  <get_query_url>
 */
manager.prototype.update = function(callback_type, rows, start){

    var anchor = this;
    //function ll(s){ this._logger.kvetch(s); }

    // Handle paging in this main section by resetting to
    // the defaults if rows and offset are not explicitly
    // defined.
    if( typeof(rows) === 'undefined' || typeof(start) === 'undefined' ){
    	this.set('rows', this.current_rows);
    	this.set('start', this.current_start);
    }
    
    // Our bookkeeping--increment packet.
    this.last_sent_packet = this.last_sent_packet + 1;
    
    // Necessary updated query variants.
    var update_query_variants = {
    	packet: this.last_sent_packet,
    	callback_type: callback_type
    };
    var update_qv = bbop.get_assemble(update_query_variants);
    
    // Structure of the necessary invariant parts.	
    //var qurl = this.get_query_url();
    var qurl = null;
    
    // Conditional merging of the remaining variant parts.
    if( callback_type === 'reset' ){
	
    	// Take everything back to the initial state--this means
    	// resetting the query and removing all non-sticky
    	// filters.
	
    	// Reset and do completely open query.
    	//ll('reset assembly');
	
    	// Save the q vals, do a fundamental get, then reset to
    	// what we had.
    	//var tmp_save = this.get_query();
    	//this.reset_default_query();
    	this.reset_query();
    	this.reset_query_filters();
    	qurl = this.get_query_url();
    	qurl = qurl + '&' + update_qv;
    	//this.set_query(tmp_save);
	
    }else if( callback_type === 'search' ){
	
    	//ll('search assembly');
    	qurl = this.get_query_url();
    	qurl = qurl + '&' + update_qv;
	
    }else{
    	throw new Error("Unknown callback_type (in update): " + callback_type);
    }

    // Start run.
    this.apply_callbacks('prerun', [anchor]);

    //console.log('qurl: ' + qurl);

    //var thing = anchor._runner(anchor._seed_url, args);
    var thing = anchor._runner(qurl);
    
    return thing;
};

///
/// Exportable body.
///

module.exports = manager;

},{"bbop-core":26,"bbop-registry":30,"bbop-response-golr":32,"golr-conf":57,"underscore":108}],30:[function(require,module,exports){
/* 
 * Generic lightweight listener/callback registry system.
 *
 * @module: bbop-registry
 */

var us = require('underscore');
var each = us.each;
var bbop = require('bbop-core');

/**
 * Contructor for BBOP registry. Takes a list of event categories as
 * strings.
 * 
 * @constructor
 * @param {Array} evt_list - a list of strings that identify the events to be used
 * @returns {Object} bbop registry object
 */
var registry = function(evt_list){
    this._is_a = 'bbop-registry';

    var registry_anchor = this;

    // Handle the registration of call functions to get activated
    // after certain events.
    this.callback_registry = {};
    each(evt_list, function(item, i){
	registry_anchor.callback_registry[item] = {};
    });
    
    /**
     * Add the specified function from the registry, with an optional
     * relative priority against other callback functions.
     *
     * The in_priority value is relative to others in the category,
     * with a higher priority...getting priority.
     * 
     * See also: <apply>
     *
     * @param {String} category - one of the pre-defined categories
     * @param {Function} in_function - function
     * @param {Number} [in_priority] - the higher the faster
     * @param {String} [function_id] - a unique string to identify a function; generated if one is not given
     * @returns {String} the ID for the registered function in the given category
     */
    this.register = function(category, in_function, in_priority, function_id){

	// Only these categories.
	if( typeof(registry_anchor.callback_registry[category]) === 'undefined'){
	    throw new Error('cannot register unknown category');
	}

	// The default priority is 0.
	var priority = 0;
	if( in_priority ){ priority = in_priority; }

	// The default ID is generated, but take one if given.
	var fid = null;
	if( function_id ){
	    fid = function_id;
	}else{
	    fid = bbop.uuid();
	}

	// Final registration.
	registry_anchor.callback_registry[category][fid] = {
	    runner: in_function,
	    priority: priority
	};

	return fid;
    };

    /**
     * Returns whether or not an id has already been registered to a
     * category. Will return null if the category does not exist.
     * 
     * @param {String} category - one of the pre-defined categories
     * @param {String} function_id - a unique string to identify a function
     * @returns {Boolean|null} true, false, or null
     */
    this.is_registered = function(category, function_id){

	var retval = null;

	var anc = registry_anchor.callback_registry;

	//
	if( typeof(anc[category]) !== 'undefined'){
	    
	    retval = false;

	    if( typeof(anc[category][function_id]) !== 'undefined'){
		retval = true;
	    }
	}

	return retval;
    };

    /**
     * Remove the specified function from the registry. Must specify a
     * legitimate category and the function id of the function in it.
     *
     * @param {String} category - string
     * @param {String} function_id - string
     * @returns {Boolean} boolean on whether something was unregistered
     */
    this.unregister = function(category, function_id){
	var retval = false;
	if( registry_anchor.callback_registry[category] &&
	    registry_anchor.callback_registry[category][function_id] ){
		delete registry_anchor.callback_registry[category][function_id];
		retval = true;
            }
	return retval;
    };
    
    /**
     * Generic getter for callback functions, returns by priority.
     *
     * @param {String} category - string
     * @returns {Array} an ordered (by priority) list of function_id strings
     */
    this.get_callbacks = function(category){

	var cb_id_list = us.keys(registry_anchor.callback_registry[category]);
	// Sort callback list according to priority.
	var ptype_registry_anchor = this;
	cb_id_list.sort(
	    function(a, b){  
		var pkg_a =
			ptype_registry_anchor.callback_registry[category][a];
		var pkg_b =
			ptype_registry_anchor.callback_registry[category][b];
		return pkg_b['priority'] - pkg_a['priority'];
	    });
	
	// Collect the actual stored functions by priority.
	var cb_fun_list = [];
	for( var cbi = 0; cbi < cb_id_list.length; cbi++ ){
	    var cb_id = cb_id_list[cbi];
	    var to_run =
		    registry_anchor.callback_registry[category][cb_id]['runner'];
	    cb_fun_list.push(to_run);
	    // ll('callback: ' + category + ', ' + cb_id + ', ' +
	    //    this.callback_registry[category][cb_id]['priority']);
	}
	
	return cb_fun_list;
    };

    /**
     * Generic runner for prioritized callbacks with various arguments
     * and an optional change in context..
     *
     * @param {String} category - string
     * @param {Array} arg_list - a list of arguments to pass to the function in the category
     * @param {String} [context] - the context to apply the arguments in
     */
    this.apply_callbacks = function(category, arg_list, context){

	// Run all against registered functions.
	var callbacks = registry_anchor.get_callbacks(category);
	for( var ci = 0; ci < callbacks.length; ci++ ){
	    var run_fun = callbacks[ci];
	    //run_fun(arg_list);
	    run_fun.apply(context, arg_list);
	}
    };
};

///
/// Exportable body.
///

module.exports = registry;

},{"bbop-core":31,"underscore":108}],31:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"underscore":108}],32:[function(require,module,exports){
/* 
 * Package: response.js
 * 
 * Namespace: bbop.golr.response
 * 
 * Generic BBOP handler for dealing with the gross parsing of
 * responses from a GOlr server (whereas <golr_conf> deals with the
 * reported configuration). This is not intended to do anything like
 * modeling the data in the store (<golr_manager>), but rather to deal
 * with things like checking for success, what paging would look like,
 * what parameters were passed, etc.
 */

var bbop = require('bbop-core');
var us = require('underscore');

var bbop_rest_response = require('bbop-rest-response');

/*
 * Constructor: response
 * 
 * Contructor for a GOlr query response object.
 * 
 * The constructor argument is an object, not a string.
 * 
 * Arguments:
 *  json_data - the JSON data (as object) returned from a request
 * 
 * Returns:
 *  golr response object
 */
var response = function(json_data){
    bbop_rest_response.json.call(this, json_data);
    //console.log('_is_a', this._is_a);
    this._is_a = 'bbop-response-golr';
    //console.log('_is_a', this._is_a);

    // The setting of:
    //   this._raw (as JSON)
    //   this._raw_string (incoming arg)
    //   this._okay (parsability)
    // are left to the superclass.

    // Cache for repeated calls to success().
    this._success = null;

    // Cache for repeated calls to get_doc* functions.
    // These are non-incremental indices--they are either full formed
    // (the first time they are hit) or they are null.
    this._doc_id2index = null;
    this._doc_index2_id = null;

    // Cache for repeated calls to resolve labels.
    // This cache is incremental--the more it's used the larger it gets.
    this._doc_label_maps = {}; // {<field_1>: <parsed_json_map_1>, ...}

    // For highlight stripping, I just want to compile this once.
    this._hl_regexp = new RegExp("\<\[\^\>\]\*\>", "g");

};
bbop.extend(response, bbop_rest_response.json);

/*
 * Function: raw
 * 
 * returns a pointer to the initial response object
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  object
 */
response.prototype.raw = function(){
    return this._raw;
};

/*
 * Function: success
 * 
 * Simple return verification of sane response from server.
 * 
 * Success caches its return value.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  boolean
 */
response.prototype.success = function(){

    if( this._success === null ){

	var robj = this._raw;
	if( robj &&
	    robj.responseHeader &&
	    typeof robj.responseHeader.status !== 'undefined' &&
	    robj.responseHeader.status === 0 &&
	    robj.responseHeader.params &&
	    robj.response &&
	    typeof robj.response.numFound !== 'undefined' &&
	    typeof robj.response.start !== 'undefined' &&
	    typeof robj.response.maxScore !== 'undefined' &&
	    robj.response.docs &&
	    robj.facet_counts &&
	    robj.facet_counts.facet_fields ){
		this._success = true;
	    }else{
		this._success = false;
	    }
    }

    return this._success;
};

/*
 * Function: okay
 * 
 * Alias for <success>.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  boolean
 */
response.prototype.okay = function(){
    return this.success();
};

/*
 * Function: callback_type
 * 
 * Return the callback type if it was specified in the query,
 * otherwise return null. For example "reset" and "response".
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  string (or null)
 */
response.prototype.callback_type = function(){
    var robj = this._raw;
    var retval = null;
    if( robj.responseHeader.params.callback_type &&
	typeof robj.responseHeader.params.callback_type !== 'undefined' ){
	    retval = robj.responseHeader.params.callback_type;
	}
    return retval;
};

/*
 * Function: parameters
 * 
 * Get the parameter chunk--variable stuff we put in.
 * 
 * Pretty general, specialized functions are better.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  hash
 */
response.prototype.parameters = function(){
    var robj = this._raw;
    return robj.responseHeader.params;
};

/*
 * Function: parameter
 * 
 * Get the parameter chunk--variable stuff we put in.
 * 
 * Pretty general, specialized functions are better.
 * 
 * Arguments:
 *  n/a
 *  key - string id for the wanted parameter
 * 
 * Returns:
 *  hash, string, whatever is there at that key (otherwise null)
 */
response.prototype.parameter = function(key){
    var robj = this._raw;
    var retval = null;
    if( robj.responseHeader.params[key] && robj.responseHeader.params[key] ){
	retval = robj.responseHeader.params[key];
    }
    return retval;
};

/*
 * Function: row_step
 * 
 * Returns the number of rows requested (integer).
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  integer
 */
response.prototype.row_step = function(){	
    var robj = this._raw;
    return parseInt(robj.responseHeader.params.rows);
};

/*
 * Function: total_documents
 * 
 * Return the total number of documents found.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  integer
 */
response.prototype.total_documents = function(){
    var robj = this._raw;
    return parseInt(robj.response.numFound);
};

/*
 * Function: start_document
 * 
 * Returns the start document for this response as an integer.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  integer
 */
response.prototype.start_document = function(){
    var robj = this._raw;
    return parseInt(robj.response.start) + 1;
};

/*
 * Function: end_document
 * 
 * Returns the end document for this response as an integer.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  integer
 */
response.prototype.end_document = function(){
    var robj = this._raw;
    return this.start_document() +
	parseInt(robj.response.docs.length) - 1;
};

/*
 * Function: packet
 * 
 * Return the packet number of the current response.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  integer or null (no packet defined)
 */
response.prototype.packet = function(){
    var robj = this._raw;
    var retval = null;
    var pval = robj.responseHeader.params.packet;
    if( pval ){
	retval = parseInt(pval);
    }
    return retval;
};

/*
 * Function: paging_p
 * 
 * Whether or not paging is necessary with the given results set.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  boolean
 */
response.prototype.paging_p = function(){
    var robj = this._raw;
    var retval = false;
    if( this.total_documents() > this.row_step() ){
	retval = true;
    }
    return retval;
};

/*
 * Function: paging_previous_p
 * 
 * Whether or paging backwards is an option right now.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  boolean
 */
response.prototype.paging_previous_p = function(){
    // We'll take this as a proxy that a step was taken.
    // Remember: we offset the start_document by one for readability.
    var robj = this._raw;
    var retval = false;
    if( this.start_document() > 1 ){
	retval = true;
    }
    return retval;
};

/*
 * Function: paging_next_p
 * 
 * Whether or paging forwards is an option right now.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  boolean
 */
response.prototype.paging_next_p = function(){
    // We'll take this as a proxy that a step was taken.
    var robj = this._raw;
    var retval = false;
    if( this.total_documents() > this.end_document() ){
	retval = true;	
    }
    return retval;
};

/*
 * Function: documents
 * 
 * Returns an array of raw and unprocessed document hashes.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  hash
 */
response.prototype.documents = function(){
    var robj = this._raw;
    return robj.response.docs;
};

/*
 * Function: highlighted_documents
 * 
 * Returns an array of raw and unprocessed document hashes.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  hash
 */
response.prototype.highlighted_documents = function(){
    var robj = this._raw;

    var zipped = us.zip(robj.response.docs, us.values(robj.highlighting));
    var hl = us.map(zipped, function(tuple) {
        var json = tuple[0];
        var highlight = tuple[1];

        return us.mapObject(json, function(val, key) {
            if(highlight[key] != null) {
                return highlight[key];
            } else {
                return val;
            }
        });
     });

    return hl;
};

/*
 * Function: get_doc
 * 
 * Returns a specified document, in its raw hash form.
 * 
 * Arguments:
 *  doc_id - document identifier either an id (first) or place in the array
 * 
 * Returns:
 *  document hash or null
 */
response.prototype.get_doc = function(doc_id){

    var doc = null;
    var robj = this._raw;

    // First check if the document is available by position.
    var docs = robj.response.docs;
    if( docs && docs[doc_id] ){
	doc = docs[doc_id];
    }else{ // Not available by position, so lets see if we can get it by id.
	
	//console.log('in: ' + doc_id + ' _' + this._doc_id2index);

	// Build the doc index if it isn't there.
	var local_anchor = this;
	if( ! this._doc_id2index ){
	    //console.log('BUILD triggered on: ' + doc_id);
	    this._doc_id2index = {};
	    this._doc_index2id = {};
	    us.each(docs, function(doc_item, doc_index){
		var did = doc_item['id'];
		//console.log('BUILD: ' + did + ' => ' + doc_index);
		local_anchor._doc_id2index[did] = doc_index;
		local_anchor._doc_index2id[doc_index] = did;
	    });
	}
	
	//console.log('pre-probe: ' + doc_id + ' _' + this._doc_id2index);

	// Try and probe it out.
	if( this._doc_id2index &&
	    typeof(this._doc_id2index[doc_id]) !== 'undefined' ){
		//console.log('PROBE: ' + doc_id);
		var doc_i = this._doc_id2index[doc_id];
		doc = docs[doc_i];
	    }
    }

    return doc;
};

/*
 * Function: get_doc_field
 * 
 * Returns the value(s) of the requested fields.
 * 
 * Remember that determining whether the returned value is a string or
 * a list is left as an exercise for the reader when using this
 * function.
 * 
 * Arguments:
 *  doc_id - document identifier either an id (first) or place in the array
 *  field_id - the identifier of the field we're trying to pull
 * 
 * Returns:
 *  value or list of values
 */
response.prototype.get_doc_field = function(doc_id, field_id){

    var ret = null;

    // If we found our doc, go ahead and start looking for the field.
    var doc = this.get_doc(doc_id);
    if( doc && typeof(doc[field_id]) !== 'undefined' ){
	
	// We have an answer with this.
	ret = doc[field_id];
    }

    return ret;
};

/*
 * Function: get_doc_label
 * 
 * Tries to return a label for a document, field, and id combination.
 * 
 * WARNING: This function could be potentially slow on large datasets.
 * 
 * Arguments:
 *  doc_id - document identifier either an id (first) or place in the array
 *  field_id - the identifier of the field we're trying to pull
 *  item_id - *[optional]* the item identifier that we're trying to resolve; if the field in question is a string or a single-valued list (as opposed to a multi-values list), this argument is not necessary, but it wouldn't hurt either
 * 
 * Returns:
 *  null (not found) or string
 */
response.prototype.get_doc_label = function(doc_id,field_id,item_id){

    var retval = null;

    var anchor = this;

    // If we found our doc, and confirmed that the field in question
    // exists in the doc, go ahead and start digging to resolve the id.
    var doc = this.get_doc(doc_id);
    if( doc && typeof(doc[field_id]) !== 'undefined' ){
	
	// First try the '_label' extension.
	var ilabel = this.get_doc_field(doc_id, field_id + '_label');

	if( ilabel && bbop.what_is(ilabel) === 'string' ){
	    // It looks like the simple solution.
	    //console.log('trivial hit');
	    retval = ilabel; // Hit!
	}else if( ilabel && bbop.what_is(ilabel) === 'array' ){
	    
	    // Well, it's multi-valued, but id might just be the one.
	    var iid = this.get_doc_field(doc_id, field_id);
	    if( ilabel.length === 1 && iid &&
		bbop.what_is(iid) === 'array' &&
		iid.length === 1 ){
		    // Case of a single id trivially mapping to a
		    // single label.
		    //console.log('forced hit');
		    retval = ilabel[0]; // Hit!
		}else{

		    //console.log('need to probe');

		    // Since we'll do this twice with different map
		    // fields, a generic function to try and probe a JSON
		    // string map (caching it along the way) for a label.
		    var _map_to_try = function(doc_key, map_field, item_key){

			var retlbl = null;

			var map_str = anchor.get_doc_field(doc_key, map_field);

			if( map_str && bbop.what_is(map_str) === 'string' ){

			    // First, check the cache. If it's not there
			    // add it.
			    if( typeof(anchor._doc_label_maps[doc_key]) ===  'undefined'){
				anchor._doc_label_maps[doc_key] = {};
			    }
			    if( typeof(anchor._doc_label_maps[doc_key][map_field]) === 'undefined'){
				// It looks like a map wasn't defined, so let's
				// convert it into JSON now.
				anchor._doc_label_maps[doc_key][map_field] =
				    JSON.parse(map_str);
			    }

			    // Pull our map out of the cache.
			    var map = anchor._doc_label_maps[doc_key][map_field];

			    // Probe to see if we have anything in the map.
			    if( map && map[item_key] ){
				retlbl = map[item_key];
			    }
			}

			return retlbl;
		    };

		    // Well, now we know that either we have to find a map
		    // or the information isn't there. First try the
		    // standard "_map".
		    var mlabel = _map_to_try(doc_id, field_id + '_map', item_id);
		    if( mlabel ){
			//console.log('map hit');
			retval = mlabel; // Hit!
		    }else{
			// If that didn't work, try again with
			// "_closure_map".
			var cmlabel =
				_map_to_try(doc_id, field_id + '_closure_map', item_id);
			if( cmlabel ){
			    //console.log('closure map hit');
			    retval = cmlabel; // Hit!
			}else{
			    // If that didn't work, try again with
			    // "_list_map".
			    var lmlabel =
				    _map_to_try(doc_id, field_id +'_list_map', item_id);
			    if( lmlabel ){
				//console.log('list map hit');
				retval = lmlabel; // Hit!
			    }
			}
		    }
		}
	}
    }

    return retval;
};

/*
 * Function: get_doc_highlight
 * 
 * Returns the highlighted value(s) of the requested fields.
 * 
 * WARNING: This function is a work in progress and will not return
 * multi-valued fields, just the first match it finds.
 * 
 * WARNING: This function could be potentially slow on large datasets.
 * 
 * Arguments:
 *  doc_id - document id
 *  field_id - the identifier of the field we're trying to pull
 *  item - the item that we're looking for the highlighted HTML for
 * 
 * Returns:
 *  string of highlight or null if nothing was found
 */
response.prototype.get_doc_highlight = function(doc_id,field_id,item){

    var ret = null;
    var robj = this._raw;
    var hlre = this._hl_regexp;

    // See if we can find a highlighted version in the raw
    // response. First, see if the document is in the hilight section;
    // otherwise try and pull the id out first, then head for the
    // highlight section.
    var hilite_obj = null;
    if( robj.highlighting && robj.highlighting[doc_id] ){
	hilite_obj = robj.highlighting[doc_id];
    }else{
	var iid = this._doc_index2id[doc_id];
	if( iid ){
	    var new_doc = this.get_doc(iid);
	    var new_doc_id = new_doc['id'];
	    if( robj.highlighting && robj.highlighting[new_doc_id] ){
		hilite_obj = robj.highlighting[new_doc_id];
	    }
	}
    }

    // If we got a highlight object, see if the highlighted field is
    // there--search the different possibilities for what a highlight
    // field may be called.
    if( hilite_obj ){
	
	//console.log('here (field_id): ' + field_id);

	var ans = null;

	if( hilite_obj[field_id + '_label_searchable'] ){
	    ans = hilite_obj[field_id + '_label_searchable'];
	}

	if( ! ans ){
	    if( hilite_obj[field_id + '_label'] ){
		ans = hilite_obj[field_id + '_label'];
	    }	    
	}

	if( ! ans ){
	    if( hilite_obj[field_id + '_searchable'] ){
		ans = hilite_obj[field_id + '_searchable'];
	    }
	}

	if( ! ans ){
	    if( hilite_obj[field_id] ){
		//console.log('here (field_id): ' + field_id);
		ans = hilite_obj[field_id];
	    }
	}

	if( ans ){ // looks like I found a list of something

	    // Use only the first match.
	    var matches_p = false;
	    us.each(ans, function(an){
		if( ! matches_p ){
		    var stripped = an.replace(hlre, '');
		    //console.log('stripped: ' + stripped);
		    //console.log('item: ' + item);
		    if( item === stripped ){
			matches_p = true;
			ret = an;
		    }
		}
	    });
	}
    }

    return ret;
};

// /*
//  * Function: facet_fields
//  * 
//  * Return a count sorted array of the response's facet fields and counts.
//  * 
//  * Arguments:
//  *  n/a
//  * 
//  * Returns:
//  *  list of string/integer doublets
//  */
// response.prototype.facet_fields = function(){
//     var robj = this._raw;
//     return robj.facet_counts.facet_fields;
// };

/*
 * Function: facet_field_list
 * 
 * Return a count sorted array of the response's facet fields.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  list of strings
 */
response.prototype.facet_field_list = function(){
    var robj = this._raw;
    return us.keys(robj.facet_counts.facet_fields).sort();
};

/*
 * Function: facet_field
 * 
 * Return a count-sorted array of a facet field's response.
 * 
 * : [["foo", 60], ...]
 * 
 * Arguments:
 *  facet_name - name of the facet to examine
 * 
 * Returns:
 *  list of nested lists
 */
response.prototype.facet_field = function(facet_name){
    var robj = this._raw;
    return robj.facet_counts.facet_fields[facet_name];
};

/*
 * Function: facet_counts
 * 
 * For a given facet field, return a hash of that field's items and
 * their counts.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  hash of facets to their integer counts
 */
response.prototype.facet_counts = function(){

    var robj = this._raw;
    var ret_hash = {};

    var anchor = this;
    
    var facet_field_list = this.facet_field_list();
    us.each(facet_field_list, function(ffield){
	
	// Make sure the top field is present,
	if( ! ret_hash[ffield] ){
	    ret_hash[ffield] = {};		
	}
	
	var facet_field_items = anchor.facet_field(ffield);
	us.each(facet_field_items, function(item, index){
	    var name = item[0];
	    var count = item[1];
	    ret_hash[ffield][name] = count;
	});
    });
    
    return ret_hash;
};

/*
 * Function: query
 * 
 * Return the raw query parameter "q".
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  string or null
 */
response.prototype.query = function(){
    var robj = this._raw;    
    var retval = null;
    
    if( robj.responseHeader.params && robj.responseHeader.params.q ){
	retval = robj.responseHeader.params.q;
    }
    
    return retval;
};

/*
 * Function: query_filters
 *
 * A sensible handling of the not-so-great format of "fq" returned by
 * Solr (fq can be irritating single value or irritating array, along
 * with things like "-" in front of values). Since plus and minus
 * filters are mutually exclusive, we have a return format like:
 * 
 * : {field1: {filter1: (true|false), ...}, ...}
 * 
 * Where the true|false value represents a positive (true) or negative
 * (false) filter.
 * 
 * Parameters:
 *  n/a
 *
 * Returns:
 *  a hash of keyed hashes
 */
response.prototype.query_filters = function(){
    var robj = this._raw;    
    var ret_hash = {};
    var fq_list = this.parameter('fq');
    if( fq_list ){
	
	// Ensure that it's a list and not just a naked string (as can
	// sometimes happen).
	if( bbop.what_is(fq_list) === 'string'){
	    fq_list = [fq_list];
	}
	
	// Make the return fq more tolerable.
	us.each(fq_list, function(fq_item){
	    
	    // Split everything on colons. Field is the first
	    // one, and everything else joined back together is
	    // the value of the filter. Best if you think about
	    // the GO id and non-GO id cases.
	    var splits = fq_item.split(":");
	    var field = splits.shift();
	    var value = splits.join(":"); // GO 0022008 -> GO:0022008
	    
	    // First let's just assume that we have a positive
	    // filter.
	    var polarity = true;
	    
	    // Check and see if the first value in our
	    // field is '-' or '+'. If so, edit it out, but
	    // change the polarity in the '-' case.
	    if( field.charAt(0) === '-' ){
		polarity = false;
		field = field.substring(1, field.length);
	    }else if( field.charAt(0) === '+' ){
		field = field.substring(1, field.length);
	    }
	    
	    // Ensure that there is a place in the return hash
	    // for us.
	    if( ! ret_hash[field] ){
		ret_hash[field] = {};
	    }
	    
	    // I want just the first quote and the final quote
	    // gone from the value if they are matching quotes.
	    if( value.charAt(0) === '"' &&
		value.charAt(value.length -1) === '"' ){
		    value = value.substring(1, value.length -1);
		}
	    
	    // The final filter note.
	    ret_hash[field][value] = polarity;
	    
	});
    }
    
    return ret_hash;
};

///
/// Exportable body.
///

module.exports = response;

},{"bbop-core":33,"bbop-rest-response":37,"underscore":108}],33:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"underscore":108}],34:[function(require,module,exports){
/** 
 * Generic BBOP manager for dealing with basic generic REST calls.
 * This specific one is designed to be overridden by its subclasses.
 * This one pretty much just uses its incoming resource string as the data.
 * Mostly for testing purposes.
 * 
 * Both a <bbop-rest-response> (or clean error data) and the manager
 * itself (this as anchor) should be passed to the callbacks.
 *
 * @module bbop-rest-manager
 */

// For base.
var us = require('underscore');
var each = us.each;
var bbop = require('bbop-core');
var registry = require('bbop-registry');

// For engines.
var Q = require('q');
var querystring = require('querystring');
var jQuery = require('jquery');
var sync_request = require('sync-request');

///
/// Base class.
///

/**
 * Contructor for the REST manager.
 * 
 * See also: module:bbop-registry
 * 
 * @constructor
 * @param {Object} response_parser - the response handler class to use for each call
 * @returns {Object} rest manager object
 */
function manager_base(response_handler){
    registry.call(this, ['success', 'error']);
    this._is_a = 'bbop-rest-manager.base';

    // Get a good self-reference point.
    var anchor = this;

    // Per-manager logger.
    this._logger = new bbop.logger(this._is_a);
    //this._logger.DEBUG = true;
    this._logger.DEBUG = false;
    function ll(str){ anchor._logger.kvetch(str); }

    // Handler instance.
    this._response_handler = response_handler;

    // The URL to query.
    this._qurl = null;

    // The argument payload to deliver to the URL.
    this._qpayload = {};

    // The way to do the above.
    this._qmethod = 'GET';

    this._headers = [];

    // Whether or not to prevent ajax events from going.
    // This may not be usable, or applicable, to all backends.
    this._safety = false;

    /**
     * Turn on or off the verbose messages. Uses <bbop.logger>, so
     * they should come out everywhere.
     * 
     * @param {Boolean} [p] - true or false for debugging
     * @returns {Boolean} the current state of debugging
     */
    this.debug = function(p){
	if( p === true || p === false ){
	    this._logger.DEBUG = p;
	    // TODO: add debug parameter a la include_highlighting
	}
	return this._logger.DEBUG;
    };

    // The main callback function called after a successful AJAX call in
    // the update function.
    this._run_success_callbacks = function(in_data){
	ll('run success callbacks...');
	//var response = anchor.(in_data);
	var response = new anchor._response_handler(in_data);
	anchor.apply_callbacks('success', [response, anchor]);
    };

    // This set is called when we run into a problem.
    this._run_error_callbacks = function(in_data){
	ll('run error callbacks...');
	var response = new anchor._response_handler(in_data);
	anchor.apply_callbacks('error', [response, anchor]);
    };

    // Ensure the necessary 
    this._ensure_arguments = function (url, payload, method, headers){
	ll('ensure arguments...');
	
	// Allow default settings to be set at the moment.
	if( typeof(url) !== 'undefined' ){ this.resource(url); }
	if( typeof(payload) !== 'undefined' ){ this.payload(payload); }
	if( typeof(method) !== 'undefined' ){ this.method(method); }
	if( typeof(headers) !== 'undefined' ){ this.headers(headers); }
	
	// Bail if no good resource to try.
	if( ! this.resource() ){
	    throw new Error('must have resource defined');
	}
    };

    // Apply the callbacks by the status of the response.
    this._apply_callbacks_by_response = function (response){
	ll('apply callbacks by response...');

	if( response && response.okay() ){
	    anchor.apply_callbacks('success', [response, anchor]);
	}else{
	    anchor.apply_callbacks('error', [response, anchor]);
	}
    };

    /**
     * The base target URL for our operations.
     * 
     * @param {String} [in_url] - update resource target with string
     * @returns {String|null} the url as string (or null)
     */
    this.resource = function(in_url){
	ll('resource called with: ' + in_url);

	if( typeof(in_url) !== 'undefined' && 
	    bbop.what_is(in_url) === 'string' ){
	    anchor._qurl = in_url;
	}
	return anchor._qurl;
    };

    /**
     * The information to deliver to the resource.
     * 
     * @param {Object} [payload] - update payload information
     * @returns {Object|null} a copy of the current payload
     */
    this.payload = function(payload){
	ll('payload called with: ' + payload);

	if( bbop.is_defined(payload) && 
	    bbop.what_is(payload) === 'object' ){
	    anchor._qpayload = payload;
	}
	return bbop.clone(anchor._qpayload);
    };

    /**
     * The method to use to get the resource, as a string.
     * 
     * @param {String} [method] - update aquisition method with string
     * @returns {String|null} the string or null
     */
    this.method = function(method){
	ll('method called with: ' + method);

	if( bbop.is_defined(method) && 
	    bbop.what_is(method) === 'string' ){
	    anchor._qmethod = method;
	}
	return anchor._qmethod;
    };

    /**
     * The headers to use to get the resource, as a list of pairs.
     * 
     * @param {Array} [headers] - update headers to send with form of: [['x-content', 'x/blarg'], ...]
     * @returns {Array} the current headers list
     */
    this.headers = function(in_headers){
	ll('headers called with: ' + in_headers);

	if( in_headers && us.isArray(in_headers) ){
	    anchor._headers = in_headers;
	}
	return anchor._headers;
    };

    /**
     * Coordinate an arbitary number of promise generating functions
     * serially.
     * 
     * @param {Array} [promise_function_stack] - An ordered list of functions that produce a Q promise in the order that they should be run.
     * @param {Function} [accumulator_function] - The function to run on every successful return; it takes a single <bbop-response-golr> and this manager as arguments.
     * @param {Function} [final_function] - The function to run after all queries have completed; it takes this manager as an argument.
     * @param {Function} [error_function] - The function to run on an error; it takes the Q error and this manager as arguments.
     * @returns {Number} the number of functions that will run
     */
    anchor.run_promise_functions = function(promise_function_stack, 
					    accumulator_function,
					    final_function,
					    error_function){
	if( ! us.isEmpty(promise_function_stack) ){
            var promise_runner = promise_function_stack.shift();
            promise_runner().then(function(resp){
		accumulator_function(resp, anchor);
		anchor.run_promise_functions(promise_function_stack,
					     accumulator_function,
					     final_function,
					     error_function);
            }).fail(function(err){
		if(err){
                    error_function(err, anchor);
		}
            }).done();
	}else{
            final_function(anchor);
	}

	// Return the number of functions that will be run.
	return promise_function_stack.length || 0;
    };

}
bbop.extend(manager_base, registry);

///
/// Overridables.
///

/**
 * It should combine the URL, payload, and method in the ways
 * appropriate to the subclass engine.
 * 
 * This model class always returns true, with set messages; the
 * "payload" is fed as the argument into the response handler.
 * 
 * What we're aiming for is a system that:
 *  - runs callbacks (in order: success, error, return)
 *  - return response
 * 
 * @param {String} [url] - update resource target with string
 * @param {Object} [payload] - object to represent arguments
 * @param {String} [method] - GET, POST, etc.
 * @param {Array} [headers] - List of header pairs. 
 * @returns {Object} response (given the incoming payload)
 */
manager_base.prototype.fetch = function(url, payload, method, headers){

    var anchor = this;
    anchor._logger.kvetch('called fetch');

    this._ensure_arguments(url, payload, method, headers);

    // This is an empty "sync" example, so just return the empty and
    // see.
    var response = new this._response_handler(this.payload());
    response.okay(true);
    response.message('empty');
    response.message_type('success');
    
    // Run through the callbacks--naturally always "success" in our
    // case.
    this._apply_callbacks_by_response(response);

    return response;
};

/**
 * It should combine the URL, payload, and method in the ways
 * appropriate to the subclass engine.
 * 
 * This model class always returns true, with set messages; the
 * "payload" is fed as the argument into the response handler.
 * 
 * What we're aiming for is a system that:
 *  - runs callbacks (in order: success, error, return)
 *  - return promise (delivering response)
 * 
 * @param {String} [url] - update resource target with string
 * @param {Object} [payload] - object to represent arguments
 * @param {String} [method] - GET, POST, etc.
 * @param {Array} [headers] - List of header pairs. 
 * @returns {Object} promise for the processed response subclass
 */
manager_base.prototype.start = function(url, payload, method, headers){

    var anchor = this;
    this._ensure_arguments(url, payload, method, headers);

    // No actual async here, but do anyways.
    var deferred = Q.defer();

    // This is an empty "sync" example, so just return the empty and
    // see.
    var response = new this._response_handler(this.payload());
    response.okay(true);
    response.message('empty');
    response.message_type('success');
    
    // Run through the callbacks--naturally always "success" in our
    // case.
    this._apply_callbacks_by_response(response);

    deferred.resolve(response);

    return deferred.promise;
};

///
/// Node async engine.
///

/**
 * Contructor for the REST query manager; NodeJS-style.
 * 
 * This is an asynchronous engine, so while both fetch and start will
 * run the callbacks, fetch will return null while start returns a
 * promise for the eventual result. Using the promise is entirely
 * optional--the main method is still considered to be the callbacks.
 * 
 * NodeJS BBOP manager for dealing with remote calls. Remember,
 * this is actually a "subclass" of <bbop.rest.manager>.
 * 
 * See also: {module:bbop-rest-manager#manager}
 *
 * @constructor
 * @param {Object} response_handler
 * @returns {manager_node}
 */
var manager_node = function(response_handler){
    manager_base.call(this, response_handler);
    this._is_a = 'bbop-rest-manager.node';

    // Grab an http(s) client.
    this._http_client = require('http');
    this._https_client = require('https');
    this._url_parser = require('url');
};
bbop.extend(manager_node, manager_base);

/**
 * It should combine the URL, payload, and method in the ways
 * appropriate to the subclass engine.
 *
 * Runs callbacks, returns null.
 * 
 * @param {String} [url] - update resource target with string
 * @param {Object} [payload] - object to represent arguments
 * @param {String} [method] - GET, POST, etc.
 * @param {Array} [headers] - List of header pairs. 
 * @returns {null} returns null
 */
manager_node.prototype.fetch = function(url, payload, method, headers){

    var anchor = this;
    anchor._logger.kvetch('called fetch');

    // As we /only/ have async here, pass off to start().
    this.start(url, payload, method, headers);

    return null;
};

/**
 * It should combine the URL, payload, and method in the ways
 * appropriate to the subclass engine.
 * 
 * What we're aiming for is a system that:
 *  - runs callbacks (in order: success, error, return)
 *  - return promise (delivering response)
 * 
 * WARNING/NOTE: This method automatically injects the headers:
 * 'Content-Type': 'application/x-www-form-urlencoded' and
 * 'Content-Length': <calculated> during a POST. 
 * 
 * @param {String} [url] - update resource target with string
 * @param {Object} [payload] - object to represent arguments
 * @param {String} [method] - GET, POST, etc.
 * @param {Array} [headers] - List of header pairs. 
 * @returns {Object} promise for the processed response subclass
 */
manager_node.prototype.start = function(url, payload, method, headers){

    var anchor = this;

    this._ensure_arguments(url, payload, method, headers);

    // Our eventual promise.
    var deferred = Q.defer();

    // What to do if an error is triggered.
    function on_error(e) {
	console.log('problem with request: ' + e.message);
	var response = new anchor._response_handler(null);
	response.okay(false);
	response.message(e.message);
	response.message_type('error');
	anchor.apply_callbacks('error', [response, anchor]);
	deferred.resolve(response);
    }

    // Two things to do here: 1) collect data and 2) what to do with
    // it when we're done (create response).
    function on_connect(res){
	//console.log('STATUS: ' + res.statusCode);
	//console.log('HEADERS: ' + JSON.stringify(res.headers));
	res.setEncoding('utf8');
	var raw_data = '';
	res.on('data', function (chunk) {
	    //console.log('BODY: ' + chunk);
	    raw_data = raw_data + chunk;
	});
	// Throw to .
	res.on('end', function () {
	    //console.log('END with: ' + raw_data);
	    var response = new anchor._response_handler(raw_data);
	    if( response && response.okay() && res.statusCode < 400){
		anchor.apply_callbacks('success', [response, anchor]);
		deferred.resolve(response);
	    }else{
		// Make sure that there is something there to
		// hold on to.
		if( ! response ){
		    response = new anchor._response_handler(null);
		    response.okay(false);
		    response.message_type('error');
		    response.message('null response');
		}else{
		    response.okay(false);
		    response.message_type('error');
		    response.message('bad response');
		}
		anchor.apply_callbacks('error', [response, anchor]);
		deferred.resolve(response);
	    }
	});
    }

    // http://nodejs.org/api/url.html
    var purl = anchor._url_parser.parse(anchor.resource());
    var protocol = purl['protocol'];
    var req_opts = {
    	//'hostname': anchor.resource(),
    	//'path': '/amigo/term/GO:0022008/json',
	//'port': 80,
	'method': anchor.method(),
	'headers': us.object(anchor.headers())
    };
    // Tranfer the interesting bit over.
    each(['protocol', 'hostname', 'port', 'path'], function(purl_prop){
    	if( purl[purl_prop] ){
    	    req_opts[purl_prop] = purl[purl_prop];
    	}
    });

    // Add any payload if it exists. On an empty payload, post_data
    // will still be '', so no real harm done.
    var post_data = '';
    if( ! us.isEmpty(anchor.payload()) ){
	if( anchor.method() === 'POST' ){
	    post_data = querystring.stringify(anchor.payload());
	    // WARNING: Injecting headers for some reason.
	    req_opts['headers']['Content-Type'] =
		'application/x-www-form-urlencoded';
	    req_opts['headers']['Content-Length'] = post_data.length;
	}else{
	    var qs = querystring.stringify(anchor.payload());
	    if( qs ){
		req_opts['path'] = req_opts['path'] + '?' + qs;
	    }else{
		req_opts['path'] = req_opts['path'];
	    }
	}
    }

    //console.log('req_opts', req_opts);

    // Ready either an HTTP or HTTPS run.
    var req = null;
    if( protocol && protocol === 'https:' ){
	req = anchor._https_client.request(req_opts, on_connect);
    }else{
	req = anchor._http_client.request(req_opts, on_connect);
    }
    //console.log('protocol', protocol);
    //console.log('protocol', protocol);
    
    // Oh yeah, add the error responder.
    req.on('error', on_error);
    
    // Write data to request body.
    if( anchor.method() === 'POST' ){
	req.write(post_data);
    }
    req.end();
    
    return deferred.promise;
};

///
/// Node sync engine.
///

/**
 * Contructor for the REST query manager--synchronous in node.
 * 
 * This is an synchronous engine, so while both fetch and start will
 * run the callbacks, fetch will return a response while start returns
 * an instantly resolvable promise. Using the response results is
 * entirely optional--the main method is still considered to be the
 * callbacks.
 * 
 * See also: <bbop.rest.manager>
 * 
 * @constructor
 * @param {Object} response_handler
 * @returns {manager_sync_request}
  */
var manager_sync_request = function(response_handler){
    manager_base.call(this, response_handler);
    this._is_a = 'bbop-rest-manager.sync_request';
};
bbop.extend(manager_sync_request, manager_base);

/**
 * It should combine the URL, payload, and method in the ways
 * appropriate to the subclass engine.
 * 
 * WARNING/NOTE: This method automatically injects the headers:
 * 'Content-Type': 'application/x-www-form-urlencoded' and
 * 'Content-Length': <calculated> during a POST. 
 * 
 * @param {String} [url] - update resource target with string
 * @param {Object} [payload] - object to represent arguments
 * @param {String} [method] - GET, POST, etc.
 * @param {Array} [headers] - List of header pairs. 
 * @returns {Object} returns response
 */
manager_sync_request.prototype.fetch = function(url, payload, method, headers){
    var anchor = this;

    this._ensure_arguments(url, payload, method, headers);

    // The wrapped version of the post request.
    function _post_request(){
	var res = null;

	// 
	try {
	    var use_headers = us.object(anchor.headers());

	    // Need special handling if we are posting something to
	    // the server.
	    if( ! us.isEmpty(anchor.payload()) ){
		var qs = querystring.stringify(anchor.payload());
		//console.log('qs',qs);
		// WARNING: Injecting headers.
		use_headers['Content-Type'] =
		    'application/x-www-form-urlencoded';
		use_headers['Content-Length'] = qs.length;
		res = sync_request('POST', anchor.resource(), {
		    'headers': use_headers,
		    'body': qs
		});
	    }else{
		res = sync_request('POST', anchor.resource(), {
		    'headers': use_headers
		});
		//console.log('res', res);
	    }
	}
	catch(e){
	    console.log('ERROR in sync_request call, will try to recover');
	}
	
	return res;
    }

    function _get_request(){
	var res = null;

	// 
	try {
	    var use_headers = us.object(anchor.headers());
	    
	    // Need special handling if we are sending something to
	    // the server.
	    if( ! us.isEmpty(anchor.payload()) ){

		var qs = querystring.stringify(anchor.payload());
		//console.log('qs',qs);

		if( qs ){
		    res = sync_request('GET', anchor.resource() + '?' + qs, {
			'headers': use_headers
		    });
		}else{
		    res = sync_request('GET', anchor.resource(), {
			'headers': use_headers
		    });
		}
	    }else{
		res = sync_request('GET', anchor.resource(), {
		    'headers': use_headers
		});
		//console.log('res', res);
	    }
	}
	catch(e){
	    console.log('ERROR in sync_request call, will try to recover');
	}
	
	return res;
    }

    // Minimal processing and then grab the data from the server.
    var res = null;
    if( anchor.method() === 'POST' ){
	res = _post_request();
    }else{
	res = _get_request();
    }
    
    //
    var raw_str = null;
    if( res && res.statusCode < 400 ){
	raw_str = res.getBody().toString();
    }else if( res && res.body ){
	raw_str = res.body.toString();
    }else{
	//
    }
    
    // Process and pick the right callback group accordingly.
    var response = new anchor._response_handler(raw_str);
    if( raw_str && raw_str !== '' && res.statusCode < 400 ){
	this.apply_callbacks('success', [response, anchor]);
    }else{
	this.apply_callbacks('error', [response, anchor]);
	//throw new Error('explody');
    }

    return response;
};

/**
 * This is the synchronous data getter for Node (and technically the
 * browser, but never never do that)--probably your best bet right now
 * for scripting.
 * 
 * Works as fetch, except returns an (already resolved) promise.
 * 
 * @param {String} [url] - update resource target with string
 * @param {Object} [payload] - object to represent arguments
 * @param {String} [method] - GET, POST, etc.
 * @param {Array} [headers] - List of header pairs. 
 * @returns {Object} returns promise
 */
manager_sync_request.prototype.start = function(url, payload, method, headers){
    var anchor = this;

    var response = anchor.fetch(url, payload, method, headers);

    // .
    var deferred = Q.defer();
    deferred.resolve(response);
    return deferred.promise;
};

///
/// jQuery engine.
///

/**
 * Contructor for the jQuery REST manager
 * 
 * jQuery BBOP manager for dealing with actual ajax calls. Remember,
 * this is actually a "subclass" of {bbop-rest-manager}.
 * 
 * Use <use_jsonp> is you are working against a JSONP service instead
 * of a non-cross-site JSON service.
 * 
 * See also:
 *  <bbop.rest.manager>
 *
 * @constructor
 * @param {Object} response_handler
 * @returns {manager_sync_request}
 */
var manager_jquery = function(response_handler){
    manager_base.call(this, response_handler);
    this._is_a = 'bbop-rest-manager.jquery';

    this._use_jsonp = false;
    this._jsonp_callback = 'json.wrf';
    
    // Track down and try jQuery.
    var anchor = this;
    //anchor.JQ = new bbop.rest.manager.jquery_faux_ajax();
    try{ // some interpreters might not like this kind of probing
    	if( typeof(jQuery) !== 'undefined' ){
    	    anchor.JQ = jQuery;
    	    //anchor.JQ = jQuery.noConflict();
    	}
    }catch (x){
	throw new Error('unable to find "jQuery" in the environment');
    }
};
bbop.extend(manager_jquery, manager_base);

/**
 * Set the jQuery engine to use JSONP handling instead of the default
 * JSON. If set, the callback function to use will be given my the
 * argument "json.wrf" (like Solr), so consider that special.
 * 
 * @param {Boolean} [use_p] - external setter for 
 * @returns {Boolean} boolean
 */
manager_jquery.prototype.use_jsonp = function(use_p){
    var anchor = this;
    if( typeof(use_p) !== 'undefined' ){
	if( use_p === true || use_p === false ){
	    anchor._use_jsonp = use_p;
	}
    }
    return anchor._use_jsonp;
};

/**
 * Get/set the jQuery jsonp callback string to something other than
 * "json.wrf".
 * 
 * @param {String} [cstring] - setter string
 * @returns {String} string
 */
manager_jquery.prototype.jsonp_callback = function(cstring){
    var anchor = this;
    if( typeof(cstring) !== 'undefined'  ){
	anchor._jsonp_callback = cstring;
    }
    return anchor._jsonp_callback;
};

/**
 * It should combine the URL, payload, and method in the ways
 * appropriate to the subclass engine.
 *
 * Runs callbacks, returns null.
 * 
 * @param {String} [url] - update resource target with string
 * @param {Object} [payload] - object to represent arguments
 * @param {String} [method] - GET, POST, etc.
 * @param {Array} [headers] - List of header pairs. 
 * @returns {null} returns null
 */
manager_jquery.prototype.fetch = function(url, payload, method, headers){

    var anchor = this;
    anchor._logger.kvetch('called fetch');

    // Pass off.
    anchor.start(url, payload, method, headers);

    return null;
};

/**
 * See the documentation in <manager.js> on update to get more
 * of the story. This override function adds functionality for
 * jQuery.
 * 
 * @param {String} [url] - update resource target with string
 * @param {Object} [payload] - object to represent arguments
 * @param {String} [method] - GET, POST, etc.
 * @param {Array} [headers] - List of header pairs. 
 * @returns {Object} promise for the processed response subclass
 */
manager_jquery.prototype.start = function(url, payload, method, headers){

    var anchor = this;
    
    this._ensure_arguments(url, payload, method, headers);

    // Our eventual promise.
    var deferred = Q.defer();

    // URL and payload (jQuery will just append as arg for GETs).
    //var qurl = anchor.resource();
    //var pl = anchor.payload();

    // The base jQuery Ajax args we need with the setup we have.
    var jq_vars = {};
    if( anchor.method() === 'GET' ){
    	jq_vars['type'] = 'GET';
	var qs = querystring.stringify(anchor.payload());
	if( qs ){
    	    jq_vars['url'] = anchor.resource() + '?' + qs;
	}else{
    	    jq_vars['url'] = anchor.resource();
	}
    }else{ // POST
    	jq_vars['type'] = 'POST';
    	jq_vars['url'] = anchor.resource();
	jq_vars['data'] = anchor.payload();
    	jq_vars['dataType'] = 'json';
	// headers: {
	//     "Content-Type": "application/javascript",
	//     "Accept": "application/javascript"
	// },
    }

    // If we're going to use JSONP instead of the defaults, set that now.
    if( anchor.use_jsonp() ){
	jq_vars['dataType'] = 'jsonp';
	jq_vars['jsonp'] = anchor._jsonp_callback;
    }

    // 
    if( ! us.isEmpty(anchor.headers()) ){
    	jq_vars['headers'] = us.object(anchor.headers());
    }

    // What to do if an error is triggered.
    // Remember that with jQuery, when using JSONP, there is no error.
    function on_error(xhr, status, error) {
	var response = new anchor._response_handler(null);
	response.okay(false);
	response.message(error);
	response.message_type(status);
	anchor.apply_callbacks('error', [response, anchor]);
	deferred.resolve(response);
    }

    function on_success(raw_data, status, xhr){
	var response = new anchor._response_handler(raw_data);
	if( response && response.okay() ){
	    anchor.apply_callbacks('success', [response, anchor]);
	    deferred.resolve(response);
	}else{
	    // Make sure that there is something there to
	    // hold on to.
	    if( ! response ){
		response = new anchor._response_handler(null);
		response.okay(false);
		response.message_type(status);
		response.message('null response');
	    }else{
		response.message_type(status);
		response.message('bad response');
	    }
	    //anchor.apply_callbacks('error', [response, anchor]);
	    //anchor.apply_callbacks('error', [raw_data, anchor]);
	    anchor.apply_callbacks('error', [response, anchor]);
	    deferred.resolve(response);
	}
    }

    // Setup JSONP for Solr and jQuery ajax-specific parameters.
    jq_vars['success'] = on_success;
    jq_vars['error'] = on_error;
    //done: _callback_type_decider, // decide & run search or reset
    //fail: _run_error_callbacks, // run error callbacks
    //always: function(){} // do I need this?
    anchor.JQ.ajax(jq_vars);

    return deferred.promise;
};

///
/// Exportable body.
///

module.exports = {

    "base" : manager_base,
    "node" : manager_node,
    "sync_request" : manager_sync_request,
    "jquery" : manager_jquery

};

},{"bbop-core":35,"bbop-registry":30,"http":80,"https":66,"jquery":36,"q":73,"querystring":76,"sync-request":100,"underscore":108,"url":114}],35:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"underscore":108}],36:[function(require,module,exports){
/*!
 * jQuery JavaScript Library v2.1.4
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2015-04-28T16:01Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Support: Firefox 18+
// Can't be in strict mode, several libs including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
//

var arr = [];

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,

	version = "2.1.4",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {
		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		// adding 1 corrects loss of precision from parseFloat (#15100)
		return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;
	},

	isPlainObject: function( obj ) {
		// Not plain objects:
		// - Any object or value whose internal [[Class]] property is not "[object Object]"
		// - DOM nodes
		// - window
		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		if ( obj.constructor &&
				!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
			return false;
		}

		// If the function hasn't returned already, we're confident that
		// |obj| is a plain object, created by {} or constructed with new Object
		return true;
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}
		// Support: Android<4.0, iOS<6 (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call(obj) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		var script,
			indirect = eval;

		code = jQuery.trim( code );

		if ( code ) {
			// If the code includes a valid, prologue position
			// strict mode pragma, execute code by injecting a
			// script tag into the document.
			if ( code.indexOf("use strict") === 1 ) {
				script = document.createElement("script");
				script.text = code;
				document.head.appendChild( script ).parentNode.removeChild( script );
			} else {
			// Otherwise, avoid the DOM node creation, insertion
			// and removal by using an indirect global eval
				indirect( code );
			}
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE9-11+
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Support: Android<4.1
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {

	// Support: iOS 8.2 (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = "length" in obj && obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.2.0-pre
 * http://sizzlejs.com/
 *
 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-16
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// http://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + characterEncoding + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		// QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];
	nodeType = context.nodeType;

	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	if ( !seed && documentIsHTML ) {

		// Try to shortcut find operations when possible (e.g., not under DocumentFragment)
		if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document (jQuery #6963)
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && support.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				return results;
			}
		}

		// QSA path
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType !== 1 && selector;

			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, parent,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Set our document
	document = doc;
	docElem = doc.documentElement;
	parent = doc.defaultView;

	// Support: IE>8
	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	// IE6-8 do not support the defaultView property so parent will be undefined
	if ( parent && parent !== parent.top ) {
		// IE11 does not have attachEvent, so all must suffer
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", unloadHandler, false );
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Support tests
	---------------------------------------------------------------------- */
	documentIsHTML = !isXML( doc );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( doc.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\f]' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( div.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibing-combinator selector` fails
			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = doc.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return doc;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {
							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						// Use previously-cached element index if available
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							// Use the same loop as above to seek `elem` from the start
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									// Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (oldCache = outerCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							outerCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context !== document && context;
			}

			// Add elements passing elementMatchers directly to results
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is no seed and only one group
	if ( match.length === 1 ) {

		// Take a shortcut and set the context if the root selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		});

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		});

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
	});
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		}));
};

jQuery.fn.extend({
	find: function( selector ) {
		var i,
			len = this.length,
			ret = [],
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow(this, selector || [], false) );
	},
	not: function( selector ) {
		return this.pushStack( winnow(this, selector || [], true) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Support: Blackberry 4.6
					// gEBID returns nodes no longer in the document (#6963)
					if ( elem && elem.parentNode ) {
						// Inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return typeof rootjQuery.ready !== "undefined" ?
				rootjQuery.ready( selector ) :
				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.extend({
	dir: function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	}
});

jQuery.fn.extend({
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter(function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
				// Always skip document fragments
				if ( cur.nodeType < 11 && (pos ?
					pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector(cur, selectors)) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.unique(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

function sibling( cur, dir ) {
	while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {
			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.unique( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
});
var rnotwhite = (/\S+/g);



// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( list && ( !fired || stack ) ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// Add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// If we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend({
	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( "ready" );
			jQuery( document ).off( "ready" );
		}
	}
});

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed, false );
	window.removeEventListener( "load", completed, false );
	jQuery.ready();
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// We once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		} else {

			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );
		}
	}
	return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {
			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[0], key ) : emptyGet;
};


/**
 * Determines whether an object can have data
 */
jQuery.acceptData = function( owner ) {
	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	/* jshint -W018 */
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};


function Data() {
	// Support: Android<4,
	// Old WebKit does not have Object.preventExtensions/freeze method,
	// return new empty object instead with no [[set]] accessor
	Object.defineProperty( this.cache = {}, 0, {
		get: function() {
			return {};
		}
	});

	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;
Data.accepts = jQuery.acceptData;

Data.prototype = {
	key: function( owner ) {
		// We can accept data for non-element nodes in modern browsers,
		// but we should not, see #8335.
		// Always return the key for a frozen object.
		if ( !Data.accepts( owner ) ) {
			return 0;
		}

		var descriptor = {},
			// Check if the owner object already has a cache key
			unlock = owner[ this.expando ];

		// If not, create one
		if ( !unlock ) {
			unlock = Data.uid++;

			// Secure it in a non-enumerable, non-writable property
			try {
				descriptor[ this.expando ] = { value: unlock };
				Object.defineProperties( owner, descriptor );

			// Support: Android<4
			// Fallback to a less secure definition
			} catch ( e ) {
				descriptor[ this.expando ] = unlock;
				jQuery.extend( owner, descriptor );
			}
		}

		// Ensure the cache object
		if ( !this.cache[ unlock ] ) {
			this.cache[ unlock ] = {};
		}

		return unlock;
	},
	set: function( owner, data, value ) {
		var prop,
			// There may be an unlock assigned to this node,
			// if there is no entry for this "owner", create one inline
			// and set the unlock as though an owner entry had always existed
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		// Handle: [ owner, key, value ] args
		if ( typeof data === "string" ) {
			cache[ data ] = value;

		// Handle: [ owner, { properties } ] args
		} else {
			// Fresh assignments by object are shallow copied
			if ( jQuery.isEmptyObject( cache ) ) {
				jQuery.extend( this.cache[ unlock ], data );
			// Otherwise, copy the properties one-by-one to the cache object
			} else {
				for ( prop in data ) {
					cache[ prop ] = data[ prop ];
				}
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		// Either a valid cache is found, or will be created.
		// New caches will be created and the unlock returned,
		// allowing direct access to the newly created
		// empty data object. A valid owner object must be provided.
		var cache = this.cache[ this.key( owner ) ];

		return key === undefined ?
			cache : cache[ key ];
	},
	access: function( owner, key, value ) {
		var stored;
		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				((key && typeof key === "string") && value === undefined) ) {

			stored = this.get( owner, key );

			return stored !== undefined ?
				stored : this.get( owner, jQuery.camelCase(key) );
		}

		// [*]When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i, name, camel,
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		if ( key === undefined ) {
			this.cache[ unlock ] = {};

		} else {
			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = key.concat( key.map( jQuery.camelCase ) );
			} else {
				camel = jQuery.camelCase( key );
				// Try the string as a key before any manipulation
				if ( key in cache ) {
					name = [ key, camel ];
				} else {
					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					name = camel;
					name = name in cache ?
						[ name ] : ( name.match( rnotwhite ) || [] );
				}
			}

			i = name.length;
			while ( i-- ) {
				delete cache[ name[ i ] ];
			}
		}
	},
	hasData: function( owner ) {
		return !jQuery.isEmptyObject(
			this.cache[ owner[ this.expando ] ] || {}
		);
	},
	discard: function( owner ) {
		if ( owner[ this.expando ] ) {
			delete this.cache[ owner[ this.expando ] ];
		}
	}
};
var data_priv = new Data();

var data_user = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			data_user.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend({
	hasData: function( elem ) {
		return data_user.hasData( elem ) || data_priv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return data_user.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		data_user.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to data_priv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return data_priv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		data_priv.remove( elem, name );
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = data_user.get( elem );

				if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice(5) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					data_priv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				data_user.set( this, key );
			});
		}

		return access( this, function( value ) {
			var data,
				camelKey = jQuery.camelCase( key );

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {
				// Attempt to get data from the cache
				// with the key as-is
				data = data_user.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to get data from the cache
				// with the key camelized
				data = data_user.get( elem, camelKey );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, camelKey, undefined );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each(function() {
				// First, attempt to store a copy or reference of any
				// data that might've been store with a camelCased key.
				var data = data_user.get( this, camelKey );

				// For HTML5 data-* attribute interop, we have to
				// store property names with dashes in a camelCase form.
				// This might not apply to all properties...*
				data_user.set( this, camelKey, value );

				// *... In the case of properties that might _actually_
				// have dashes, we need to also store a copy of that
				// unchanged property.
				if ( key.indexOf("-") !== -1 && data !== undefined ) {
					data_user.set( this, key, value );
				}
			});
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each(function() {
			data_user.remove( this, key );
		});
	}
});


jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = data_priv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = data_priv.access( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return data_priv.get( elem, key ) || data_priv.access( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				data_priv.remove( elem, [ type + "queue", key ] );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = data_priv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {
		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
	};

var rcheckableType = (/^(?:checkbox|radio)$/i);



(function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Safari<=5.1
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Safari<=5.1, Android<4.2
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<=11+
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
})();
var strundefined = typeof undefined;



support.focusinBubbles = "onfocusin" in window;


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.hasData( elem ) && data_priv.get( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;
			data_priv.remove( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
				jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, j, ret, matched, handleObj,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.disabled !== true || event.type !== "click" ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: Cordova 2.5 (WebKit) (#13255)
		// All events should have a target; Cordova deviceready doesn't
		if ( !event.target ) {
			event.target = document;
		}

		// Support: Safari 6.0+, Chrome<28
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle, false );
	}
};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&
				// Support: Android<4.0
				src.returnValue === false ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && e.preventDefault ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && e.stopPropagation ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && e.stopImmediatePropagation ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// Support: Chrome 15+
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// Support: Firefox, Chrome, Safari
// Create "bubbling" focus and blur events
if ( !support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					data_priv.remove( doc, fix );

				} else {
					data_priv.access( doc, fix, attaches );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});


var
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	// We have to close these tags to support XHTML (#13200)
	wrapMap = {

		// Support: IE9
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

// Support: IE9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: 1.x compatibility
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName("tbody")[0] ||
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute("type");
	}

	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		data_priv.set(
			elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
		);
	}
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( data_priv.hasData( src ) ) {
		pdataOld = data_priv.access( src );
		pdataCur = data_priv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( data_user.hasData( src ) ) {
		udataOld = data_user.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		data_user.set( dest, udataCur );
	}
}

function getAll( context, tag ) {
	var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
			context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
			[];

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], ret ) :
		ret;
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
					// Support: QtWebKit, PhantomJS
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement("div") );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: QtWebKit, PhantomJS
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			// #4087 - If origin and destination elements are the same, and this is
			// that element, do not do anything
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	},

	cleanData: function( elems ) {
		var data, elem, type, key,
			special = jQuery.event.special,
			i = 0;

		for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
			if ( jQuery.acceptData( elem ) ) {
				key = elem[ data_priv.expando ];

				if ( key && (data = data_priv.cache[ key ]) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}
					if ( data_priv.cache[ key ] ) {
						// Discard any remaining `private` data
						delete data_priv.cache[ key ];
					}
				}
			}
			// Discard any remaining `user` data
			delete data_user.cache[ elem[ data_user.expando ] ];
		}
	}
});

jQuery.fn.extend({
	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each(function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				});
		}, null, value, arguments.length );
	},

	append: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	remove: function( selector, keepData /* Internal Use Only */ ) {
		var elem,
			elems = selector ? jQuery.filter( selector, this ) : this,
			i = 0;

		for ( ; (elem = elems[i]) != null; i++ ) {
			if ( !keepData && elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem ) );
			}

			if ( elem.parentNode ) {
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, "script" ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map(function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var arg = arguments[ 0 ];

		// Make the changes, replacing each context element with the new content
		this.domManip( arguments, function( elem ) {
			arg = this.parentNode;

			jQuery.cleanData( getAll( this ) );

			if ( arg ) {
				arg.replaceChild( elem, this );
			}
		});

		// Force removal if there was no new content (e.g., from empty arguments)
		return arg && (arg.length || arg.nodeType) ? this : this.remove();
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, callback ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				self.domManip( args, callback );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							// Support: QtWebKit
							// jQuery.merge because push.apply(_, arraylike) throws
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( this[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
							}
						}
					}
				}
			}
		}

		return this;
	}
});

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: QtWebKit
			// .get() because push.apply(_, arraylike) throws
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});


var iframe,
	elemdisplay = {};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var style,
		elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		// getDefaultComputedStyle might be reliably used only on attached element
		display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

			// Use of this method is a temporary fix (more like optimization) until something better comes along,
			// since it was removed from specification and supported only in FF
			style.display : jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = iframe[ 0 ].contentDocument;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}
var rmargin = (/^margin/);

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {
		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		if ( elem.ownerDocument.defaultView.opener ) {
			return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
		}

		return window.getComputedStyle( elem, null );
	};



function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );

	// Support: IE9
	// getPropertyValue is only needed for .css('filter') (#12537)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];
	}

	if ( computed ) {

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// Support: iOS < 6
		// A tribute to the "awesome hack by Dean Edwards"
		// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
		// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
		if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?
		// Support: IE
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {
	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {
				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return (this.get = hookFn).apply( this, arguments );
		}
	};
}


(function() {
	var pixelPositionVal, boxSizingReliableVal,
		docElem = document.documentElement,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	if ( !div.style ) {
		return;
	}

	// Support: IE9-11+
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
		"position:absolute";
	container.appendChild( div );

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computePixelPositionAndBoxSizingReliable() {
		div.style.cssText =
			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
			"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
			"border:1px;padding:1px;width:4px;position:absolute";
		div.innerHTML = "";
		docElem.appendChild( container );

		var divStyle = window.getComputedStyle( div, null );
		pixelPositionVal = divStyle.top !== "1%";
		boxSizingReliableVal = divStyle.width === "4px";

		docElem.removeChild( container );
	}

	// Support: node.js jsdom
	// Don't assume that getComputedStyle is a property of the global object
	if ( window.getComputedStyle ) {
		jQuery.extend( support, {
			pixelPosition: function() {

				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computePixelPositionAndBoxSizingReliable();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				if ( boxSizingReliableVal == null ) {
					computePixelPositionAndBoxSizingReliable();
				}
				return boxSizingReliableVal;
			},
			reliableMarginRight: function() {

				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
					marginDiv = div.appendChild( document.createElement( "div" ) );

				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =
					// Support: Firefox<29, Android 2.3
					// Vendor-prefix box-sizing
					"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
					"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				docElem.appendChild( container );

				ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );

				docElem.removeChild( container );
				div.removeChild( marginDiv );

				return ret;
			}
		});
	}
})();


// A method for quickly swapping in/out CSS properties to get correct calculations.
jQuery.swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var
	// Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[0].toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = data_priv.get( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
			}
		} else {
			hidden = isHidden( elem );

			if ( display !== "none" || !hidden ) {
				data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.extend({

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Support: IE9-11+
			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
				style[ name ] = value;
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	}
});

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

// Support: Android 2.3
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			return jQuery.swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});

jQuery.fn.extend({
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE9
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	}
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value ),
				target = tween.cur(),
				parts = rfxnum.exec( value ),
				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				// Starting value computation is required for potential unit mismatches
				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
				scale = 1,
				maxIterations = 20;

			if ( start && start[ 3 ] !== unit ) {
				// Trust units reported by jQuery.css
				unit = unit || start[ 3 ];

				// Make sure we update the tween properties later on
				parts = parts || [];

				// Iteratively approximate from a nonzero starting point
				start = +target || 1;

				do {
					// If previous iteration zeroed out, double until we get *something*.
					// Use string for doubling so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					start = start / scale;
					jQuery.style( tween.elem, prop, start + unit );

				// Update scale, tolerating zero or NaN from tween.cur(),
				// break the loop if scale is unchanged or perfect, or if we've just had enough
				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
			}

			// Update tween properties
			if ( parts ) {
				start = tween.start = +start || +target || 0;
				tween.unit = unit;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[ 1 ] ?
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
					+parts[ 2 ];
			}

			return tween;
		} ]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = data_priv.get( elem, "fxshow" );

	// Handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// Ensure the complete handler is called before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// Height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE9-10 do not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );

		// Test default display if display is currently "none"
		checkDisplay = display === "none" ?
			data_priv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
			style.display = "inline-block";
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always(function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		});
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

		// Any non-fx value stops us from restoring the original display value
		} else {
			display = undefined;
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = data_priv.access( elem, "fxshow", {} );
		}

		// Store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;

			data_priv.remove( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}

	// If this is a noop like .hide().hide(), restore an overwritten display value
	} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
		style.display = display;
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// Don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// Support: Android 2.3
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || data_priv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = data_priv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = data_priv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		});
	}
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = setTimeout( next, time );
		hooks.stop = function() {
			clearTimeout( timeout );
		};
	});
};


(function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: iOS<=5.1, Android<=4.2+
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE<=11+
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: Android<=2.3
	// Options inside disabled selects are incorrectly marked as disabled
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE<=11+
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
})();


var nodeHook, boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend({
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	}
});

jQuery.extend({
	attr: function( elem, name, value ) {
		var hooks, ret,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {
			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {
					// Set corresponding property to false
					elem[ propName ] = false;
				}

				elem.removeAttribute( name );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	}
});

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle;
		if ( !isXML ) {
			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ name ];
			attrHandle[ name ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				name.toLowerCase() :
				null;
			attrHandle[ name ] = handle;
		}
		return ret;
	};
});




var rfocusable = /^(?:input|select|textarea|button)$/i;

jQuery.fn.extend({
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each(function() {
			delete this[ jQuery.propFix[ name ] || name ];
		});
	}
});

jQuery.extend({
	propFix: {
		"for": "htmlFor",
		"class": "className"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
				ret :
				( elem[ name ] = value );

		} else {
			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
				ret :
				elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
					elem.tabIndex :
					-1;
			}
		}
	}
});

if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		}
	};
}

jQuery.each([
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
});




var rclass = /[\t\r\n\f]/g;

jQuery.fn.extend({
	addClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			// The disjunction here is for better compressibility (see removeClass)
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = arguments.length === 0 || typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = value ? jQuery.trim( cur ) : "";
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// Toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					classNames = value.match( rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( type === strundefined || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					data_priv.set( this, "__className__", this.className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	}
});




var rreturn = /\r/g;

jQuery.fn.extend({
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// Handle most common string cases
					ret.replace(rreturn, "") :
					// Handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :
					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					jQuery.trim( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// IE6-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {
						optionSet = true;
					}
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
});

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute("value") === null ? "on" : elem.value;
		};
	}
});




// Return jQuery for attributes-only inclusion


jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.extend({
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	}
});


var nonce = jQuery.now();

var rquery = (/\?/);



// Support: Android 2.3
// Workaround failure to string-cast null input
jQuery.parseJSON = function( data ) {
	return JSON.parse( data + "" );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, tmp;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE9
	try {
		tmp = new DOMParser();
		xml = tmp.parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Document location
	ajaxLocation = window.location.href,

	// Segment location into parts
	ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			while ( (dataType = dataTypes[i++]) ) {
				// Prepend if requested
				if ( dataType[0] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				// Otherwise append
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

		// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s[ "throws" ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,
			// URL without anti-cache param
			cacheURL,
			// Response headers
			responseHeadersString,
			responseHeaders,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
			.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});


jQuery._evalUrl = function( url ) {
	return jQuery.ajax({
		url: url,
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	});
};


jQuery.fn.extend({
	wrapAll: function( html ) {
		var wrap;

		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapAll( html.call(this, i) );
			});
		}

		if ( this[ 0 ] ) {

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	}
});


jQuery.expr.filters.hidden = function( elem ) {
	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
};
jQuery.expr.filters.visible = function( elem ) {
	return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function() {
			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		})
		.map(function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});


jQuery.ajaxSettings.xhr = function() {
	try {
		return new XMLHttpRequest();
	} catch( e ) {}
};

var xhrId = 0,
	xhrCallbacks = {},
	xhrSuccessStatus = {
		// file protocol always yields status code 0, assume 200
		0: 200,
		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE9
// Open requests must be manually aborted on unload (#5280)
// See https://support.microsoft.com/kb/2856746 for more info
if ( window.attachEvent ) {
	window.attachEvent( "onunload", function() {
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]();
		}
	});
}

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport(function( options ) {
	var callback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr(),
					id = ++xhrId;

				xhr.open( options.type, options.url, options.async, options.username, options.password );

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers["X-Requested-With"] ) {
					headers["X-Requested-With"] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							delete xhrCallbacks[ id ];
							callback = xhr.onload = xhr.onerror = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {
								complete(
									// file: protocol always yields status 0; see #8605, #14207
									xhr.status,
									xhr.statusText
								);
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,
									// Support: IE9
									// Accessing binary-data responseText throws an exception
									// (#11426)
									typeof xhr.responseText === "string" ? {
										text: xhr.responseText
									} : undefined,
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				xhr.onerror = callback("error");

				// Create the abort callback
				callback = xhrCallbacks[ id ] = callback("abort");

				try {
					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {
					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {
	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery("<script>").prop({
					async: true,
					charset: s.scriptCharset,
					src: s.url
				}).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[1] ) ];
	}

	parsed = jQuery.buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, type, response,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = jQuery.trim( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			// if "type" variable is undefined, then "GET" method will be used
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
});




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep(jQuery.timers, function( fn ) {
		return elem === fn.elem;
	}).length;
};




var docElem = window.document.documentElement;

/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf("auto") > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend({
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each(function( i ) {
					jQuery.offset.setOffset( this, options, i );
				});
		}

		var docElem, win,
			elem = this[ 0 ],
			box = { top: 0, left: 0 },
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		// Support: BlackBerry 5, iOS 3 (original iPhone)
		// If we don't have gBCR, just use 0,0 rather than error
		if ( typeof elem.getBoundingClientRect !== strundefined ) {
			box = elem.getBoundingClientRect();
		}
		win = getWindow( doc );
		return {
			top: box.top + win.pageYOffset - docElem.clientTop,
			left: box.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {
			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || docElem;

			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || docElem;
		});
	}
});

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : window.pageXOffset,
					top ? val : window.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

// Support: Safari<7+, Chrome<37+
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );
				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});


// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	});
}




var
	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === strundefined ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;

}));

},{}],37:[function(require,module,exports){
/**
 * This module contains two response handlers.
 *
 * First, a generic BBOP handler for dealing with the gross parsing of
 * responses from a REST server. This is just an example pass-thru
 * handler that needs to be overridden (see subclasses).
 * 
 * Second, a generic BBOP handler for dealing with the gross parsing
 * of responses from a REST JSON server. It will detect if the
 * incoming response is a string, and if so, try to parse it to
 * JSON. Otherwise, if the raw return is already an Object, we assume
 * that somebody got to it before us (e.g. jQuery's handling).
 *
 * A little more discussion of the base class.
 *
 * You may note that things like status and status codes are not part
 * of the base response. The reason is is that not all methods of REST
 * in the environments that we use support them. For example: readURL
 * in rhino. For this reason, the "health" of the response is left to
 * the simple okay() function--just enought to be able to choose
 * between "success" and "failure" in the managers. To give a bit more
 * information in case of early error, there is message and
 * message_type.
 * 
 * Similarly, there are no toeholds in the returned data except
 * raw(). All data views and operations are implemented in the
 * subclasses.
 *
 * This module includes the following objects:
 *  - base: essentially uninteresting base class
 *  - json: json parsing attmpted
 *
 * @module bbop-rest-response
 */

var bbop = require('bbop-core');
var us = require('underscore');

/**
 * Contructor for a REST query response object.
 * 
 * The constructor argument is an object, not a string.
 * 
 * @constructor
 * @param {String} in_data - the string returned from a request
 * @returns {Object} rest response object
 */
var response = function(in_data){
    this._is_a = 'bbop-rest-response';

    // The raw incoming document.
    this._raw = in_data;

    // Cache for repeated calls to okay().
    this._okay = null;
    this._message = null;
    this._message_type = null;
};

/**
 * Returns the initial response object, whatever it was.
 * 
 * @returns {Object} object
 */
response.prototype.raw = function(){
    return this._raw;
};

/**
 * Simple return verification of sane response from server.
 * 
 * This okay() caches its return value, so harder probes don't need to
 * be performed more than once.
 * 
 * @param {Boolean} [okay_p] - setter for okay
 * @returns {Boolean}
 */
response.prototype.okay = function(okay_p){

    // Optionally set from the outside.
    if( bbop.is_defined(okay_p) ){
	this._okay = okay_p;
    }

    //print('a: ' + this._okay);
    if( this._okay == null ){ // only go if answer not cached
	//print('b: ' + this._raw);
	if( ! this._raw || this._raw === '' ){
	    //print('c: if');
	    this._okay = false;
	}else{
	    //print('c: else');
	    this._okay = true;
	}
    }
    
    return this._okay;
};

/**
 * A message that the response wants to let you know about its
 * creation.
 * 
 * @param {String} [message] - setter for message
 * @returns {String} message string
 */
response.prototype.message = function(message){
    if( bbop.is_defined(message) ){
	this._message = message;
    }
    return this._message;
};

/**
 * A message about the message (a string classifier) that the response
 * wants to let you know about its message.
 * 
 * @param {String} [message_type] - setter for message_type
 * @returns {String} message type string
 */
response.prototype.message_type = function(message_type){
    if( bbop.is_defined(message_type) ){
	this._message_type = message_type;
    }
    return this._message_type;
};

///
///
///

/**
 * Contructor for a REST JSON response object.
 * 
 * The constructor argument is an object or a string.
 * 
 * @constructor
 * @param {Object|String} json_data - the JSON object as a string (as returned from a request)
 * @returns {response_json} rest response object
 */
var response_json = function(json_data){
    response.call(this);
    this._is_a = 'bbop-rest-response-json';

    // The raw incoming document.
    //this._raw_string = json_data_str;
    this._raw_string = null;
    this._okay = null;

    if( json_data ){

	if( bbop.what_is(json_data) === 'string' ){

	    // Try and parse out strings.
	    try {
		this._raw = JSON.parse(json_data);
		this._okay = true;
	    }catch(e){
		// Didn't make it, but still a string.
		this._raw = json_data;
		this._okay = false;
	    }

	}else if( bbop.what_is(json_data) === 'object' ||
		  bbop.what_is(json_data) === 'array' ){

	    // Looks like somebody else got here first.
	    this._raw = json_data;
	    this._okay = true;
	    
	}else{

	    // No idea what this thing is...
	    this._raw = null;
	    this._okay = null;
	}
    }
};
bbop.extend(response_json, response);

///
/// Exportable body.
///

module.exports = {

    'base': response,
    'json': response_json

};

},{"bbop-core":38,"underscore":108}],38:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"underscore":108}],39:[function(require,module,exports){

},{}],40:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}],41:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"base64-js":25,"buffer":41,"ieee754":67}],42:[function(require,module,exports){
module.exports = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Unordered Collection",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
}

},{}],43:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');

var callBind = require('./');

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};

},{"./":44,"get-intrinsic":56}],44:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var GetIntrinsic = require('get-intrinsic');
var setFunctionLength = require('set-function-length');

var $TypeError = require('es-errors/type');
var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $defineProperty = require('es-define-property');
var $max = GetIntrinsic('%Math.max%');

module.exports = function callBind(originalFunction) {
	if (typeof originalFunction !== 'function') {
		throw new $TypeError('a function is required');
	}
	var func = $reflectApply(bind, $call, arguments);
	return setFunctionLength(
		func,
		1 + $max(0, originalFunction.length - (arguments.length - 1)),
		true
	);
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}

},{"es-define-property":46,"es-errors/type":52,"function-bind":55,"get-intrinsic":56,"set-function-length":78}],45:[function(require,module,exports){
'use strict';

var $defineProperty = require('es-define-property');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var gopd = require('gopd');

/** @type {import('.')} */
module.exports = function defineDataProperty(
	obj,
	property,
	value
) {
	if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
		throw new $TypeError('`obj` must be an object or a function`');
	}
	if (typeof property !== 'string' && typeof property !== 'symbol') {
		throw new $TypeError('`property` must be a string or a symbol`');
	}
	if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
		throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
		throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
		throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
		throw new $TypeError('`loose`, if provided, must be a boolean');
	}

	var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
	var nonWritable = arguments.length > 4 ? arguments[4] : null;
	var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
	var loose = arguments.length > 6 ? arguments[6] : false;

	/* @type {false | TypedPropertyDescriptor<unknown>} */
	var desc = !!gopd && gopd(obj, property);

	if ($defineProperty) {
		$defineProperty(obj, property, {
			configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
			enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
			value: value,
			writable: nonWritable === null && desc ? desc.writable : !nonWritable
		});
	} else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {
		// must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
		obj[property] = value; // eslint-disable-line no-param-reassign
	} else {
		throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
	}
};

},{"es-define-property":46,"es-errors/syntax":51,"es-errors/type":52,"gopd":59}],46:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');

/** @type {import('.')} */
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true) || false;
if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = false;
	}
}

module.exports = $defineProperty;

},{"get-intrinsic":56}],47:[function(require,module,exports){
'use strict';

/** @type {import('./eval')} */
module.exports = EvalError;

},{}],48:[function(require,module,exports){
'use strict';

/** @type {import('.')} */
module.exports = Error;

},{}],49:[function(require,module,exports){
'use strict';

/** @type {import('./range')} */
module.exports = RangeError;

},{}],50:[function(require,module,exports){
'use strict';

/** @type {import('./ref')} */
module.exports = ReferenceError;

},{}],51:[function(require,module,exports){
'use strict';

/** @type {import('./syntax')} */
module.exports = SyntaxError;

},{}],52:[function(require,module,exports){
'use strict';

/** @type {import('./type')} */
module.exports = TypeError;

},{}],53:[function(require,module,exports){
'use strict';

/** @type {import('./uri')} */
module.exports = URIError;

},{}],54:[function(require,module,exports){
'use strict';

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';

var concatty = function concatty(a, b) {
    var arr = [];

    for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
    }

    return arr;
};

var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
    }
    return arr;
};

var joiny = function (arr, joiner) {
    var str = '';
    for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                concatty(args, arguments)
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(
            that,
            concatty(args, arguments)
        );

    };

    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = '$' + i;
    }

    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

},{}],55:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;

},{"./implementation":54}],56:[function(require,module,exports){
'use strict';

var undefined;

var $Error = require('es-errors');
var $EvalError = require('es-errors/eval');
var $RangeError = require('es-errors/range');
var $ReferenceError = require('es-errors/ref');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var $URIError = require('es-errors/uri');

var $Function = Function;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = require('has-symbols')();
var hasProto = require('has-proto')();

var getProto = Object.getPrototypeOf || (
	hasProto
		? function (x) { return x.__proto__; } // eslint-disable-line no-proto
		: null
);

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	__proto__: null,
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': $Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': $EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': $RangeError,
	'%ReferenceError%': $ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': $URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	__proto__: null,
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = require('function-bind');
var hasOwn = require('hasown');
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};

},{"es-errors":48,"es-errors/eval":47,"es-errors/range":49,"es-errors/ref":50,"es-errors/syntax":51,"es-errors/type":52,"es-errors/uri":53,"function-bind":55,"has-proto":61,"has-symbols":62,"hasown":64}],57:[function(require,module,exports){
/* 
 * Package: conf.js
 * 
 * Generic BBOP manager for dealing with gross GOlr configuration
 * and management.
 * 
 * Contains <bbop.golr.conf_field>, <bbop.golr.conf_class>, and
 * <bbop.golr.conf>.
 * 
 * TODO: better document all of this. Essentially, this is all for
 * getting data out of a JSONized version of the YAML files used to
 * drive the OWLTools-Solr parts of GOlr.
 */

var bbop = require('bbop-core');
var us = require('underscore');

// Aliasing.
var bbop_logger = bbop.logger;
var each = us.each;

/*
 * Constructor: conf_field
 * 
 * Contructor for a GOlr search field.
 * 
 * Arguments:
 *  field_conf_struct - JSONized config
 * 
 * Returns:
 *  conf_field object
 */
var conf_field = function (field_conf_struct){
    this._is_a = 'golr-conf.conf_field';

    // Get a good self-reference point.
    var anchor = this;

    // Per-manager logger.
    var logger = new bbop_logger(this._is_a);
    logger.DEBUG = true;
    function ll(str){ logger.kvetch(str); }

    // Capture search fields.
    this._field = field_conf_struct;

    /*
     * Function: display_name
     * 
     * The user-facing display name. Suitable for label or title
     * somewhere.
     * 
     * Returns:
     *  Display name string.
     */
    this.display_name = function(){
	return this._field['display_name'];
    };

    /*
     * Function: description
     * 
     * A longer description. Suitable for tooltips.
     * 
     * Returns:
     *  Description string.
     */
    this.description = function(){
	return this._field['description'];
    };

    /*
     * Function: id
     * 
     * The unique ID of this profile.
     * 
     * Returns:
     *  String.
     */
    this.id = function(){
	return this._field['id'];
    };

    /*
     * Function: searchable
     * 
     * Returns whether or not a string field has a shadow
     * "*_searchable" field defined that is suitable for dismax
     * searches. Defaults to false.
     * 
     * Returns:
     *  boolean
     */
    this.searchable = function(){
	var retval = false;
	if( this._field['searchable'] === 'true' ||
	    this._field['searchable'] === true ){
		retval = true;	
	    }
	return retval;
    };

    /*
     * Function: required
     * 
     * Returns whether or not this field is required. Defaults to
     * false.
     * 
     * Not of particular use.
     * 
     * Returns:
     *  Boolean.
     */
    this.required = function(){
	var retval = false;
	if( this._field['required'] === 'true' ||
	    this._field['required'] === true ){
		retval = true;	
	    }
	return retval;
    };

    /*
     * Function: is_multi
     * 
     * Using the "cardinality" entry, returns whether or not this
     * field is "single" (false) or "multi" (true). Defaults to false.
     * 
     * Returns:
     *  Boolean.
     */
    this.is_multi = function(){
	var retval = false;
	if( this._field['cardinality'] === 'multi' ){
	    retval = true;	
	}
	return retval;
    };

    /*
     * Function: is_fixed
     * 
     * Using the "property_type" entry, returns whether or not this
     * field is "dynamic" (false) or "fixed" (true). Defaults to false.
     * 
     * Not of particular use.
     * 
     * Returns:
     *  Boolean.
     */
    this.is_fixed = function(){
	var retval = false;
	if( this._field['property_type'] === 'fixed' ){
	    retval = true;	
	}
	return retval;
    };

    /*
     * Function: property
     * 
     * Returns the method of this field's generation in the loader.
     * 
     * Not of particular use.
     * 
     * Returns:
     *  String.
     */
    this.property = function(){
	var retval = '???';
	if( this._field['property'] ){
	    retval = this._field['property'];
	}
	return retval;
    };

    // TODO: ...
};

/*
 * Namespace: bbop.golr.conf_class
 *
 * Constructor: conf_class
 * 
 * Contructor for a GOlr search class.
 * 
 * Arguments:
 *  class_conf_struct - JSONized config
 * 
 * Returns:
 *  conf_class object
 */
var conf_class = function (class_conf_struct){
    this._is_a = 'golr-conf.conf_class';

    // Get a good self-reference point.
    var anchor = this;

    // Per-manager logger.
    var logger = new bbop_logger(this._is_a);
    logger.DEBUG = true;
    function ll(str){ logger.kvetch(str); }

    // Capture class and the component fields into variables.
    this._class = class_conf_struct;
    // this._fields = {};
    // bbop.core.each(this._class['fields'],
    // 		   function(item, index){
    // 		       var sf = new bbop.golr.conf_field(item);
    // 		       anchor._fields[sf.id()] = sf;
    // 		  });

    /*
     * Function: display_name
     * 
     * The user-facing display name. Suitable for label or title
     * somewhere.
     * 
     * Returns:
     *  Display name string.
     */
    this.display_name = function(){
	return this._class['display_name'];
    };

    /*
     * Function: description
     * 
     * A longer description. Suitable for tooltips.
     * 
     * Returns:
     *  Description string.
     */
    this.description = function(){
	return this._class['description'];
    };

    /*
     * Function: weight
     * 
     * The relative weight of this search class.
     * 
     * Returns:
     *  Integer.
     */
    this.weight = function(){
    	return parseInt(this._class['weight']) || 0;
    };

    /*
     * Function: id
     * 
     * The unique ID of this profile.
     * 
     * Returns:
     *  String.
     */
    this.id = function(){
	return this._class['id'];
    };

    /*
     * Function: document_category
     * 
     * The document category that this personality is meant to work
     * with. Otherwise, returns the class id.
     * 
     * Returns:
     *  String.
     */
    this.document_category = function(){
	return this._class['document_category'] || this.id();
    };

    /*
     * Function: searchable_extension
     * 
     * This returns the searchable extension used for this
     * class. There is a typical default, but it might be change in
     * namespace collisions, so it's better to just use this.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     * string
     */
    this.searchable_extension = function(){
    	//return this._class['searchable_extension'] || '_searchable';
    	return '_searchable';
    };

    /*
     * Function: get_field
     * 
     * Returns a search field by id string. Null otherwise.
     * 
     * Parameters:
     *  fid - a string id for the field
     * 
     * Returns:
     *  <bbop.golr.conf_field>
     */
    this.get_field = function(fid){
	var retval = null;
	if( this._class.fields_hash &&
	    this._class.fields_hash[fid] ){
		retval = new conf_field(this._class.fields_hash[fid]);
	    }
	return retval;
    };

    /*
     * Function: get_fields
     * 
     * Return all of the fields in this search class.
     * 
     * Returns:
     *  Array of <bbop.golr.conf_field> (unordered).
     */
    this.get_fields = function(){
	var retval = [];
	if( this._class.fields_hash ){
	    each(this._class.fields_hash, function(struct, fid){
		var cf = new conf_field(struct);
		retval.push(cf);
	    });
	}
	return retval;
    };

    // Internal function to determine if the weight category that's
    // used by several functions is okay.
    this._munge_weight_category = function(weight_category){

	// Not defined or only the defined few.
	if( ! weight_category ){
	    throw new Error("Missing weight category");	
	}else if( weight_category !== 'boost' &&
	    weight_category !== 'result' &&
	    weight_category !== 'filter' ){
	    throw new Error("Unknown weight category: " + weight_category);
	}

	return weight_category + '_weights';
    };

    /*
     * Function: get_weights
     * 
     * Get the various weights we need to run.
     * 
     * The weight category can be 'boost', 'result', or 'filter'.
     * 
     * Arguments:
     *  weight_category - string identifying the legal weight category
     * 
     * Returns:
     *  object of {field => weight, ...}
     */
    this.get_weights = function(weight_category){
	
	var rethash = {};

	// Only the defined few.
	weight_category = this._munge_weight_category(weight_category);

	// Collect the good bits.
	if( typeof(this._class[weight_category]) === 'undefined' ){
	    throw new Error("Missing weight category: " + weight_category);
	}else{
	    // Only work it if there is something there more than "".
	    var wcs = this._class[weight_category];
	    if( wcs && wcs !== "" && wcs !== " " ){
		var dfab = wcs;
		var fields = dfab.split(/\s+/);
		each(fields, function(item, i){
		    var field_val = item.split(/\^/);
		    rethash[field_val[0]] =
			parseFloat(field_val[1]);
		});
	    }
	}

	return rethash;
    };

    /*
     * Function: field_order_by_weight
     * 
     * Returns an array of field ids ordered by weight.
     * 
     * The weight category can be 'boost', 'result', or 'filter'.
     * 
     * Arguments:
     * weight_category - string identifying the legal weight category
     * cutoff - *[optional]* if not defined, all listed fields in set returned
     * 
     * Returns:
     *  array like [field5, field4, ...]
     */
    this.field_order_by_weight = function(weight_category, cutoff){

    	var retset = [];

	var weights = this.get_weights(weight_category);

	// Add the ones that meet threshold (if there is one) to the
	// set.
	each(weights, function(val, key){
	    if( cutoff ){
		if( val >= cutoff ){
		    retset.push(key);			       
		}
	    }else{
		retset.push(key);			       
	    }
	});
	
	// Order the set.
	retset.sort(function(a, b){
			return weights[b] - weights[a];
		    });

    	return retset;
    };
};

/*
 * Namespace: bbop.golr.conf
 *
 * Constructor: conf
 * 
 * Contructor for the GOlr query manager.
 * Why don't we just take bbop.golr.golr_meta as read? We want to
 * leave the door open to having multiple GOlrs running in the same area.
 * 
 * Arguments:
 *  golr_conf_var - JSized GOlr config
 * 
 * Returns:
 *  golr conf object
 * 
 */
var conf = function (golr_conf_var){
    this._is_a = 'golr-conf.conf';

    // Get a good self-reference point.
    var anchor = this;

    // Per-manager logger.
    var logger = new bbop_logger(this._is_a);
    logger.DEBUG = true;
    function ll(str){ logger.kvetch(str); }

    // Lightly check incoming arguments.
    // There could be a hash of pinned filters argument.
    if( ! golr_conf_var || typeof golr_conf_var !== 'object' ){
	ll('ERROR: no proper golr conf var argument');
    }
    
    // Settle in the conf.
    this._golr_conf = golr_conf_var;

    // Process the conf classes into one spot.
    this._classes = {};
    each(anchor._golr_conf, function(val, key){
	var new_asp = new conf_class(val);
	anchor._classes[new_asp.id()] = new_asp;
    });

    /*
     * Function: get_class
     * 
     * Returns a class info object by id string. Null otherwise.
     * 
     * Arguments:
     *  fid - TODO
     * 
     * Returns:
     *  bbop.golr.conf_class.
     */
    this.get_class = function(fid){
	var retval = null;
	if( this._classes && this._classes[fid] ){
	    retval = this._classes[fid];
	}
	return retval;
    };

    /*
     * Function: get_classes
     * 
     * Returns an array of all search classes.
     * 
     * Returns:
     *  Array of <bbop.golr.conf_class> (unordered).
     */
    this.get_classes = function(){
	var ret = [];
	each(anchor._classes, function(val, key){
	    ret.push(val);
	});
	return ret;
    };

    /*
     * Function: get_classes_by_weight
     * 
     * Returns an array of all search classes. Ordered by weight.
     * 
     * Returns:
     *  Array of <bbop.golr.conf_class>.
     */
    this.get_classes_by_weight = function(){
	var ret = this.get_classes();

	ret.sort(
	    function(cc1, cc2){
		var w1 = cc1.weight() || 0;
		var w2 = cc2.weight() || 0;
		return w2 - w1;
	    });

	return ret;
    };
};

///
/// Exportable body.
///

module.exports = {};
module.exports['conf_field'] = conf_field;
module.exports['conf_class'] = conf_class;
module.exports['conf'] = conf;

},{"bbop-core":58,"underscore":108}],58:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"underscore":108}],59:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;

},{"get-intrinsic":56}],60:[function(require,module,exports){
'use strict';

var $defineProperty = require('es-define-property');

var hasPropertyDescriptors = function hasPropertyDescriptors() {
	return !!$defineProperty;
};

hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
	// node v0.6 has a bug where array lengths can be Set but not Defined
	if (!$defineProperty) {
		return null;
	}
	try {
		return $defineProperty([], 'length', { value: 1 }).length !== 1;
	} catch (e) {
		// In Firefox 4-22, defining length on an array throws an exception.
		return true;
	}
};

module.exports = hasPropertyDescriptors;

},{"es-define-property":46}],61:[function(require,module,exports){
'use strict';

var test = {
	__proto__: null,
	foo: {}
};

var $Object = Object;

/** @type {import('.')} */
module.exports = function hasProto() {
	// @ts-expect-error: TS errors on an inherited property for some reason
	return { __proto__: test }.foo === test.foo
		&& !(test instanceof $Object);
};

},{}],62:[function(require,module,exports){
'use strict';

var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = require('./shams');

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};

},{"./shams":63}],63:[function(require,module,exports){
'use strict';

/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};

},{}],64:[function(require,module,exports){
'use strict';

var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = require('function-bind');

/** @type {import('.')} */
module.exports = bind.call(call, $hasOwn);

},{"function-bind":55}],65:[function(require,module,exports){
'use strict';

module.exports = Response;

/**
 * A response from a web request
 *
 * @param {Number} statusCode
 * @param {Object} headers
 * @param {Buffer} body
 * @param {String} url
 */
function Response(statusCode, headers, body, url) {
  if (typeof statusCode !== 'number') {
    throw new TypeError('statusCode must be a number but was ' + (typeof statusCode));
  }
  if (headers === null) {
    throw new TypeError('headers cannot be null');
  }
  if (typeof headers !== 'object') {
    throw new TypeError('headers must be an object but was ' + (typeof headers));
  }
  this.statusCode = statusCode;
  this.headers = {};
  for (var key in headers) {
    this.headers[key.toLowerCase()] = headers[key];
  }
  this.body = body;
  this.url = url;
}

Response.prototype.getBody = function (encoding) {
  if (this.statusCode >= 300) {
    var err = new Error('Server responded with status code '
                    + this.statusCode + ':\n' + this.body.toString());
    err.statusCode = this.statusCode;
    err.headers = this.headers;
    err.body = this.body;
    err.url = this.url;
    throw err;
  }
  return encoding ? this.body.toString(encoding) : this.body;
};

},{}],66:[function(require,module,exports){
var http = require('http')
var url = require('url')

var https = module.exports

for (var key in http) {
  if (http.hasOwnProperty(key)) https[key] = http[key]
}

https.request = function (params, cb) {
  params = validateParams(params)
  return http.request.call(this, params, cb)
}

https.get = function (params, cb) {
  params = validateParams(params)
  return http.get.call(this, params, cb)
}

function validateParams (params) {
  if (typeof params === 'string') {
    params = url.parse(params)
  }
  if (!params.protocol) {
    params.protocol = 'https:'
  }
  if (params.protocol !== 'https:') {
    throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"')
  }
  return params
}

},{"http":80,"url":114}],67:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],68:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],69:[function(require,module,exports){
/*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */

/*global define: false Mustache: true*/

(function defineMustache (global, factory) {
  if (typeof exports === 'object' && exports && typeof exports.nodeName !== 'string') {
    factory(exports); // CommonJS
  } else if (typeof define === 'function' && define.amd) {
    define(['exports'], factory); // AMD
  } else {
    global.Mustache = {};
    factory(global.Mustache); // script, wsh, asp
  }
}(this, function mustacheFactory (mustache) {

  var objectToString = Object.prototype.toString;
  var isArray = Array.isArray || function isArrayPolyfill (object) {
    return objectToString.call(object) === '[object Array]';
  };

  function isFunction (object) {
    return typeof object === 'function';
  }

  /**
   * More correct typeof string handling array
   * which normally returns typeof 'object'
   */
  function typeStr (obj) {
    return isArray(obj) ? 'array' : typeof obj;
  }

  function escapeRegExp (string) {
    return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
  }

  /**
   * Null safe way of checking whether or not an object,
   * including its prototype, has a given property
   */
  function hasProperty (obj, propName) {
    return obj != null && typeof obj === 'object' && (propName in obj);
  }

  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577
  // See https://github.com/janl/mustache.js/issues/189
  var regExpTest = RegExp.prototype.test;
  function testRegExp (re, string) {
    return regExpTest.call(re, string);
  }

  var nonSpaceRe = /\S/;
  function isWhitespace (string) {
    return !testRegExp(nonSpaceRe, string);
  }

  var entityMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '/': '&#x2F;',
    '`': '&#x60;',
    '=': '&#x3D;'
  };

  function escapeHtml (string) {
    return String(string).replace(/[&<>"'`=\/]/g, function fromEntityMap (s) {
      return entityMap[s];
    });
  }

  var whiteRe = /\s*/;
  var spaceRe = /\s+/;
  var equalsRe = /\s*=/;
  var curlyRe = /\s*\}/;
  var tagRe = /#|\^|\/|>|\{|&|=|!/;

  /**
   * Breaks up the given `template` string into a tree of tokens. If the `tags`
   * argument is given here it must be an array with two string values: the
   * opening and closing tags used in the template (e.g. [ "<%", "%>" ]). Of
   * course, the default is to use mustaches (i.e. mustache.tags).
   *
   * A token is an array with at least 4 elements. The first element is the
   * mustache symbol that was used inside the tag, e.g. "#" or "&". If the tag
   * did not contain a symbol (i.e. {{myValue}}) this element is "name". For
   * all text that appears outside a symbol this element is "text".
   *
   * The second element of a token is its "value". For mustache tags this is
   * whatever else was inside the tag besides the opening symbol. For text tokens
   * this is the text itself.
   *
   * The third and fourth elements of the token are the start and end indices,
   * respectively, of the token in the original template.
   *
   * Tokens that are the root node of a subtree contain two more elements: 1) an
   * array of tokens in the subtree and 2) the index in the original template at
   * which the closing tag for that section begins.
   */
  function parseTemplate (template, tags) {
    if (!template)
      return [];

    var sections = [];     // Stack to hold section tokens
    var tokens = [];       // Buffer to hold the tokens
    var spaces = [];       // Indices of whitespace tokens on the current line
    var hasTag = false;    // Is there a {{tag}} on the current line?
    var nonSpace = false;  // Is there a non-space char on the current line?

    // Strips all whitespace tokens array for the current line
    // if there was a {{#tag}} on it and otherwise only space.
    function stripSpace () {
      if (hasTag && !nonSpace) {
        while (spaces.length)
          delete tokens[spaces.pop()];
      } else {
        spaces = [];
      }

      hasTag = false;
      nonSpace = false;
    }

    var openingTagRe, closingTagRe, closingCurlyRe;
    function compileTags (tagsToCompile) {
      if (typeof tagsToCompile === 'string')
        tagsToCompile = tagsToCompile.split(spaceRe, 2);

      if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)
        throw new Error('Invalid tags: ' + tagsToCompile);

      openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\s*');
      closingTagRe = new RegExp('\\s*' + escapeRegExp(tagsToCompile[1]));
      closingCurlyRe = new RegExp('\\s*' + escapeRegExp('}' + tagsToCompile[1]));
    }

    compileTags(tags || mustache.tags);

    var scanner = new Scanner(template);

    var start, type, value, chr, token, openSection;
    while (!scanner.eos()) {
      start = scanner.pos;

      // Match any text between tags.
      value = scanner.scanUntil(openingTagRe);

      if (value) {
        for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
          chr = value.charAt(i);

          if (isWhitespace(chr)) {
            spaces.push(tokens.length);
          } else {
            nonSpace = true;
          }

          tokens.push([ 'text', chr, start, start + 1 ]);
          start += 1;

          // Check for whitespace on the current line.
          if (chr === '\n')
            stripSpace();
        }
      }

      // Match the opening tag.
      if (!scanner.scan(openingTagRe))
        break;

      hasTag = true;

      // Get the tag type.
      type = scanner.scan(tagRe) || 'name';
      scanner.scan(whiteRe);

      // Get the tag value.
      if (type === '=') {
        value = scanner.scanUntil(equalsRe);
        scanner.scan(equalsRe);
        scanner.scanUntil(closingTagRe);
      } else if (type === '{') {
        value = scanner.scanUntil(closingCurlyRe);
        scanner.scan(curlyRe);
        scanner.scanUntil(closingTagRe);
        type = '&';
      } else {
        value = scanner.scanUntil(closingTagRe);
      }

      // Match the closing tag.
      if (!scanner.scan(closingTagRe))
        throw new Error('Unclosed tag at ' + scanner.pos);

      token = [ type, value, start, scanner.pos ];
      tokens.push(token);

      if (type === '#' || type === '^') {
        sections.push(token);
      } else if (type === '/') {
        // Check section nesting.
        openSection = sections.pop();

        if (!openSection)
          throw new Error('Unopened section "' + value + '" at ' + start);

        if (openSection[1] !== value)
          throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
      } else if (type === 'name' || type === '{' || type === '&') {
        nonSpace = true;
      } else if (type === '=') {
        // Set the tags for the next time around.
        compileTags(value);
      }
    }

    // Make sure there are no open sections when we're done.
    openSection = sections.pop();

    if (openSection)
      throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);

    return nestTokens(squashTokens(tokens));
  }

  /**
   * Combines the values of consecutive text tokens in the given `tokens` array
   * to a single token.
   */
  function squashTokens (tokens) {
    var squashedTokens = [];

    var token, lastToken;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      token = tokens[i];

      if (token) {
        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {
          lastToken[1] += token[1];
          lastToken[3] = token[3];
        } else {
          squashedTokens.push(token);
          lastToken = token;
        }
      }
    }

    return squashedTokens;
  }

  /**
   * Forms the given array of `tokens` into a nested tree structure where
   * tokens that represent a section have two additional items: 1) an array of
   * all tokens that appear in that section and 2) the index in the original
   * template that represents the end of that section.
   */
  function nestTokens (tokens) {
    var nestedTokens = [];
    var collector = nestedTokens;
    var sections = [];

    var token, section;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      token = tokens[i];

      switch (token[0]) {
        case '#':
        case '^':
          collector.push(token);
          sections.push(token);
          collector = token[4] = [];
          break;
        case '/':
          section = sections.pop();
          section[5] = token[2];
          collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
          break;
        default:
          collector.push(token);
      }
    }

    return nestedTokens;
  }

  /**
   * A simple string scanner that is used by the template parser to find
   * tokens in template strings.
   */
  function Scanner (string) {
    this.string = string;
    this.tail = string;
    this.pos = 0;
  }

  /**
   * Returns `true` if the tail is empty (end of string).
   */
  Scanner.prototype.eos = function eos () {
    return this.tail === '';
  };

  /**
   * Tries to match the given regular expression at the current position.
   * Returns the matched text if it can match, the empty string otherwise.
   */
  Scanner.prototype.scan = function scan (re) {
    var match = this.tail.match(re);

    if (!match || match.index !== 0)
      return '';

    var string = match[0];

    this.tail = this.tail.substring(string.length);
    this.pos += string.length;

    return string;
  };

  /**
   * Skips all text until the given regular expression can be matched. Returns
   * the skipped string, which is the entire tail if no match can be made.
   */
  Scanner.prototype.scanUntil = function scanUntil (re) {
    var index = this.tail.search(re), match;

    switch (index) {
      case -1:
        match = this.tail;
        this.tail = '';
        break;
      case 0:
        match = '';
        break;
      default:
        match = this.tail.substring(0, index);
        this.tail = this.tail.substring(index);
    }

    this.pos += match.length;

    return match;
  };

  /**
   * Represents a rendering context by wrapping a view object and
   * maintaining a reference to the parent context.
   */
  function Context (view, parentContext) {
    this.view = view;
    this.cache = { '.': this.view };
    this.parent = parentContext;
  }

  /**
   * Creates a new context using the given view with this context
   * as the parent.
   */
  Context.prototype.push = function push (view) {
    return new Context(view, this);
  };

  /**
   * Returns the value of the given name in this context, traversing
   * up the context hierarchy if the value is absent in this context's view.
   */
  Context.prototype.lookup = function lookup (name) {
    var cache = this.cache;

    var value;
    if (cache.hasOwnProperty(name)) {
      value = cache[name];
    } else {
      var context = this, names, index, lookupHit = false;

      while (context) {
        if (name.indexOf('.') > 0) {
          value = context.view;
          names = name.split('.');
          index = 0;

          /**
           * Using the dot notion path in `name`, we descend through the
           * nested objects.
           *
           * To be certain that the lookup has been successful, we have to
           * check if the last object in the path actually has the property
           * we are looking for. We store the result in `lookupHit`.
           *
           * This is specially necessary for when the value has been set to
           * `undefined` and we want to avoid looking up parent contexts.
           **/
          while (value != null && index < names.length) {
            if (index === names.length - 1)
              lookupHit = hasProperty(value, names[index]);

            value = value[names[index++]];
          }
        } else {
          value = context.view[name];
          lookupHit = hasProperty(context.view, name);
        }

        if (lookupHit)
          break;

        context = context.parent;
      }

      cache[name] = value;
    }

    if (isFunction(value))
      value = value.call(this.view);

    return value;
  };

  /**
   * A Writer knows how to take a stream of tokens and render them to a
   * string, given a context. It also maintains a cache of templates to
   * avoid the need to parse the same template twice.
   */
  function Writer () {
    this.cache = {};
  }

  /**
   * Clears all cached templates in this writer.
   */
  Writer.prototype.clearCache = function clearCache () {
    this.cache = {};
  };

  /**
   * Parses and caches the given `template` and returns the array of tokens
   * that is generated from the parse.
   */
  Writer.prototype.parse = function parse (template, tags) {
    var cache = this.cache;
    var tokens = cache[template];

    if (tokens == null)
      tokens = cache[template] = parseTemplate(template, tags);

    return tokens;
  };

  /**
   * High-level method that is used to render the given `template` with
   * the given `view`.
   *
   * The optional `partials` argument may be an object that contains the
   * names and templates of partials that are used in the template. It may
   * also be a function that is used to load partial templates on the fly
   * that takes a single argument: the name of the partial.
   */
  Writer.prototype.render = function render (template, view, partials) {
    var tokens = this.parse(template);
    var context = (view instanceof Context) ? view : new Context(view);
    return this.renderTokens(tokens, context, partials, template);
  };

  /**
   * Low-level method that renders the given array of `tokens` using
   * the given `context` and `partials`.
   *
   * Note: The `originalTemplate` is only ever used to extract the portion
   * of the original template that was contained in a higher-order section.
   * If the template doesn't use higher-order sections, this argument may
   * be omitted.
   */
  Writer.prototype.renderTokens = function renderTokens (tokens, context, partials, originalTemplate) {
    var buffer = '';

    var token, symbol, value;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      value = undefined;
      token = tokens[i];
      symbol = token[0];

      if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate);
      else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate);
      else if (symbol === '>') value = this.renderPartial(token, context, partials, originalTemplate);
      else if (symbol === '&') value = this.unescapedValue(token, context);
      else if (symbol === 'name') value = this.escapedValue(token, context);
      else if (symbol === 'text') value = this.rawValue(token);

      if (value !== undefined)
        buffer += value;
    }

    return buffer;
  };

  Writer.prototype.renderSection = function renderSection (token, context, partials, originalTemplate) {
    var self = this;
    var buffer = '';
    var value = context.lookup(token[1]);

    // This function is used to render an arbitrary template
    // in the current context by higher-order sections.
    function subRender (template) {
      return self.render(template, context, partials);
    }

    if (!value) return;

    if (isArray(value)) {
      for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
        buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);
      }
    } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {
      buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);
    } else if (isFunction(value)) {
      if (typeof originalTemplate !== 'string')
        throw new Error('Cannot use higher-order sections without the original template');

      // Extract the portion of the original template that the section contains.
      value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);

      if (value != null)
        buffer += value;
    } else {
      buffer += this.renderTokens(token[4], context, partials, originalTemplate);
    }
    return buffer;
  };

  Writer.prototype.renderInverted = function renderInverted (token, context, partials, originalTemplate) {
    var value = context.lookup(token[1]);

    // Use JavaScript's definition of falsy. Include empty arrays.
    // See https://github.com/janl/mustache.js/issues/186
    if (!value || (isArray(value) && value.length === 0))
      return this.renderTokens(token[4], context, partials, originalTemplate);
  };

  Writer.prototype.renderPartial = function renderPartial (token, context, partials) {
    if (!partials) return;

    var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
    if (value != null)
      return this.renderTokens(this.parse(value), context, partials, value);
  };

  Writer.prototype.unescapedValue = function unescapedValue (token, context) {
    var value = context.lookup(token[1]);
    if (value != null)
      return value;
  };

  Writer.prototype.escapedValue = function escapedValue (token, context) {
    var value = context.lookup(token[1]);
    if (value != null)
      return mustache.escape(value);
  };

  Writer.prototype.rawValue = function rawValue (token) {
    return token[1];
  };

  mustache.name = 'mustache.js';
  mustache.version = '2.3.0';
  mustache.tags = [ '{{', '}}' ];

  // All high-level mustache.* functions use this writer.
  var defaultWriter = new Writer();

  /**
   * Clears all cached templates in the default writer.
   */
  mustache.clearCache = function clearCache () {
    return defaultWriter.clearCache();
  };

  /**
   * Parses and caches the given template in the default writer and returns the
   * array of tokens it contains. Doing this ahead of time avoids the need to
   * parse templates on the fly as they are rendered.
   */
  mustache.parse = function parse (template, tags) {
    return defaultWriter.parse(template, tags);
  };

  /**
   * Renders the `template` with the given `view` and `partials` using the
   * default writer.
   */
  mustache.render = function render (template, view, partials) {
    if (typeof template !== 'string') {
      throw new TypeError('Invalid template! Template should be a "string" ' +
                          'but "' + typeStr(template) + '" was given as the first ' +
                          'argument for mustache#render(template, view, partials)');
    }

    return defaultWriter.render(template, view, partials);
  };

  // This is here for backwards compatibility with 0.4.x.,
  /*eslint-disable */ // eslint wants camel cased function name
  mustache.to_html = function to_html (template, view, partials, send) {
    /*eslint-enable*/

    var result = mustache.render(template, view, partials);

    if (isFunction(send)) {
      send(result);
    } else {
      return result;
    }
  };

  // Export the escaping function so that the user may override it.
  // See https://github.com/janl/mustache.js/issues/244
  mustache.escape = escapeHtml;

  // Export these mainly for testing, but also for advanced usage.
  mustache.Scanner = Scanner;
  mustache.Context = Context;
  mustache.Writer = Writer;

  return mustache;
}));

},{}],70:[function(require,module,exports){
(function (global){(function (){
var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
// ie, `has-tostringtag/shams
var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')
    ? Symbol.toStringTag
    : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;

var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
    [].__proto__ === Array.prototype // eslint-disable-line no-proto
        ? function (O) {
            return O.__proto__; // eslint-disable-line no-proto
        }
        : null
);

function addNumericSeparator(num, str) {
    if (
        num === Infinity
        || num === -Infinity
        || num !== num
        || (num && num > -1000 && num < 1000)
        || $test.call(/e/, str)
    ) {
        return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === 'number') {
        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
        if (int !== num) {
            var intStr = String(int);
            var dec = $slice.call(str, intStr.length + 1);
            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
        }
    }
    return $replace.call(str, sepRegex, '$&_');
}

var utilInspect = require('./util.inspect');
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;

module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};

    if (has(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (
        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
            : opts.maxStringLength !== null
        )
    ) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
    }

    if (
        has(opts, 'indent')
        && opts.indent !== null
        && opts.indent !== '\t'
        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
    ) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;

    if (typeof obj === 'undefined') {
        return 'undefined';
    }
    if (obj === null) {
        return 'null';
    }
    if (typeof obj === 'boolean') {
        return obj ? 'true' : 'false';
    }

    if (typeof obj === 'string') {
        return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
        if (obj === 0) {
            return Infinity / obj > 0 ? '0' : '-0';
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === 'bigint') {
        var bigIntStr = String(obj) + 'n';
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }

    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') { depth = 0; }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
        return isArray(obj) ? '[Array]' : '[Object]';
    }

    var indent = getIndent(opts, depth);

    if (typeof seen === 'undefined') {
        seen = [];
    } else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }

    function inspect(value, from, noIndent) {
        if (from) {
            seen = $arrSlice.call(seen);
            seen.push(from);
        }
        if (noIndent) {
            var newOpts = {
                depth: opts.depth
            };
            if (has(opts, 'quoteStyle')) {
                newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
    }

    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
    }
    if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = '<' + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0) { return '[]'; }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
            return '[' + indentedJoin(xs, indent) + ']';
        }
        return '[ ' + $join.call(xs, ', ') + ' ]';
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
        }
        if (parts.length === 0) { return '[' + String(obj) + ']'; }
        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
    }
    if (typeof obj === 'object' && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
            return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
            return obj.inspect();
        }
    }
    if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
            mapForEach.call(obj, function (value, key) {
                mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
            });
        }
        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
            setForEach.call(obj, function (value) {
                setParts.push(inspect(value, obj));
            });
        }
        return collectionOf('Set', setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
        return weakCollectionOf('WeakMap');
    }
    if (isWeakSet(obj)) {
        return weakCollectionOf('WeakSet');
    }
    if (isWeakRef(obj)) {
        return weakCollectionOf('WeakRef');
    }
    if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
    }
    // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other
    /* eslint-env browser */
    if (typeof window !== 'undefined' && obj === window) {
        return '{ [object Window] }';
    }
    if (obj === global) {
        return '{ [object globalThis] }';
    }
    if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? '' : 'null prototype';
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
        if (ys.length === 0) { return tag + '{}'; }
        if (indent) {
            return tag + '{' + indentedJoin(ys, indent) + '}';
        }
        return tag + '{ ' + $join.call(ys, ', ') + ' }';
    }
    return String(obj);
};

function wrapQuotes(s, defaultStyle, opts) {
    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
    return quoteChar + s + quoteChar;
}

function quote(s) {
    return $replace.call(String(s), /"/g, '&quot;');
}

function isArray(obj) { return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isDate(obj) { return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isRegExp(obj) { return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isError(obj) { return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isString(obj) { return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isNumber(obj) { return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isBoolean(obj) { return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }

// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
function isSymbol(obj) {
    if (hasShammedSymbols) {
        return obj && typeof obj === 'object' && obj instanceof Symbol;
    }
    if (typeof obj === 'symbol') {
        return true;
    }
    if (!obj || typeof obj !== 'object' || !symToString) {
        return false;
    }
    try {
        symToString.call(obj);
        return true;
    } catch (e) {}
    return false;
}

function isBigInt(obj) {
    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
        return false;
    }
    try {
        bigIntValueOf.call(obj);
        return true;
    } catch (e) {}
    return false;
}

var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has(obj, key) {
    return hasOwn.call(obj, key);
}

function toStr(obj) {
    return objectToString.call(obj);
}

function nameOf(f) {
    if (f.name) { return f.name; }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) { return m[1]; }
    return null;
}

function indexOf(xs, x) {
    if (xs.indexOf) { return xs.indexOf(x); }
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) { return i; }
    }
    return -1;
}

function isMap(x) {
    if (!mapSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakMapHas.call(x, weakMapHas);
        try {
            weakSetHas.call(x, weakSetHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakRefDeref.call(x);
        return true;
    } catch (e) {}
    return false;
}

function isSet(x) {
    if (!setSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakSetHas.call(x, weakSetHas);
        try {
            weakMapHas.call(x, weakMapHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isElement(x) {
    if (!x || typeof x !== 'object') { return false; }
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}

function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    // eslint-disable-next-line no-control-regex
    var s = $replace.call($replace.call(str, /(['\\])/g, '\\$1'), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
}

function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
        8: 'b',
        9: 't',
        10: 'n',
        12: 'f',
        13: 'r'
    }[n];
    if (x) { return '\\' + x; }
    return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
}

function markBoxed(str) {
    return 'Object(' + str + ')';
}

function weakCollectionOf(type) {
    return type + ' { ? }';
}

function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
    return type + ' (' + size + ') {' + joinedEntries + '}';
}

function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], '\n') >= 0) {
            return false;
        }
    }
    return true;
}

function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === '\t') {
        baseIndent = '\t';
    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), ' ');
    } else {
        return null;
    }
    return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
    };
}

function indentedJoin(xs, indent) {
    if (xs.length === 0) { return ''; }
    var lineJoiner = '\n' + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
}

function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
    }
    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
            symMap['$' + syms[k]] = syms[k];
        }
    }

    for (var key in obj) { // eslint-disable-line no-restricted-syntax
        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        } else if ($test.call(/[^\w$]/, key)) {
            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
        } else {
            xs.push(key + ': ' + inspect(obj[key], obj));
        }
    }
    if (typeof gOPS === 'function') {
        for (var j = 0; j < syms.length; j++) {
            if (isEnumerable.call(obj, syms[j])) {
                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
            }
        }
    }
    return xs;
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./util.inspect":39}],71:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],72:[function(require,module,exports){
(function (global){(function (){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],73:[function(require,module,exports){
(function (process,setImmediate){(function (){
// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    "use strict";

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

    // CommonJS
    } else if (typeof exports === "object" && typeof module === "object") {
        module.exports = definition();

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
        define(definition);

    // SES (Secure EcmaScript)
    } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
            return;
        } else {
            ses.makeQ = definition;
        }

    // <script>
    } else if (typeof window !== "undefined" || typeof self !== "undefined") {
        // Prefer window over self for add-on scripts. Use self for
        // non-windowed contexts.
        var global = typeof window !== "undefined" ? window : self;

        // Get the `window` object, save the previous Q global
        // and initialize Q as a global.
        var previousQ = global.Q;
        global.Q = definition();

        // Add a noConflict function so Q can be removed from the
        // global namespace.
        global.Q.noConflict = function () {
            global.Q = previousQ;
            return this;
        };

    } else {
        throw new Error("This environment was not anticipated by Q. Please file a bug.");
    }

})(function () {
"use strict";

var hasStacks = false;
try {
    throw new Error();
} catch (e) {
    hasStacks = !!e.stack;
}

// All code after this point will be filtered from stack traces reported
// by Q.
var qStartingLine = captureLine();
var qFileName;

// shims

// used for fallback in "allResolved"
var noop = function () {};

// Use the fastest possible means to execute a task in a future turn
// of the event loop.
var nextTick =(function () {
    // linked list of tasks (single, with head node)
    var head = {task: void 0, next: null};
    var tail = head;
    var flushing = false;
    var requestTick = void 0;
    var isNodeJS = false;
    // queue for late tasks, used by unhandled rejection tracking
    var laterQueue = [];

    function flush() {
        /* jshint loopfunc: true */
        var task, domain;

        while (head.next) {
            head = head.next;
            task = head.task;
            head.task = void 0;
            domain = head.domain;

            if (domain) {
                head.domain = void 0;
                domain.enter();
            }
            runSingle(task, domain);

        }
        while (laterQueue.length) {
            task = laterQueue.pop();
            runSingle(task);
        }
        flushing = false;
    }
    // runs a single function in the async queue
    function runSingle(task, domain) {
        try {
            task();

        } catch (e) {
            if (isNodeJS) {
                // In node, uncaught exceptions are considered fatal errors.
                // Re-throw them synchronously to interrupt flushing!

                // Ensure continuation if the uncaught exception is suppressed
                // listening "uncaughtException" events (as domains does).
                // Continue in next event to avoid tick recursion.
                if (domain) {
                    domain.exit();
                }
                setTimeout(flush, 0);
                if (domain) {
                    domain.enter();
                }

                throw e;

            } else {
                // In browsers, uncaught exceptions are not fatal.
                // Re-throw them asynchronously to avoid slow-downs.
                setTimeout(function () {
                    throw e;
                }, 0);
            }
        }

        if (domain) {
            domain.exit();
        }
    }

    nextTick = function (task) {
        tail = tail.next = {
            task: task,
            domain: isNodeJS && process.domain,
            next: null
        };

        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };

    if (typeof process === "object" &&
        process.toString() === "[object process]" && process.nextTick) {
        // Ensure Q is in a real Node environment, with a `process.nextTick`.
        // To see through fake Node environments:
        // * Mocha test runner - exposes a `process` global without a `nextTick`
        // * Browserify - exposes a `process.nexTick` function that uses
        //   `setTimeout`. In this case `setImmediate` is preferred because
        //    it is faster. Browserify's `process.toString()` yields
        //   "[object Object]", while in a real Node environment
        //   `process.nextTick()` yields "[object process]".
        isNodeJS = true;

        requestTick = function () {
            process.nextTick(flush);
        };

    } else if (typeof setImmediate === "function") {
        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
        if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
        } else {
            requestTick = function () {
                setImmediate(flush);
            };
        }

    } else if (typeof MessageChannel !== "undefined") {
        // modern browsers
        // http://www.nonblocking.io/2011/06/windownexttick.html
        var channel = new MessageChannel();
        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
        // working message ports the first time a page loads.
        channel.port1.onmessage = function () {
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
        };
        var requestPortTick = function () {
            // Opera requires us to provide a message payload, regardless of
            // whether we use it.
            channel.port2.postMessage(0);
        };
        requestTick = function () {
            setTimeout(flush, 0);
            requestPortTick();
        };

    } else {
        // old browsers
        requestTick = function () {
            setTimeout(flush, 0);
        };
    }
    // runs a task after all other tasks have been run
    // this is useful for unhandled rejection tracking that needs to happen
    // after all `then`d tasks have been run.
    nextTick.runAfter = function (task) {
        laterQueue.push(task);
        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };
    return nextTick;
})();

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you dont need a security guarantee,
// this is just plain paranoid.
// However, this **might** have the nice side-effect of reducing the size of
// the minified code by reducing x.call() to merely x()
// See Mark Millers explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
var call = Function.call;
function uncurryThis(f) {
    return function () {
        return call.apply(f, arguments);
    };
}
// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

var array_slice = uncurryThis(Array.prototype.slice);

var array_reduce = uncurryThis(
    Array.prototype.reduce || function (callback, basis) {
        var index = 0,
            length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    }
);

var array_indexOf = uncurryThis(
    Array.prototype.indexOf || function (value) {
        // not a very good shim, but good enough for our one use of it
        for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    }
);

var array_map = uncurryThis(
    Array.prototype.map || function (callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    }
);

var object_create = Object.create || function (prototype) {
    function Type() { }
    Type.prototype = prototype;
    return new Type();
};

var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    return keys;
};

var object_toString = uncurryThis(Object.prototype.toString);

function isObject(value) {
    return value === Object(value);
}

// generator related shims

// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
function isStopIteration(exception) {
    return (
        object_toString(exception) === "[object StopIteration]" ||
        exception instanceof QReturnValue
    );
}

// FIXME: Remove this helper and Q.return once ES6 generators are in
// SpiderMonkey.
var QReturnValue;
if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
} else {
    QReturnValue = function (value) {
        this.value = value;
    };
}

// long stack traces

var STACK_JUMP_SEPARATOR = "From previous event:";

function makeStackTraceLong(error, promise) {
    // If possible, transform the error stack trace by removing Node and Q
    // cruft, then concatenating with the stack trace of `promise`. See #57.
    if (hasStacks &&
        promise.stack &&
        typeof error === "object" &&
        error !== null &&
        error.stack &&
        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
    ) {
        var stacks = [];
        for (var p = promise; !!p; p = p.source) {
            if (p.stack) {
                stacks.unshift(p.stack);
            }
        }
        stacks.unshift(error.stack);

        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        error.stack = filterStackString(concatedStacks);
    }
}

function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];

        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
        }
    }
    return desiredLines.join("\n");
}

function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 ||
           stackLine.indexOf("(node.js:") !== -1;
}

function getFileNameAndLineNumber(stackLine) {
    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
    // In IE10 function name can have spaces ("Anonymous function") O_o
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: "at filename:lineNumber:columnNumber"
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
    }
}

function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

    if (!fileNameAndLineNumber) {
        return false;
    }

    var fileName = fileNameAndLineNumber[0];
    var lineNumber = fileNameAndLineNumber[1];

    return fileName === qFileName &&
        lineNumber >= qStartingLine &&
        lineNumber <= qEndingLine;
}

// discover own file name and line number range for filtering stack
// traces
function captureLine() {
    if (!hasStacks) {
        return;
    }

    try {
        throw new Error();
    } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
            return;
        }

        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
    }
}

function deprecate(callback, name, alternative) {
    return function () {
        if (typeof console !== "undefined" &&
            typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative +
                         " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
    };
}

// end of shims
// beginning of real work

/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */
function Q(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (value instanceof Promise) {
        return value;
    }

    // assimilate thenables
    if (isPromiseAlike(value)) {
        return coerce(value);
    } else {
        return fulfill(value);
    }
}
Q.resolve = Q;

/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */
Q.nextTick = nextTick;

/**
 * Controls whether or not long stack traces will be on
 */
Q.longStackSupport = false;

// enable long stacks if Q_DEBUG is set
if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
    Q.longStackSupport = true;
}

/**
 * Constructs a {promise, resolve, reject} object.
 *
 * `resolve` is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke `resolve` with any value that is
 * not a thenable. To reject the promise, invoke `resolve` with a rejected
 * thenable, or invoke `reject` with the reason directly. To resolve the
 * promise to another thenable, thus putting it in the same state, invoke
 * `resolve` with that other thenable.
 */
Q.defer = defer;
function defer() {
    // if "messages" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the messages array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the `resolve` function because it handles both fully
    // non-thenable values and other thenables gracefully.
    var messages = [], progressListeners = [], resolvedPromise;

    var deferred = object_create(defer.prototype);
    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            Q.nextTick(function () {
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
        }
    };

    // XXX deprecated
    promise.valueOf = function () {
        if (messages) {
            return promise;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue; // shorten chain
        }
        return nearerValue;
    };

    promise.inspect = function () {
        if (!resolvedPromise) {
            return { state: "pending" };
        }
        return resolvedPromise.inspect();
    };

    if (Q.longStackSupport && hasStacks) {
        try {
            throw new Error();
        } catch (e) {
            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
            // accessor around; that causes memory leaks as per GH-111. Just
            // reify the stack trace as a string ASAP.
            //
            // At the same time, cut off the first line; it's always just
            // "[object Promise]\n", as per the `toString`.
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
        }
    }

    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
    // consolidating them into `become`, since otherwise we'd create new
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

    function become(newPromise) {
        resolvedPromise = newPromise;
        promise.source = newPromise;

        array_reduce(messages, function (undefined, message) {
            Q.nextTick(function () {
                newPromise.promiseDispatch.apply(newPromise, message);
            });
        }, void 0);

        messages = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(Q(value));
    };

    deferred.fulfill = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(fulfill(value));
    };
    deferred.reject = function (reason) {
        if (resolvedPromise) {
            return;
        }

        become(reject(reason));
    };
    deferred.notify = function (progress) {
        if (resolvedPromise) {
            return;
        }

        array_reduce(progressListeners, function (undefined, progressListener) {
            Q.nextTick(function () {
                progressListener(progress);
            });
        }, void 0);
    };

    return deferred;
}

/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */
defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
        if (error) {
            self.reject(error);
        } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
        } else {
            self.resolve(value);
        }
    };
};

/**
 * @param resolver {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in resolver
 */
Q.Promise = promise; // ES6
Q.promise = promise;
function promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
    }
    var deferred = defer();
    try {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
    } catch (reason) {
        deferred.reject(reason);
    }
    return deferred.promise;
}

promise.race = race; // ES6
promise.all = all; // ES6
promise.reject = reject; // ES6
promise.resolve = Q; // ES6

// XXX experimental.  This method is a way to denote that a local value is
// serializable and should be immediately dispatched to a remote upon request,
// instead of passing a reference.
Q.passByCopy = function (object) {
    //freeze(object);
    //passByCopies.set(object, true);
    return object;
};

Promise.prototype.passByCopy = function () {
    //freeze(object);
    //passByCopies.set(object, true);
    return this;
};

/**
 * If two promises eventually fulfill to the same value, promises that value,
 * but otherwise rejects.
 * @param x {Any*}
 * @param y {Any*}
 * @returns {Any*} a promise for x and y if they are the same, but a rejection
 * otherwise.
 *
 */
Q.join = function (x, y) {
    return Q(x).join(y);
};

Promise.prototype.join = function (that) {
    return Q([this, that]).spread(function (x, y) {
        if (x === y) {
            // TODO: "===" should be Object.is or equiv
            return x;
        } else {
            throw new Error("Can't join: not the same: " + x + " " + y);
        }
    });
};

/**
 * Returns a promise for the first of an array of promises to become settled.
 * @param answers {Array[Any*]} promises to race
 * @returns {Any*} the first promise to be settled
 */
Q.race = race;
function race(answerPs) {
    return promise(function (resolve, reject) {
        // Switch to this once we can assume at least ES5
        // answerPs.forEach(function (answerP) {
        //     Q(answerP).then(resolve, reject);
        // });
        // Use this in the meantime
        for (var i = 0, len = answerPs.length; i < len; i++) {
            Q(answerPs[i]).then(resolve, reject);
        }
    });
}

Promise.prototype.race = function () {
    return this.then(Q.race);
};

/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * set(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */
Q.makePromise = Promise;
function Promise(descriptor, fallback, inspect) {
    if (fallback === void 0) {
        fallback = function (op) {
            return reject(new Error(
                "Promise does not support operation: " + op
            ));
        };
    }
    if (inspect === void 0) {
        inspect = function () {
            return {state: "unknown"};
        };
    }

    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, args) {
        var result;
        try {
            if (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } else {
                result = fallback.call(promise, op, args);
            }
        } catch (exception) {
            result = reject(exception);
        }
        if (resolve) {
            resolve(result);
        }
    };

    promise.inspect = inspect;

    // XXX deprecated `valueOf` and `exception` support
    if (inspect) {
        var inspected = inspect();
        if (inspected.state === "rejected") {
            promise.exception = inspected.reason;
        }

        promise.valueOf = function () {
            var inspected = inspect();
            if (inspected.state === "pending" ||
                inspected.state === "rejected") {
                return promise;
            }
            return inspected.value;
        };
    }

    return promise;
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.then = function (fulfilled, rejected, progressed) {
    var self = this;
    var deferred = defer();
    var done = false;   // ensure the untrusted promise makes at most a
                        // single call to one of the callbacks

    function _fulfilled(value) {
        try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
            return reject(exception);
        }
    }

    function _rejected(exception) {
        if (typeof rejected === "function") {
            makeStackTraceLong(exception, self);
            try {
                return rejected(exception);
            } catch (newException) {
                return reject(newException);
            }
        }
        return reject(exception);
    }

    function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
    }

    Q.nextTick(function () {
        self.promiseDispatch(function (value) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_fulfilled(value));
        }, "when", [function (exception) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_rejected(exception));
        }]);
    });

    // Progress propagator need to be attached in the current tick.
    self.promiseDispatch(void 0, "when", [void 0, function (value) {
        var newValue;
        var threw = false;
        try {
            newValue = _progressed(value);
        } catch (e) {
            threw = true;
            if (Q.onerror) {
                Q.onerror(e);
            } else {
                throw e;
            }
        }

        if (!threw) {
            deferred.notify(newValue);
        }
    }]);

    return deferred.promise;
};

Q.tap = function (promise, callback) {
    return Q(promise).tap(callback);
};

/**
 * Works almost like "finally", but not called for rejections.
 * Original resolution value is passed through callback unaffected.
 * Callback may return a promise that will be awaited for.
 * @param {Function} callback
 * @returns {Q.Promise}
 * @example
 * doSomething()
 *   .then(...)
 *   .tap(console.log)
 *   .then(...);
 */
Promise.prototype.tap = function (callback) {
    callback = Q(callback);

    return this.then(function (value) {
        return callback.fcall(value).thenResolve(value);
    });
};

/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */
Q.when = when;
function when(value, fulfilled, rejected, progressed) {
    return Q(value).then(fulfilled, rejected, progressed);
}

Promise.prototype.thenResolve = function (value) {
    return this.then(function () { return value; });
};

Q.thenResolve = function (promise, value) {
    return Q(promise).thenResolve(value);
};

Promise.prototype.thenReject = function (reason) {
    return this.then(function () { throw reason; });
};

Q.thenReject = function (promise, reason) {
    return Q(promise).thenReject(reason);
};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If its a fulfilled promise, the fulfillment value is nearer.
 * If its a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */

// XXX should we re-do this?
Q.nearer = nearer;
function nearer(value) {
    if (isPromise(value)) {
        var inspected = value.inspect();
        if (inspected.state === "fulfilled") {
            return inspected.value;
        }
    }
    return value;
}

/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */
Q.isPromise = isPromise;
function isPromise(object) {
    return object instanceof Promise;
}

Q.isPromiseAlike = isPromiseAlike;
function isPromiseAlike(object) {
    return isObject(object) && typeof object.then === "function";
}

/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */
Q.isPending = isPending;
function isPending(object) {
    return isPromise(object) && object.inspect().state === "pending";
}

Promise.prototype.isPending = function () {
    return this.inspect().state === "pending";
};

/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */
Q.isFulfilled = isFulfilled;
function isFulfilled(object) {
    return !isPromise(object) || object.inspect().state === "fulfilled";
}

Promise.prototype.isFulfilled = function () {
    return this.inspect().state === "fulfilled";
};

/**
 * @returns whether the given object is a rejected promise.
 */
Q.isRejected = isRejected;
function isRejected(object) {
    return isPromise(object) && object.inspect().state === "rejected";
}

Promise.prototype.isRejected = function () {
    return this.inspect().state === "rejected";
};

//// BEGIN UNHANDLED REJECTION TRACKING

// This promise library consumes exceptions thrown in handlers so they can be
// handled by a subsequent promise.  The exceptions get added to this array when
// they are created, and removed when they are handled.  Note that in ES6 or
// shimmed environments, this would naturally be a `Set`.
var unhandledReasons = [];
var unhandledRejections = [];
var reportedUnhandledRejections = [];
var trackUnhandledRejections = true;

function resetUnhandledRejections() {
    unhandledReasons.length = 0;
    unhandledRejections.length = 0;

    if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;
    }
}

function trackRejection(promise, reason) {
    if (!trackUnhandledRejections) {
        return;
    }
    if (typeof process === "object" && typeof process.emit === "function") {
        Q.nextTick.runAfter(function () {
            if (array_indexOf(unhandledRejections, promise) !== -1) {
                process.emit("unhandledRejection", reason, promise);
                reportedUnhandledRejections.push(promise);
            }
        });
    }

    unhandledRejections.push(promise);
    if (reason && typeof reason.stack !== "undefined") {
        unhandledReasons.push(reason.stack);
    } else {
        unhandledReasons.push("(no stack) " + reason);
    }
}

function untrackRejection(promise) {
    if (!trackUnhandledRejections) {
        return;
    }

    var at = array_indexOf(unhandledRejections, promise);
    if (at !== -1) {
        if (typeof process === "object" && typeof process.emit === "function") {
            Q.nextTick.runAfter(function () {
                var atReport = array_indexOf(reportedUnhandledRejections, promise);
                if (atReport !== -1) {
                    process.emit("rejectionHandled", unhandledReasons[at], promise);
                    reportedUnhandledRejections.splice(atReport, 1);
                }
            });
        }
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
    }
}

Q.resetUnhandledRejections = resetUnhandledRejections;

Q.getUnhandledReasons = function () {
    // Make a copy so that consumers can't interfere with our internal state.
    return unhandledReasons.slice();
};

Q.stopUnhandledRejectionTracking = function () {
    resetUnhandledRejections();
    trackUnhandledRejections = false;
};

resetUnhandledRejections();

//// END UNHANDLED REJECTION TRACKING

/**
 * Constructs a rejected promise.
 * @param reason value describing the failure
 */
Q.reject = reject;
function reject(reason) {
    var rejection = Promise({
        "when": function (rejected) {
            // note that the error has been handled
            if (rejected) {
                untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
        }
    }, function fallback() {
        return this;
    }, function inspect() {
        return { state: "rejected", reason: reason };
    });

    // Note that the reason has not been handled.
    trackRejection(rejection, reason);

    return rejection;
}

/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */
Q.fulfill = fulfill;
function fulfill(value) {
    return Promise({
        "when": function () {
            return value;
        },
        "get": function (name) {
            return value[name];
        },
        "set": function (name, rhs) {
            value[name] = rhs;
        },
        "delete": function (name) {
            delete value[name];
        },
        "post": function (name, args) {
            // Mark Miller proposes that post with no name should apply a
            // promised function.
            if (name === null || name === void 0) {
                return value.apply(void 0, args);
            } else {
                return value[name].apply(value, args);
            }
        },
        "apply": function (thisp, args) {
            return value.apply(thisp, args);
        },
        "keys": function () {
            return object_keys(value);
        }
    }, void 0, function inspect() {
        return { state: "fulfilled", value: value };
    });
}

/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */
function coerce(promise) {
    var deferred = defer();
    Q.nextTick(function () {
        try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
            deferred.reject(exception);
        }
    });
    return deferred.promise;
}

/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */
Q.master = master;
function master(object) {
    return Promise({
        "isDef": function () {}
    }, function fallback(op, args) {
        return dispatch(object, op, args);
    }, function () {
        return Q(object).inspect();
    });
}

/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */
Q.spread = spread;
function spread(value, fulfilled, rejected) {
    return Q(value).spread(fulfilled, rejected);
}

Promise.prototype.spread = function (fulfilled, rejected) {
    return this.all().then(function (array) {
        return fulfilled.apply(void 0, array);
    }, rejected);
};

/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  Although generators are only part
 * of the newest ECMAScript 6 drafts, this code does not cause syntax
 * errors in older engines.  This code should continue to work and will
 * in fact improve over time as the language improves.
 *
 * ES6 generators are currently part of V8 version 3.19 with the
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
 * for longer, but under an older Python-inspired form.  This function
 * works on both kinds of generators.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 */
Q.async = async;
function async(makeGenerator) {
    return function () {
        // when verb is "send", arg is a value
        // when verb is "throw", arg is an exception
        function continuer(verb, arg) {
            var result;

            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
            // engine that has a deployed base of browsers that support generators.
            // However, SM's generators use the Python-inspired semantics of
            // outdated ES6 drafts.  We would like to support ES6, but we'd also
            // like to make it possible to use generators in deployed browsers, so
            // we also support Python-style generators.  At some point we can remove
            // this block.

            if (typeof StopIteration === "undefined") {
                // ES6 Generators
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    return reject(exception);
                }
                if (result.done) {
                    return Q(result.value);
                } else {
                    return when(result.value, callback, errback);
                }
            } else {
                // SpiderMonkey Generators
                // FIXME: Remove this case when SM does ES6 generators.
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    if (isStopIteration(exception)) {
                        return Q(exception.value);
                    } else {
                        return reject(exception);
                    }
                }
                return when(result, callback, errback);
            }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "next");
        var errback = continuer.bind(continuer, "throw");
        return callback();
    };
}

/**
 * The spawn function is a small wrapper around async that immediately
 * calls the generator and also ends the promise chain, so that any
 * unhandled errors are thrown instead of forwarded to the error
 * handler. This is useful because it's extremely common to run
 * generators at the top-level to work with libraries.
 */
Q.spawn = spawn;
function spawn(makeGenerator) {
    Q.done(Q.async(makeGenerator)());
}

// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 *
 * This interface is a stop-gap measure to support generator return
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
 * generators like Chromium 29, just use "return" in your generator
 * functions.
 *
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * // ES6 style
 * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
 * // Older SpiderMonkey style
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */
Q["return"] = _return;
function _return(value) {
    throw new QReturnValue(value);
}

/**
 * The promised function decorator ensures that any promise arguments
 * are settled and passed as values (`this` is also settled and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q(a), Q(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */
Q.promised = promised;
function promised(callback) {
    return function () {
        return spread([this, all(arguments)], function (self, args) {
            return callback.apply(self, args);
        });
    };
}

/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */
Q.dispatch = dispatch;
function dispatch(object, op, args) {
    return Q(object).dispatch(op, args);
}

Promise.prototype.dispatch = function (op, args) {
    var self = this;
    var deferred = defer();
    Q.nextTick(function () {
        self.promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
};

/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */
Q.get = function (object, key) {
    return Q(object).dispatch("get", [key]);
};

Promise.prototype.get = function (key) {
    return this.dispatch("get", [key]);
};

/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */
Q.set = function (object, key, value) {
    return Q(object).dispatch("set", [key, value]);
};

Promise.prototype.set = function (key, value) {
    return this.dispatch("set", [key, value]);
};

/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */
Q.del = // XXX legacy
Q["delete"] = function (object, key) {
    return Q(object).dispatch("delete", [key]);
};

Promise.prototype.del = // XXX legacy
Promise.prototype["delete"] = function (key) {
    return this.dispatch("delete", [key]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */
// bound locally because it is used by other methods
Q.mapply = // XXX As proposed by "Redsandro"
Q.post = function (object, name, args) {
    return Q(object).dispatch("post", [name, args]);
};

Promise.prototype.mapply = // XXX As proposed by "Redsandro"
Promise.prototype.post = function (name, args) {
    return this.dispatch("post", [name, args]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */
Q.send = // XXX Mark Miller's proposed parlance
Q.mcall = // XXX As proposed by "Redsandro"
Q.invoke = function (object, name /*...args*/) {
    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
};

Promise.prototype.send = // XXX Mark Miller's proposed parlance
Promise.prototype.mcall = // XXX As proposed by "Redsandro"
Promise.prototype.invoke = function (name /*...args*/) {
    return this.dispatch("post", [name, array_slice(arguments, 1)]);
};

/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */
Q.fapply = function (object, args) {
    return Q(object).dispatch("apply", [void 0, args]);
};

Promise.prototype.fapply = function (args) {
    return this.dispatch("apply", [void 0, args]);
};

/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q["try"] =
Q.fcall = function (object /* ...args*/) {
    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
};

Promise.prototype.fcall = function (/*...args*/) {
    return this.dispatch("apply", [void 0, array_slice(arguments)]);
};

/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q.fbind = function (object /*...args*/) {
    var promise = Q(object);
    var args = array_slice(arguments, 1);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};
Promise.prototype.fbind = function (/*...args*/) {
    var promise = this;
    var args = array_slice(arguments);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};

/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually settled object
 */
Q.keys = function (object) {
    return Q(object).dispatch("keys", []);
};

Promise.prototype.keys = function () {
    return this.dispatch("keys", []);
};

/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
Q.all = all;
function all(promises) {
    return when(promises, function (promises) {
        var pendingCount = 0;
        var deferred = defer();
        array_reduce(promises, function (undefined, promise, index) {
            var snapshot;
            if (
                isPromise(promise) &&
                (snapshot = promise.inspect()).state === "fulfilled"
            ) {
                promises[index] = snapshot.value;
            } else {
                ++pendingCount;
                when(
                    promise,
                    function (value) {
                        promises[index] = value;
                        if (--pendingCount === 0) {
                            deferred.resolve(promises);
                        }
                    },
                    deferred.reject,
                    function (progress) {
                        deferred.notify({ index: index, value: progress });
                    }
                );
            }
        }, void 0);
        if (pendingCount === 0) {
            deferred.resolve(promises);
        }
        return deferred.promise;
    });
}

Promise.prototype.all = function () {
    return all(this);
};

/**
 * Returns the first resolved promise of an array. Prior rejected promises are
 * ignored.  Rejects only if all promises are rejected.
 * @param {Array*} an array containing values or promises for values
 * @returns a promise fulfilled with the value of the first resolved promise,
 * or a rejected promise if all promises are rejected.
 */
Q.any = any;

function any(promises) {
    if (promises.length === 0) {
        return Q.resolve();
    }

    var deferred = Q.defer();
    var pendingCount = 0;
    array_reduce(promises, function (prev, current, index) {
        var promise = promises[index];

        pendingCount++;

        when(promise, onFulfilled, onRejected, onProgress);
        function onFulfilled(result) {
            deferred.resolve(result);
        }
        function onRejected() {
            pendingCount--;
            if (pendingCount === 0) {
                deferred.reject(new Error(
                    "Can't get fulfillment value from any promise, all " +
                    "promises were rejected."
                ));
            }
        }
        function onProgress(progress) {
            deferred.notify({
                index: index,
                value: progress
            });
        }
    }, undefined);

    return deferred.promise;
}

Promise.prototype.any = function () {
    return any(this);
};

/**
 * Waits for all promises to be settled, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */
Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
function allResolved(promises) {
    return when(promises, function (promises) {
        promises = array_map(promises, Q);
        return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
        })), function () {
            return promises;
        });
    });
}

Promise.prototype.allResolved = function () {
    return allResolved(this);
};

/**
 * @see Promise#allSettled
 */
Q.allSettled = allSettled;
function allSettled(promises) {
    return Q(promises).allSettled();
}

/**
 * Turns an array of promises into a promise for an array of their states (as
 * returned by `inspect`) when they have all settled.
 * @param {Array[Any*]} values an array (or promise for an array) of values (or
 * promises for values)
 * @returns {Array[State]} an array of states for the respective values.
 */
Promise.prototype.allSettled = function () {
    return this.then(function (promises) {
        return all(array_map(promises, function (promise) {
            promise = Q(promise);
            function regardless() {
                return promise.inspect();
            }
            return promise.then(regardless, regardless);
        }));
    });
};

/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */
Q.fail = // XXX legacy
Q["catch"] = function (object, rejected) {
    return Q(object).then(void 0, rejected);
};

Promise.prototype.fail = // XXX legacy
Promise.prototype["catch"] = function (rejected) {
    return this.then(void 0, rejected);
};

/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */
Q.progress = progress;
function progress(object, progressed) {
    return Q(object).then(void 0, void 0, progressed);
}

Promise.prototype.progress = function (progressed) {
    return this.then(void 0, void 0, progressed);
};

/**
 * Provides an opportunity to observe the settling of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */
Q.fin = // XXX legacy
Q["finally"] = function (object, callback) {
    return Q(object)["finally"](callback);
};

Promise.prototype.fin = // XXX legacy
Promise.prototype["finally"] = function (callback) {
    callback = Q(callback);
    return this.then(function (value) {
        return callback.fcall().then(function () {
            return value;
        });
    }, function (reason) {
        // TODO attempt to recycle the rejection with "this".
        return callback.fcall().then(function () {
            throw reason;
        });
    });
};

/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */
Q.done = function (object, fulfilled, rejected, progress) {
    return Q(object).done(fulfilled, rejected, progress);
};

Promise.prototype.done = function (fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
        // forward to a future turn so that ``when``
        // does not catch it and turn it into a rejection.
        Q.nextTick(function () {
            makeStackTraceLong(error, promise);
            if (Q.onerror) {
                Q.onerror(error);
            } else {
                throw error;
            }
        });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promise = fulfilled || rejected || progress ?
        this.then(fulfilled, rejected, progress) :
        this;

    if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }

    promise.then(void 0, onUnhandledError);
};

/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @param {Any*} custom error message or Error object (optional)
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */
Q.timeout = function (object, ms, error) {
    return Q(object).timeout(ms, error);
};

Promise.prototype.timeout = function (ms, error) {
    var deferred = defer();
    var timeoutId = setTimeout(function () {
        if (!error || "string" === typeof error) {
            error = new Error(error || "Timed out after " + ms + " ms");
            error.code = "ETIMEDOUT";
        }
        deferred.reject(error);
    }, ms);

    this.then(function (value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
    }, function (exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
    }, deferred.notify);

    return deferred.promise;
};

/**
 * Returns a promise for the given value (or promised value), some
 * milliseconds after it resolved. Passes rejections immediately.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after milliseconds
 * time has elapsed since the resolution of the given promise.
 * If the given promise rejects, that is passed immediately.
 */
Q.delay = function (object, timeout) {
    if (timeout === void 0) {
        timeout = object;
        object = void 0;
    }
    return Q(object).delay(timeout);
};

Promise.prototype.delay = function (timeout) {
    return this.then(function (value) {
        var deferred = defer();
        setTimeout(function () {
            deferred.resolve(value);
        }, timeout);
        return deferred.promise;
    });
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */
Q.nfapply = function (callback, args) {
    return Q(callback).nfapply(args);
};

Promise.prototype.nfapply = function (args) {
    var deferred = defer();
    var nodeArgs = array_slice(args);
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 * @example
 * Q.nfcall(FS.readFile, __filename)
 * .then(function (content) {
 * })
 *
 */
Q.nfcall = function (callback /*...args*/) {
    var args = array_slice(arguments, 1);
    return Q(callback).nfapply(args);
};

Promise.prototype.nfcall = function (/*...args*/) {
    var nodeArgs = array_slice(arguments);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 * @example
 * Q.nfbind(FS.readFile, __filename)("utf-8")
 * .then(console.log)
 * .done()
 */
Q.nfbind =
Q.denodeify = function (callback /*...args*/) {
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nfbind =
Promise.prototype.denodeify = function (/*...args*/) {
    var args = array_slice(arguments);
    args.unshift(this);
    return Q.denodeify.apply(void 0, args);
};

Q.nbind = function (callback, thisp /*...args*/) {
    var baseArgs = array_slice(arguments, 2);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        function bound() {
            return callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nbind = function (/*thisp, ...args*/) {
    var args = array_slice(arguments, 0);
    args.unshift(this);
    return Q.nbind.apply(void 0, args);
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nmapply = // XXX As proposed by "Redsandro"
Q.npost = function (object, name, args) {
    return Q(object).npost(name, args);
};

Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
Promise.prototype.npost = function (name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nsend = // XXX Based on Mark Miller's proposed "send"
Q.nmcall = // XXX Based on "Redsandro's" proposal
Q.ninvoke = function (object, name /*...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
Promise.prototype.ninvoke = function (name /*...args*/) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * If a function would like to support both Node continuation-passing-style and
 * promise-returning-style, it can end its internal promise chain with
 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
 * elects to use a nodeback, the result will be sent there.  If they do not
 * pass a nodeback, they will receive the result promise.
 * @param object a result (or a promise for a result)
 * @param {Function} nodeback a Node.js-style callback
 * @returns either the promise or nothing
 */
Q.nodeify = nodeify;
function nodeify(object, nodeback) {
    return Q(object).nodeify(nodeback);
}

Promise.prototype.nodeify = function (nodeback) {
    if (nodeback) {
        this.then(function (value) {
            Q.nextTick(function () {
                nodeback(null, value);
            });
        }, function (error) {
            Q.nextTick(function () {
                nodeback(error);
            });
        });
    } else {
        return this;
    }
};

Q.noConflict = function() {
    throw new Error("Q.noConflict only works when Q is used as a global");
};

// All code before this point will be filtered from stack traces.
var qEndingLine = captureLine();

return Q;

});

}).call(this)}).call(this,require('_process'),require("timers").setImmediate)
},{"_process":71,"timers":107}],74:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],75:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],76:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":74,"./encode":75}],77:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":41}],78:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');
var define = require('define-data-property');
var hasDescriptors = require('has-property-descriptors')();
var gOPD = require('gopd');

var $TypeError = require('es-errors/type');
var $floor = GetIntrinsic('%Math.floor%');

/** @type {import('.')} */
module.exports = function setFunctionLength(fn, length) {
	if (typeof fn !== 'function') {
		throw new $TypeError('`fn` is not a function');
	}
	if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
		throw new $TypeError('`length` must be a positive 32-bit integer');
	}

	var loose = arguments.length > 2 && !!arguments[2];

	var functionLengthIsConfigurable = true;
	var functionLengthIsWritable = true;
	if ('length' in fn && gOPD) {
		var desc = gOPD(fn, 'length');
		if (desc && !desc.configurable) {
			functionLengthIsConfigurable = false;
		}
		if (desc && !desc.writable) {
			functionLengthIsWritable = false;
		}
	}

	if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
		if (hasDescriptors) {
			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length, true, true);
		} else {
			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length);
		}
	}
	return fn;
};

},{"define-data-property":45,"es-errors/type":52,"get-intrinsic":56,"gopd":59,"has-property-descriptors":60}],79:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bind/callBound');
var inspect = require('object-inspect');

var $TypeError = require('es-errors/type');
var $WeakMap = GetIntrinsic('%WeakMap%', true);
var $Map = GetIntrinsic('%Map%', true);

var $weakMapGet = callBound('WeakMap.prototype.get', true);
var $weakMapSet = callBound('WeakMap.prototype.set', true);
var $weakMapHas = callBound('WeakMap.prototype.has', true);
var $mapGet = callBound('Map.prototype.get', true);
var $mapSet = callBound('Map.prototype.set', true);
var $mapHas = callBound('Map.prototype.has', true);

/*
* This function traverses the list returning the node corresponding to the given key.
*
* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list. By doing so, all the recently used nodes can be accessed relatively quickly.
*/
/** @type {import('.').listGetNode} */
var listGetNode = function (list, key) { // eslint-disable-line consistent-return
	/** @type {typeof list | NonNullable<(typeof list)['next']>} */
	var prev = list;
	/** @type {(typeof list)['next']} */
	var curr;
	for (; (curr = prev.next) !== null; prev = curr) {
		if (curr.key === key) {
			prev.next = curr.next;
			// eslint-disable-next-line no-extra-parens
			curr.next = /** @type {NonNullable<typeof list.next>} */ (list.next);
			list.next = curr; // eslint-disable-line no-param-reassign
			return curr;
		}
	}
};

/** @type {import('.').listGet} */
var listGet = function (objects, key) {
	var node = listGetNode(objects, key);
	return node && node.value;
};
/** @type {import('.').listSet} */
var listSet = function (objects, key, value) {
	var node = listGetNode(objects, key);
	if (node) {
		node.value = value;
	} else {
		// Prepend the new node to the beginning of the list
		objects.next = /** @type {import('.').ListNode<typeof value>} */ ({ // eslint-disable-line no-param-reassign, no-extra-parens
			key: key,
			next: objects.next,
			value: value
		});
	}
};
/** @type {import('.').listHas} */
var listHas = function (objects, key) {
	return !!listGetNode(objects, key);
};

/** @type {import('.')} */
module.exports = function getSideChannel() {
	/** @type {WeakMap<object, unknown>} */ var $wm;
	/** @type {Map<object, unknown>} */ var $m;
	/** @type {import('.').RootNode<unknown>} */ var $o;

	/** @type {import('.').Channel} */
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		get: function (key) { // eslint-disable-line consistent-return
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapGet($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapGet($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listGet($o, key);
				}
			}
		},
		has: function (key) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapHas($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapHas($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listHas($o, key);
				}
			}
			return false;
		},
		set: function (key, value) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if (!$wm) {
					$wm = new $WeakMap();
				}
				$weakMapSet($wm, key, value);
			} else if ($Map) {
				if (!$m) {
					$m = new $Map();
				}
				$mapSet($m, key, value);
			} else {
				if (!$o) {
					// Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head
					$o = { key: {}, next: null };
				}
				listSet($o, key, value);
			}
		}
	};
	return channel;
};

},{"call-bind/callBound":43,"es-errors/type":52,"get-intrinsic":56,"object-inspect":70}],80:[function(require,module,exports){
(function (global){(function (){
var ClientRequest = require('./lib/request')
var response = require('./lib/response')
var extend = require('xtend')
var statusCodes = require('builtin-status-codes')
var url = require('url')

var http = exports

http.request = function (opts, cb) {
	if (typeof opts === 'string')
		opts = url.parse(opts)
	else
		opts = extend(opts)

	// Normally, the page is loaded from http or https, so not specifying a protocol
	// will result in a (valid) protocol-relative url. However, this won't work if
	// the protocol is something else, like 'file:'
	var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''

	var protocol = opts.protocol || defaultProtocol
	var host = opts.hostname || opts.host
	var port = opts.port
	var path = opts.path || '/'

	// Necessary for IPv6 addresses
	if (host && host.indexOf(':') !== -1)
		host = '[' + host + ']'

	// This may be a relative url. The browser should always be able to interpret it correctly.
	opts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path
	opts.method = (opts.method || 'GET').toUpperCase()
	opts.headers = opts.headers || {}

	// Also valid opts.auth, opts.mode

	var req = new ClientRequest(opts)
	if (cb)
		req.on('response', cb)
	return req
}

http.get = function get (opts, cb) {
	var req = http.request(opts, cb)
	req.end()
	return req
}

http.ClientRequest = ClientRequest
http.IncomingMessage = response.IncomingMessage

http.Agent = function () {}
http.Agent.defaultMaxSockets = 4

http.globalAgent = new http.Agent()

http.STATUS_CODES = statusCodes

http.METHODS = [
	'CHECKOUT',
	'CONNECT',
	'COPY',
	'DELETE',
	'GET',
	'HEAD',
	'LOCK',
	'M-SEARCH',
	'MERGE',
	'MKACTIVITY',
	'MKCOL',
	'MOVE',
	'NOTIFY',
	'OPTIONS',
	'PATCH',
	'POST',
	'PROPFIND',
	'PROPPATCH',
	'PURGE',
	'PUT',
	'REPORT',
	'SEARCH',
	'SUBSCRIBE',
	'TRACE',
	'UNLOCK',
	'UNSUBSCRIBE'
]
}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./lib/request":82,"./lib/response":83,"builtin-status-codes":42,"url":114,"xtend":116}],81:[function(require,module,exports){
(function (global){(function (){
exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream)

exports.writableStream = isFunction(global.WritableStream)

exports.abortController = isFunction(global.AbortController)

// The xhr request to example.com may violate some restrictive CSP configurations,
// so if we're running in a browser that supports `fetch`, avoid calling getXHR()
// and assume support for certain features below.
var xhr
function getXHR () {
	// Cache the xhr value
	if (xhr !== undefined) return xhr

	if (global.XMLHttpRequest) {
		xhr = new global.XMLHttpRequest()
		// If XDomainRequest is available (ie only, where xhr might not work
		// cross domain), use the page location. Otherwise use example.com
		// Note: this doesn't actually make an http request.
		try {
			xhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com')
		} catch(e) {
			xhr = null
		}
	} else {
		// Service workers don't have XHR
		xhr = null
	}
	return xhr
}

function checkTypeSupport (type) {
	var xhr = getXHR()
	if (!xhr) return false
	try {
		xhr.responseType = type
		return xhr.responseType === type
	} catch (e) {}
	return false
}

// If fetch is supported, then arraybuffer will be supported too. Skip calling
// checkTypeSupport(), since that calls getXHR().
exports.arraybuffer = exports.fetch || checkTypeSupport('arraybuffer')

// These next two tests unavoidably show warnings in Chrome. Since fetch will always
// be used if it's available, just return false for these to avoid the warnings.
exports.msstream = !exports.fetch && checkTypeSupport('ms-stream')
exports.mozchunkedarraybuffer = !exports.fetch && checkTypeSupport('moz-chunked-arraybuffer')

// If fetch is supported, then overrideMimeType will be supported too. Skip calling
// getXHR().
exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false)

function isFunction (value) {
	return typeof value === 'function'
}

xhr = null // Help gc

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],82:[function(require,module,exports){
(function (process,global,Buffer){(function (){
var capability = require('./capability')
var inherits = require('inherits')
var response = require('./response')
var stream = require('readable-stream')

var IncomingMessage = response.IncomingMessage
var rStates = response.readyStates

function decideMode (preferBinary, useFetch) {
	if (capability.fetch && useFetch) {
		return 'fetch'
	} else if (capability.mozchunkedarraybuffer) {
		return 'moz-chunked-arraybuffer'
	} else if (capability.msstream) {
		return 'ms-stream'
	} else if (capability.arraybuffer && preferBinary) {
		return 'arraybuffer'
	} else {
		return 'text'
	}
}

var ClientRequest = module.exports = function (opts) {
	var self = this
	stream.Writable.call(self)

	self._opts = opts
	self._body = []
	self._headers = {}
	if (opts.auth)
		self.setHeader('Authorization', 'Basic ' + Buffer.from(opts.auth).toString('base64'))
	Object.keys(opts.headers).forEach(function (name) {
		self.setHeader(name, opts.headers[name])
	})

	var preferBinary
	var useFetch = true
	if (opts.mode === 'disable-fetch' || ('requestTimeout' in opts && !capability.abortController)) {
		// If the use of XHR should be preferred. Not typically needed.
		useFetch = false
		preferBinary = true
	} else if (opts.mode === 'prefer-streaming') {
		// If streaming is a high priority but binary compatibility and
		// the accuracy of the 'content-type' header aren't
		preferBinary = false
	} else if (opts.mode === 'allow-wrong-content-type') {
		// If streaming is more important than preserving the 'content-type' header
		preferBinary = !capability.overrideMimeType
	} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
		// Use binary if text streaming may corrupt data or the content-type header, or for speed
		preferBinary = true
	} else {
		throw new Error('Invalid value for opts.mode')
	}
	self._mode = decideMode(preferBinary, useFetch)
	self._fetchTimer = null
	self._socketTimeout = null
	self._socketTimer = null

	self.on('finish', function () {
		self._onFinish()
	})
}

inherits(ClientRequest, stream.Writable)

ClientRequest.prototype.setHeader = function (name, value) {
	var self = this
	var lowerName = name.toLowerCase()
	// This check is not necessary, but it prevents warnings from browsers about setting unsafe
	// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
	// http-browserify did it, so I will too.
	if (unsafeHeaders.indexOf(lowerName) !== -1)
		return

	self._headers[lowerName] = {
		name: name,
		value: value
	}
}

ClientRequest.prototype.getHeader = function (name) {
	var header = this._headers[name.toLowerCase()]
	if (header)
		return header.value
	return null
}

ClientRequest.prototype.removeHeader = function (name) {
	var self = this
	delete self._headers[name.toLowerCase()]
}

ClientRequest.prototype._onFinish = function () {
	var self = this

	if (self._destroyed)
		return
	var opts = self._opts

	if ('timeout' in opts && opts.timeout !== 0) {
		self.setTimeout(opts.timeout)
	}

	var headersObj = self._headers
	var body = null
	if (opts.method !== 'GET' && opts.method !== 'HEAD') {
        body = new Blob(self._body, {
            type: (headersObj['content-type'] || {}).value || ''
        });
    }

	// create flattened list of headers
	var headersList = []
	Object.keys(headersObj).forEach(function (keyName) {
		var name = headersObj[keyName].name
		var value = headersObj[keyName].value
		if (Array.isArray(value)) {
			value.forEach(function (v) {
				headersList.push([name, v])
			})
		} else {
			headersList.push([name, value])
		}
	})

	if (self._mode === 'fetch') {
		var signal = null
		if (capability.abortController) {
			var controller = new AbortController()
			signal = controller.signal
			self._fetchAbortController = controller

			if ('requestTimeout' in opts && opts.requestTimeout !== 0) {
				self._fetchTimer = global.setTimeout(function () {
					self.emit('requestTimeout')
					if (self._fetchAbortController)
						self._fetchAbortController.abort()
				}, opts.requestTimeout)
			}
		}

		global.fetch(self._opts.url, {
			method: self._opts.method,
			headers: headersList,
			body: body || undefined,
			mode: 'cors',
			credentials: opts.withCredentials ? 'include' : 'same-origin',
			signal: signal
		}).then(function (response) {
			self._fetchResponse = response
			self._resetTimers(false)
			self._connect()
		}, function (reason) {
			self._resetTimers(true)
			if (!self._destroyed)
				self.emit('error', reason)
		})
	} else {
		var xhr = self._xhr = new global.XMLHttpRequest()
		try {
			xhr.open(self._opts.method, self._opts.url, true)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}

		// Can't set responseType on really old browsers
		if ('responseType' in xhr)
			xhr.responseType = self._mode

		if ('withCredentials' in xhr)
			xhr.withCredentials = !!opts.withCredentials

		if (self._mode === 'text' && 'overrideMimeType' in xhr)
			xhr.overrideMimeType('text/plain; charset=x-user-defined')

		if ('requestTimeout' in opts) {
			xhr.timeout = opts.requestTimeout
			xhr.ontimeout = function () {
				self.emit('requestTimeout')
			}
		}

		headersList.forEach(function (header) {
			xhr.setRequestHeader(header[0], header[1])
		})

		self._response = null
		xhr.onreadystatechange = function () {
			switch (xhr.readyState) {
				case rStates.LOADING:
				case rStates.DONE:
					self._onXHRProgress()
					break
			}
		}
		// Necessary for streaming in Firefox, since xhr.response is ONLY defined
		// in onprogress, not in onreadystatechange with xhr.readyState = 3
		if (self._mode === 'moz-chunked-arraybuffer') {
			xhr.onprogress = function () {
				self._onXHRProgress()
			}
		}

		xhr.onerror = function () {
			if (self._destroyed)
				return
			self._resetTimers(true)
			self.emit('error', new Error('XHR error'))
		}

		try {
			xhr.send(body)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}
	}
}

/**
 * Checks if xhr.status is readable and non-zero, indicating no error.
 * Even though the spec says it should be available in readyState 3,
 * accessing it throws an exception in IE8
 */
function statusValid (xhr) {
	try {
		var status = xhr.status
		return (status !== null && status !== 0)
	} catch (e) {
		return false
	}
}

ClientRequest.prototype._onXHRProgress = function () {
	var self = this

	self._resetTimers(false)

	if (!statusValid(self._xhr) || self._destroyed)
		return

	if (!self._response)
		self._connect()

	self._response._onXHRProgress(self._resetTimers.bind(self))
}

ClientRequest.prototype._connect = function () {
	var self = this

	if (self._destroyed)
		return

	self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._resetTimers.bind(self))
	self._response.on('error', function(err) {
		self.emit('error', err)
	})

	self.emit('response', self._response)
}

ClientRequest.prototype._write = function (chunk, encoding, cb) {
	var self = this

	self._body.push(chunk)
	cb()
}

ClientRequest.prototype._resetTimers = function (done) {
	var self = this

	global.clearTimeout(self._socketTimer)
	self._socketTimer = null

	if (done) {
		global.clearTimeout(self._fetchTimer)
		self._fetchTimer = null
	} else if (self._socketTimeout) {
		self._socketTimer = global.setTimeout(function () {
			self.emit('timeout')
		}, self._socketTimeout)
	}
}

ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function (err) {
	var self = this
	self._destroyed = true
	self._resetTimers(true)
	if (self._response)
		self._response._destroyed = true
	if (self._xhr)
		self._xhr.abort()
	else if (self._fetchAbortController)
		self._fetchAbortController.abort()

	if (err)
		self.emit('error', err)
}

ClientRequest.prototype.end = function (data, encoding, cb) {
	var self = this
	if (typeof data === 'function') {
		cb = data
		data = undefined
	}

	stream.Writable.prototype.end.call(self, data, encoding, cb)
}

ClientRequest.prototype.setTimeout = function (timeout, cb) {
	var self = this

	if (cb)
		self.once('timeout', cb)

	self._socketTimeout = timeout
	self._resetTimers(false)
}

ClientRequest.prototype.flushHeaders = function () {}
ClientRequest.prototype.setNoDelay = function () {}
ClientRequest.prototype.setSocketKeepAlive = function () {}

// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
var unsafeHeaders = [
	'accept-charset',
	'accept-encoding',
	'access-control-request-headers',
	'access-control-request-method',
	'connection',
	'content-length',
	'cookie',
	'cookie2',
	'date',
	'dnt',
	'expect',
	'host',
	'keep-alive',
	'origin',
	'referer',
	'te',
	'trailer',
	'transfer-encoding',
	'upgrade',
	'via'
]

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"./capability":81,"./response":83,"_process":71,"buffer":41,"inherits":68,"readable-stream":98}],83:[function(require,module,exports){
(function (process,global,Buffer){(function (){
var capability = require('./capability')
var inherits = require('inherits')
var stream = require('readable-stream')

var rStates = exports.readyStates = {
	UNSENT: 0,
	OPENED: 1,
	HEADERS_RECEIVED: 2,
	LOADING: 3,
	DONE: 4
}

var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, resetTimers) {
	var self = this
	stream.Readable.call(self)

	self._mode = mode
	self.headers = {}
	self.rawHeaders = []
	self.trailers = {}
	self.rawTrailers = []

	// Fake the 'close' event, but only once 'end' fires
	self.on('end', function () {
		// The nextTick is necessary to prevent the 'request' module from causing an infinite loop
		process.nextTick(function () {
			self.emit('close')
		})
	})

	if (mode === 'fetch') {
		self._fetchResponse = response

		self.url = response.url
		self.statusCode = response.status
		self.statusMessage = response.statusText
		
		response.headers.forEach(function (header, key){
			self.headers[key.toLowerCase()] = header
			self.rawHeaders.push(key, header)
		})

		if (capability.writableStream) {
			var writable = new WritableStream({
				write: function (chunk) {
					resetTimers(false)
					return new Promise(function (resolve, reject) {
						if (self._destroyed) {
							reject()
						} else if(self.push(Buffer.from(chunk))) {
							resolve()
						} else {
							self._resumeFetch = resolve
						}
					})
				},
				close: function () {
					resetTimers(true)
					if (!self._destroyed)
						self.push(null)
				},
				abort: function (err) {
					resetTimers(true)
					if (!self._destroyed)
						self.emit('error', err)
				}
			})

			try {
				response.body.pipeTo(writable).catch(function (err) {
					resetTimers(true)
					if (!self._destroyed)
						self.emit('error', err)
				})
				return
			} catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this
		}
		// fallback for when writableStream or pipeTo aren't available
		var reader = response.body.getReader()
		function read () {
			reader.read().then(function (result) {
				if (self._destroyed)
					return
				resetTimers(result.done)
				if (result.done) {
					self.push(null)
					return
				}
				self.push(Buffer.from(result.value))
				read()
			}).catch(function (err) {
				resetTimers(true)
				if (!self._destroyed)
					self.emit('error', err)
			})
		}
		read()
	} else {
		self._xhr = xhr
		self._pos = 0

		self.url = xhr.responseURL
		self.statusCode = xhr.status
		self.statusMessage = xhr.statusText
		var headers = xhr.getAllResponseHeaders().split(/\r?\n/)
		headers.forEach(function (header) {
			var matches = header.match(/^([^:]+):\s*(.*)/)
			if (matches) {
				var key = matches[1].toLowerCase()
				if (key === 'set-cookie') {
					if (self.headers[key] === undefined) {
						self.headers[key] = []
					}
					self.headers[key].push(matches[2])
				} else if (self.headers[key] !== undefined) {
					self.headers[key] += ', ' + matches[2]
				} else {
					self.headers[key] = matches[2]
				}
				self.rawHeaders.push(matches[1], matches[2])
			}
		})

		self._charset = 'x-user-defined'
		if (!capability.overrideMimeType) {
			var mimeType = self.rawHeaders['mime-type']
			if (mimeType) {
				var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/)
				if (charsetMatch) {
					self._charset = charsetMatch[1].toLowerCase()
				}
			}
			if (!self._charset)
				self._charset = 'utf-8' // best guess
		}
	}
}

inherits(IncomingMessage, stream.Readable)

IncomingMessage.prototype._read = function () {
	var self = this

	var resolve = self._resumeFetch
	if (resolve) {
		self._resumeFetch = null
		resolve()
	}
}

IncomingMessage.prototype._onXHRProgress = function (resetTimers) {
	var self = this

	var xhr = self._xhr

	var response = null
	switch (self._mode) {
		case 'text':
			response = xhr.responseText
			if (response.length > self._pos) {
				var newData = response.substr(self._pos)
				if (self._charset === 'x-user-defined') {
					var buffer = Buffer.alloc(newData.length)
					for (var i = 0; i < newData.length; i++)
						buffer[i] = newData.charCodeAt(i) & 0xff

					self.push(buffer)
				} else {
					self.push(newData, self._charset)
				}
				self._pos = response.length
			}
			break
		case 'arraybuffer':
			if (xhr.readyState !== rStates.DONE || !xhr.response)
				break
			response = xhr.response
			self.push(Buffer.from(new Uint8Array(response)))
			break
		case 'moz-chunked-arraybuffer': // take whole
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING || !response)
				break
			self.push(Buffer.from(new Uint8Array(response)))
			break
		case 'ms-stream':
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING)
				break
			var reader = new global.MSStreamReader()
			reader.onprogress = function () {
				if (reader.result.byteLength > self._pos) {
					self.push(Buffer.from(new Uint8Array(reader.result.slice(self._pos))))
					self._pos = reader.result.byteLength
				}
			}
			reader.onload = function () {
				resetTimers(true)
				self.push(null)
			}
			// reader.onerror = ??? // TODO: this
			reader.readAsArrayBuffer(response)
			break
	}

	// The ms-stream case handles end separately in reader.onload()
	if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
		resetTimers(true)
		self.push(null)
	}
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"./capability":81,"_process":71,"buffer":41,"inherits":68,"readable-stream":98}],84:[function(require,module,exports){
'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

},{}],85:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
};
/*</replacement>*/

module.exports = Duplex;
var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');
require('inherits')(Duplex, Readable);
{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}
function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;
  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;
    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}
Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

// the no-half-open enforcer
function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(onEndNT, this);
}
function onEndNT(self) {
  self.end();
}
Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this)}).call(this,require('_process'))
},{"./_stream_readable":87,"./_stream_writable":89,"_process":71,"inherits":68}],86:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;
var Transform = require('./_stream_transform');
require('inherits')(PassThrough, Transform);
function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}
PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":88,"inherits":68}],87:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

module.exports = Readable;

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;
var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

var Buffer = require('buffer').Buffer;
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*<replacement>*/
var debugUtil = require('util');
var debug;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/buffer_list');
var destroyImpl = require('./internal/streams/destroy');
var _require = require('./internal/streams/state'),
  getHighWaterMark = _require.getHighWaterMark;
var _require$codes = require('../errors').codes,
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

// Lazy loaded to improve the startup performance.
var StringDecoder;
var createReadableStreamAsyncIterator;
var from;
require('inherits')(Readable, Stream);
var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}
function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false;

  // Should .destroy() be called after 'end' (and potentially 'finish')
  this.autoDestroy = !!options.autoDestroy;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options);

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5
  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex);

  // legacy
  this.readable = true;
  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }
  Stream.call(this);
}
Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;
  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }
  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  }

  // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.
  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}
function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }
  return er;
}
Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder;
  // If setEncoding(null), decoder.encoding equals utf8
  this._readableState.encoding = this._readableState.decoder.encoding;

  // Iterate over current buffer to convert already stored Buffers:
  var p = this._readableState.buffer.head;
  var content = '';
  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }
  this._readableState.buffer.clear();
  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
};

// Don't raise the hwm > 1GB
var MAX_HWM = 0x40000000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }
  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }
  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;
  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }
  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }
  if (ret !== null) this.emit('data', ret);
  return ret;
};
function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;
    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}
function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);
  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  }

  // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.
  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};
Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;
  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }
  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);
    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);
  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }
  return dest;
};
function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}
Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {
      hasUnpiped: false
    });
    return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;
  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0;

    // Try start flowing on next tick if stream isn't explicitly paused
    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);
      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }
  return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);
  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);
  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;
  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true;

    // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}
function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()
    state.flowing = !state.readableListening;
    resume(this, state);
  }
  state.paused = false;
  return this;
};
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}
function resume_(stream, state) {
  debug('resume', state.reading);
  if (!state.reading) {
    stream.read(0);
  }
  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}
Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  this._readableState.paused = true;
  return this;
};
function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null);
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;
  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }
    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };
  return this;
};
if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }
    return createReadableStreamAsyncIterator(this);
  };
}
Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
});

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}
function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);
  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length);

  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;
      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}
if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }
    return from(Readable, iterable, opts);
  };
}
function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../errors":84,"./_stream_duplex":85,"./internal/streams/async_iterator":90,"./internal/streams/buffer_list":91,"./internal/streams/destroy":92,"./internal/streams/from":94,"./internal/streams/state":96,"./internal/streams/stream":97,"_process":71,"buffer":41,"events":40,"inherits":68,"string_decoder/":99,"util":39}],88:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;
var _require$codes = require('../errors').codes,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex = require('./_stream_duplex');
require('inherits')(Transform, Duplex);
function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }
  ts.writechunk = null;
  ts.writecb = null;
  if (data != null)
    // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}
function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}
function prefinish() {
  var _this = this;
  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}
Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};
Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;
  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};
Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};
function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null)
    // single equals check for both `null` and `undefined`
    stream.push(data);

  // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
},{"../errors":84,"./_stream_duplex":85,"inherits":68}],89:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

var Buffer = require('buffer').Buffer;
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
var destroyImpl = require('./internal/streams/destroy');
var _require = require('./internal/streams/state'),
  getHighWaterMark = _require.getHighWaterMark;
var _require$codes = require('../errors').codes,
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
var errorOrDestroy = destroyImpl.errorOrDestroy;
require('inherits')(Writable, Stream);
function nop() {}
function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false;

  // Should .destroy() be called after 'finish' (and potentially 'end')
  this.autoDestroy = !!options.autoDestroy;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}
function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5
  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex);

  // legacy.
  this.writable = true;
  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }
  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END();
  // TODO: defer error events consistently everywhere, not just the cb
  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var er;
  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }
  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }
  return true;
}
Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);
  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }
  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};
Writable.prototype.cork = function () {
  this._writableState.corked++;
};
Writable.prototype.uncork = function () {
  var state = this._writableState;
  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};
Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}
Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;
  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}
function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;
  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }
    if (entry === null) state.lastBufferedRequest = null;
  }
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}
Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};
Writable.prototype._writev = null;
Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;
  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending) endWritable(this, state, cb);
  return this;
};
Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      errorOrDestroy(stream, err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;
        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }
  return need;
}
function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}
function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  // reuse the free corkReq.
  state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../errors":84,"./_stream_duplex":85,"./internal/streams/destroy":92,"./internal/streams/state":96,"./internal/streams/stream":97,"_process":71,"buffer":41,"inherits":68,"util-deprecate":115}],90:[function(require,module,exports){
(function (process){(function (){
'use strict';

var _Object$setPrototypeO;
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var finished = require('./end-of-stream');
var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');
function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}
function readAndResolve(iter) {
  var resolve = iter[kLastResolve];
  if (resolve !== null) {
    var data = iter[kStream].read();
    // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'
    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}
function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}
function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }
      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}
var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },
  next: function next() {
    var _this = this;
    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];
    if (error !== null) {
      return Promise.reject(error);
    }
    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }
    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    }

    // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time
    var lastPromise = this[kLastPromise];
    var promise;
    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();
      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }
      promise = new Promise(this[kHandlePromise]);
    }
    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;
  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }
      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);
var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;
  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();
      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject];
      // reject if we are waiting for data in the Promise
      // returned by next() and store the error
      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }
      iterator[kError] = err;
      return;
    }
    var resolve = iterator[kLastResolve];
    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }
    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};
module.exports = createReadableStreamAsyncIterator;
}).call(this)}).call(this,require('_process'))
},{"./end-of-stream":93,"_process":71}],91:[function(require,module,exports){
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var _require = require('buffer'),
  Buffer = _require.Buffer;
var _require2 = require('util'),
  inspect = _require2.inspect;
var custom = inspect && inspect.custom || 'inspect';
function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}
module.exports = /*#__PURE__*/function () {
  function BufferList() {
    _classCallCheck(this, BufferList);
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;
      while (p = p.next) ret += s + p.data;
      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    }

    // Consumes a specified amount of bytes or characters from the buffered data.
  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;
      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    }

    // Consumes a specified amount of characters from the buffered data.
  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      this.length -= c;
      return ret;
    }

    // Consumes a specified amount of bytes from the buffered data.
  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      this.length -= c;
      return ret;
    }

    // Make sure the linked list only shows the minimal necessary information.
  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);
  return BufferList;
}();
},{"buffer":41,"util":39}],92:[function(require,module,exports){
(function (process){(function (){
'use strict';

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;
  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });
  return this;
}
function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}
function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}
function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
function emitErrorNT(self, err) {
  self.emit('error', err);
}
function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.

  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}
module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
}).call(this)}).call(this,require('_process'))
},{"_process":71}],93:[function(require,module,exports){
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).

'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;
function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    callback.apply(this, args);
  };
}
function noop() {}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;
  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };
  var writableEnded = stream._writableState && stream._writableState.finished;
  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };
  var readableEnded = stream._readableState && stream._readableState.endEmitted;
  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };
  var onerror = function onerror(err) {
    callback.call(stream, err);
  };
  var onclose = function onclose() {
    var err;
    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };
  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };
  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }
  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}
module.exports = eos;
},{"../../../errors":84}],94:[function(require,module,exports){
module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};

},{}],95:[function(require,module,exports){
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).

'use strict';

var eos;
function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}
var _require$codes = require('../../../errors').codes,
  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true;

    // request.destroy just do .end - .abort is what we want
    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}
function call(fn) {
  fn();
}
function pipe(from, to) {
  return from.pipe(to);
}
function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}
function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }
  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }
  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}
module.exports = pipeline;
},{"../../../errors":84,"./end-of-stream":93}],96:[function(require,module,exports){
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }
    return Math.floor(hwm);
  }

  // Default value
  return state.objectMode ? 16 : 16 * 1024;
}
module.exports = {
  getHighWaterMark: getHighWaterMark
};
},{"../../../errors":84}],97:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":40}],98:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');

},{"./lib/_stream_duplex.js":85,"./lib/_stream_passthrough.js":86,"./lib/_stream_readable.js":87,"./lib/_stream_transform.js":88,"./lib/_stream_writable.js":89,"./lib/internal/streams/end-of-stream.js":93,"./lib/internal/streams/pipeline.js":95}],99:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":77}],100:[function(require,module,exports){
'use strict';

var Response = require('http-response-object');
var handleQs = require('then-request/lib/handle-qs.js');

module.exports = doRequest;
function doRequest(method, url, options, callback) {
  var xhr = new window.XMLHttpRequest();

  // check types of arguments

  if (typeof method !== 'string') {
    throw new TypeError('The method must be a string.');
  }
  if (typeof url !== 'string') {
    throw new TypeError('The URL/path must be a string.');
  }
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }
  if (options === null || options === undefined) {
    options = {};
  }
  if (typeof options !== 'object') {
    throw new TypeError('Options must be an object (or null).');
  }
  if (typeof callback !== 'function') {
    callback = undefined;
  }

  method = method.toUpperCase();
  options.headers = options.headers || {};

  // handle cross domain

  var match;
  var crossDomain = !!((match = /^([\w-]+:)?\/\/([^\/]+)/.exec(options.uri)) && (match[2] != window.location.host));
  if (!crossDomain) options.headers['X-Requested-With'] = 'XMLHttpRequest';

  // handle query string
  if (options.qs) {
    url = handleQs(url, options.qs);
  }

  // handle json body
  if (options.json) {
    options.body = JSON.stringify(options.json);
    options.headers['content-type'] = 'application/json';
  }

  // method, url, async
  xhr.open(method, url, false);

  for (var name in options.headers) {
    xhr.setRequestHeader(name.toLowerCase(), options.headers[name]);
  }

  // avoid sending empty string (#319)
  xhr.send(options.body ? options.body : null);


  var headers = {};
  xhr.getAllResponseHeaders().split('\r\n').forEach(function (header) {
    var h = header.split(':');
    if (h.length > 1) {
      headers[h[0].toLowerCase()] = h.slice(1).join(':').trim();
    }
  });
  return new Response(xhr.status, headers, xhr.responseText);
}

},{"http-response-object":65,"then-request/lib/handle-qs.js":101}],101:[function(require,module,exports){
'use strict';

var parse = require('qs').parse;
var stringify = require('qs').stringify;

module.exports = handleQs;
function handleQs(url, query) {
  url = url.split('?');
  var start = url[0];
  var qs = (url[1] || '').split('#')[0];
  var end = url[1] && url[1].split('#').length > 1 ? '#' + url[1].split('#')[1] : '';

  var baseQs = parse(qs);
  for (var i in query) {
    baseQs[i] = query[i];
  }
  qs = stringify(baseQs);
  if (qs !== '') {
    qs = '?' + qs;
  }
  return start + qs + end;
}

},{"qs":103}],102:[function(require,module,exports){
'use strict';

var replace = String.prototype.replace;
var percentTwenties = /%20/g;

var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

module.exports = {
    'default': Format.RFC3986,
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return String(value);
        }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
};

},{}],103:[function(require,module,exports){
'use strict';

var stringify = require('./stringify');
var parse = require('./parse');
var formats = require('./formats');

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};

},{"./formats":102,"./parse":104,"./stringify":105}],104:[function(require,module,exports){
'use strict';

var utils = require('./utils');

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var defaults = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    duplicates: 'combine',
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

var parseArrayValue = function (val, options) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
        return val.split(',');
    }

    return val;
};

// This is what browsers will submit when the  character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the  character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = { __proto__: null };

    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, 'key');
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
            val = utils.maybeMap(
                parseArrayValue(part.slice(pos + 1), options),
                function (encodedVal) {
                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
                }
            );
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(val);
        }

        if (part.indexOf('[]=') > -1) {
            val = isArray(val) ? [val] : val;
        }

        var existing = has.call(obj, key);
        if (existing && options.duplicates === 'combine') {
            obj[key] = utils.combine(obj[key], val);
        } else if (!existing || options.duplicates === 'last') {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = options.allowEmptyArrays && leaf === '' ? [] : [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, '.') : cleanRoot;
            var index = parseInt(decodedRoot, 10);
            if (!options.parseArrays && decodedRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== decodedRoot
                && String(index) === decodedRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else if (decodedRoot !== '__proto__') {
                obj[decodedRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options, valuesParsed);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }

    if (typeof opts.decodeDotInKeys !== 'undefined' && typeof opts.decodeDotInKeys !== 'boolean') {
        throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided');
    }

    if (opts.decoder !== null && typeof opts.decoder !== 'undefined' && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    var duplicates = typeof opts.duplicates === 'undefined' ? defaults.duplicates : opts.duplicates;

    if (duplicates !== 'combine' && duplicates !== 'first' && duplicates !== 'last') {
        throw new TypeError('The duplicates option must be either combine, first, or last');
    }

    var allowDots = typeof opts.allowDots === 'undefined' ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;

    return {
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === 'boolean' ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
        duplicates: duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
        obj = utils.merge(obj, newObj, options);
    }

    if (options.allowSparse === true) {
        return obj;
    }

    return utils.compact(obj);
};

},{"./utils":106}],105:[function(require,module,exports){
'use strict';

var getSideChannel = require('side-channel');
var utils = require('./utils');
var formats = require('./formats');
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};

var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaultFormat = formats['default'];
var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: 'indices',
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encodeDotInKeys: false,
    encoder: utils.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string'
        || typeof v === 'number'
        || typeof v === 'boolean'
        || typeof v === 'symbol'
        || typeof v === 'bigint';
};

var sentinel = {};

var stringify = function stringify(
    object,
    prefix,
    generateArrayPrefix,
    commaRoundTrip,
    allowEmptyArrays,
    strictNullHandling,
    skipNulls,
    encodeDotInKeys,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    format,
    formatter,
    encodeValuesOnly,
    charset,
    sideChannel
) {
    var obj = object;

    var tmpSc = sideChannel;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {
        // Where object last appeared in the ref tree
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== 'undefined') {
            if (pos === step) {
                throw new RangeError('Cyclic object value');
            } else {
                findFlag = true; // Break while
            }
        }
        if (typeof tmpSc.get(sentinel) === 'undefined') {
            step = 0;
        }
    }

    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = utils.maybeMap(obj, function (value) {
            if (value instanceof Date) {
                return serializeDate(value);
            }
            return value;
        });
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
        }

        obj = '';
    }

    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (generateArrayPrefix === 'comma' && isArray(obj)) {
        // we need to join elements in
        if (encodeValuesOnly && encoder) {
            obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];
    } else if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    var encodedPrefix = encodeDotInKeys ? prefix.replace(/\./g, '%2E') : prefix;

    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + '[]' : encodedPrefix;

    if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
        return adjustedPrefix + '[]';
    }

    for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];

        if (skipNulls && value === null) {
            continue;
        }

        var encodedKey = allowDots && encodeDotInKeys ? key.replace(/\./g, '%2E') : key;
        var keyPrefix = isArray(obj)
            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix
            : adjustedPrefix + (allowDots ? '.' + encodedKey : '[' + encodedKey + ']');

        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify(
            value,
            keyPrefix,
            generateArrayPrefix,
            commaRoundTrip,
            allowEmptyArrays,
            strictNullHandling,
            skipNulls,
            encodeDotInKeys,
            generateArrayPrefix === 'comma' && encodeValuesOnly && isArray(obj) ? null : encoder,
            filter,
            sort,
            allowDots,
            serializeDate,
            format,
            formatter,
            encodeValuesOnly,
            charset,
            valueSideChannel
        ));
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }

    if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {
        throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');
    }

    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    var arrayFormat;
    if (opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if ('indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = defaults.arrayFormat;
    }

    if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
    }

    var allowDots = typeof opts.allowDots === 'undefined' ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        arrayFormat: arrayFormat,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        commaRoundTrip: opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        format: format,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
    var commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    var sideChannel = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (options.skipNulls && obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(
            obj[key],
            key,
            generateArrayPrefix,
            commaRoundTrip,
            options.allowEmptyArrays,
            options.strictNullHandling,
            options.skipNulls,
            options.encodeDotInKeys,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.format,
            options.formatter,
            options.encodeValuesOnly,
            options.charset,
            sideChannel
        ));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};

},{"./formats":102,"./utils":106,"side-channel":79}],106:[function(require,module,exports){
'use strict';

var formats = require('./formats');

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var limit = 1024;

/* eslint operator-linebreak: [2, "before"] */

var encode = function encode(str, defaultEncoder, charset, kind, format) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = str;
    if (typeof str === 'symbol') {
        string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
        string = String(str);
    }

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var j = 0; j < string.length; j += limit) {
        var segment = string.length >= limit ? string.slice(j, j + limit) : string;
        var arr = [];

        for (var i = 0; i < segment.length; ++i) {
            var c = segment.charCodeAt(i);
            if (
                c === 0x2D // -
                || c === 0x2E // .
                || c === 0x5F // _
                || c === 0x7E // ~
                || (c >= 0x30 && c <= 0x39) // 0-9
                || (c >= 0x41 && c <= 0x5A) // a-z
                || (c >= 0x61 && c <= 0x7A) // A-Z
                || (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )
            ) {
                arr[arr.length] = segment.charAt(i);
                continue;
            }

            if (c < 0x80) {
                arr[arr.length] = hexTable[c];
                continue;
            }

            if (c < 0x800) {
                arr[arr.length] = hexTable[0xC0 | (c >> 6)]
                    + hexTable[0x80 | (c & 0x3F)];
                continue;
            }

            if (c < 0xD800 || c >= 0xE000) {
                arr[arr.length] = hexTable[0xE0 | (c >> 12)]
                    + hexTable[0x80 | ((c >> 6) & 0x3F)]
                    + hexTable[0x80 | (c & 0x3F)];
                continue;
            }

            i += 1;
            c = 0x10000 + (((c & 0x3FF) << 10) | (segment.charCodeAt(i) & 0x3FF));

            arr[arr.length] = hexTable[0xF0 | (c >> 18)]
                + hexTable[0x80 | ((c >> 12) & 0x3F)]
                + hexTable[0x80 | ((c >> 6) & 0x3F)]
                + hexTable[0x80 | (c & 0x3F)];
        }

        out += arr.join('');
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
            mapped.push(fn(val[i]));
        }
        return mapped;
    }
    return fn(val);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    maybeMap: maybeMap,
    merge: merge
};

},{"./formats":102}],107:[function(require,module,exports){
(function (setImmediate,clearImmediate){(function (){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this)}).call(this,require("timers").setImmediate,require("timers").clearImmediate)
},{"process/browser.js":71,"timers":107}],108:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],109:[function(require,module,exports){
arguments[4][102][0].apply(exports,arguments)
},{"dup":102}],110:[function(require,module,exports){
arguments[4][103][0].apply(exports,arguments)
},{"./formats":109,"./parse":111,"./stringify":112,"dup":103}],111:[function(require,module,exports){
arguments[4][104][0].apply(exports,arguments)
},{"./utils":113,"dup":104}],112:[function(require,module,exports){
arguments[4][105][0].apply(exports,arguments)
},{"./formats":109,"./utils":113,"dup":105,"side-channel":79}],113:[function(require,module,exports){
arguments[4][106][0].apply(exports,arguments)
},{"./formats":109,"dup":106}],114:[function(require,module,exports){
/*
 * Copyright Joyent, Inc. and other Node contributors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to permit
 * persons to whom the Software is furnished to do so, subject to the
 * following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
 * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

'use strict';

var punycode = require('punycode');

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

/*
 * define these here so at least they only have to be
 * compiled once on the first module load.
 */
var protocolPattern = /^([a-z0-9.+-]+:)/i,
  portPattern = /:[0-9]*$/,

  // Special case for a simple path URL
  simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/,

  /*
   * RFC 2396: characters reserved for delimiting URLs.
   * We actually just auto-escape these.
   */
  delims = [
    '<', '>', '"', '`', ' ', '\r', '\n', '\t'
  ],

  // RFC 2396: characters not allowed for various reasons.
  unwise = [
    '{', '}', '|', '\\', '^', '`'
  ].concat(delims),

  // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
  autoEscape = ['\''].concat(unwise),
  /*
   * Characters that are never ever allowed in a hostname.
   * Note that any invalid chars are also handled, but these
   * are the ones that are *expected* to be seen, so we fast-path
   * them.
   */
  nonHostChars = [
    '%', '/', '?', ';', '#'
  ].concat(autoEscape),
  hostEndingChars = [
    '/', '?', '#'
  ],
  hostnameMaxLen = 255,
  hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
  hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
  // protocols that can allow "unsafe" and "unwise" chars.
  unsafeProtocol = {
    javascript: true,
    'javascript:': true
  },
  // protocols that never have a hostname.
  hostlessProtocol = {
    javascript: true,
    'javascript:': true
  },
  // protocols that always contain a // bit.
  slashedProtocol = {
    http: true,
    https: true,
    ftp: true,
    gopher: true,
    file: true,
    'http:': true,
    'https:': true,
    'ftp:': true,
    'gopher:': true,
    'file:': true
  },
  querystring = require('qs');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && typeof url === 'object' && url instanceof Url) { return url; }

  var u = new Url();
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
  if (typeof url !== 'string') {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  /*
   * Copy chrome, IE, opera backslash-handling behavior.
   * Back slashes before the query string get converted to forward slashes
   * See: https://code.google.com/p/chromium/issues/detail?id=25916
   */
  var queryIndex = url.indexOf('?'),
    splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
    uSplit = url.split(splitter),
    slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  /*
   * trim before proceeding.
   * This is to support parse stuff like "  http://foo.com  \n"
   */
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  /*
   * figure out if it's got a host
   * user@server is *always* interpreted as a hostname, and url
   * resolution will treat //foo/bar as host=foo,path=bar because that's
   * how the browser resolves relative URLs.
   */
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@/]+@[^@/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {

    /*
     * there's a hostname.
     * the first instance of /, ?, ;, or # ends the host.
     *
     * If there is an @ in the hostname, then non-host chars *are* allowed
     * to the left of the last @ sign, unless some host-ending character
     * comes *before* the @-sign.
     * URLs are obnoxious.
     *
     * ex:
     * http://a@b@c/ => user:a@b host:c
     * http://a@b?@c => user:a host:c path:/?@c
     */

    /*
     * v0.12 TODO(isaacs): This is not quite how Chrome does things.
     * Review our test case against browsers more comprehensively.
     */

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }
    }

    /*
     * at this point, either we have an explicit point where the
     * auth portion cannot go past, or the last @ char is the decider.
     */
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      /*
       * atSign must be in auth portion.
       * http://a@b/c@d => host:b auth:a path:/c@d
       */
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    /*
     * Now we have a portion which is definitely the auth.
     * Pull that off.
     */
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1) { hostEnd = rest.length; }

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    /*
     * we've indicated that there is a hostname,
     * so even if it's empty, it has to be present.
     */
    this.hostname = this.hostname || '';

    /*
     * if hostname begins with [ and ends with ]
     * assume that it's an IPv6 address.
     */
    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) { continue; }
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              /*
               * we replace non-ASCII char with a temporary placeholder
               * we need this to make sure size of hostname is not
               * broken by replacing non-ASCII by nothing
               */
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      /*
       * IDNA Support: Returns a punycoded representation of "domain".
       * It only converts parts of the domain name that
       * have non-ASCII characters, i.e. it doesn't matter if
       * you call it with a domain that already is ASCII-only.
       */
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    /*
     * strip [ and ] from the hostname
     * the host field still retains them, though
     */
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  /*
   * now rest is set to the post-host stuff.
   * chop off any delim chars.
   */
  if (!unsafeProtocol[lowerProto]) {

    /*
     * First, make 100% sure that any "autoEscape" chars get
     * escaped, even if encodeURIComponent doesn't think they
     * need to be.
     */
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1) { continue; }
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }

  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) { this.pathname = rest; }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  // to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  /*
   * ensure it's an object, and not a string url.
   * If it's an obj, this is a no-op.
   * this way, you can call url_format() on strings
   * to clean up potentially wonky urls.
   */
  if (typeof obj === 'string') { obj = urlParse(obj); }
  if (!(obj instanceof Url)) { return Url.prototype.format.call(obj); }
  return obj.format();
}

Url.prototype.format = function () {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
    pathname = this.pathname || '',
    hash = this.hash || '',
    host = false,
    query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query && typeof this.query === 'object' && Object.keys(this.query).length) {
    query = querystring.stringify(this.query, {
      arrayFormat: 'repeat',
      addQueryPrefix: false
    });
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') { protocol += ':'; }

  /*
   * only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
   * unless they had them to begin with.
   */
  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') { pathname = '/' + pathname; }
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') { hash = '#' + hash; }
  if (search && search.charAt(0) !== '?') { search = '?' + search; }

  pathname = pathname.replace(/[?#]/g, function (match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function (relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) { return relative; }
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function (relative) {
  if (typeof relative === 'string') {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  /*
   * hash is always overridden, no matter what.
   * even href="" will remove it.
   */
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol') { result[rkey] = relative[rkey]; }
    }

    // urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.pathname = '/';
      result.path = result.pathname;
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    /*
     * if it's a known url protocol, then changing
     * the protocol does weird things
     * first, if it's not file:, then we MUST have a host,
     * and if there was a path
     * to begin with, then we MUST have a path.
     * if it is file:, then the host is dropped,
     * because that's known to be hostless.
     * anything else is assumed to be absolute.
     */
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift())) { }
      if (!relative.host) { relative.host = ''; }
      if (!relative.hostname) { relative.hostname = ''; }
      if (relPath[0] !== '') { relPath.unshift(''); }
      if (relPath.length < 2) { relPath.unshift(''); }
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
    isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
    mustEndAbs = isRelAbs || isSourceAbs || (result.host && relative.pathname),
    removeAllDots = mustEndAbs,
    srcPath = result.pathname && result.pathname.split('/') || [],
    relPath = relative.pathname && relative.pathname.split('/') || [],
    psychotic = result.protocol && !slashedProtocol[result.protocol];

  /*
   * if the url is a non-slashed url, then relative
   * links like ../.. should be able
   * to crawl up to the hostname, as well.  This is strange.
   * result.protocol has already been set by now.
   * Later on, put the first path part into the host field.
   */
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') { srcPath[0] = result.host; } else { srcPath.unshift(result.host); }
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') { relPath[0] = relative.host; } else { relPath.unshift(relative.host); }
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = relative.host || relative.host === '' ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    /*
     * it's relative
     * throw away the existing file, and take the new path instead.
     */
    if (!srcPath) { srcPath = []; }
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (relative.search != null) {
    /*
     * just pull out the search.
     * like href='?foo'.
     * Put this after the other two cases because it simplifies the booleans
     */
    if (psychotic) {
      result.host = srcPath.shift();
      result.hostname = result.host;
      /*
       * occationaly the auth can get stuck only in host
       * this especially happens in cases like
       * url.resolveObject('mailto:local1@domain1', 'local2@domain2')
       */
      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.hostname = authInHost.shift();
        result.host = result.hostname;
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    // to support http.request
    if (result.pathname !== null || result.search !== null) {
      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    /*
     * no path at all.  easy.
     * we've already handled the other stuff above.
     */
    result.pathname = null;
    // to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  /*
   * if a url ENDs in . or .., then it must get a trailing slash.
   * however, if it ends in anything else non-slashy,
   * then it must NOT get a trailing slash.
   */
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';

  /*
   * strip single dots, resolve double dots to parent dir
   * if the path tries to go above the root, `up` ends up > 0
   */
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' || (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
    result.host = result.hostname;
    /*
     * occationaly the auth can get stuck only in host
     * this especially happens in cases like
     * url.resolveObject('mailto:local1@domain1', 'local2@domain2')
     */
    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.hostname = authInHost.shift();
      result.host = result.hostname;
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (srcPath.length > 0) {
    result.pathname = srcPath.join('/');
  } else {
    result.pathname = null;
    result.path = null;
  }

  // to support request.http
  if (result.pathname !== null || result.search !== null) {
    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function () {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) { this.hostname = host; }
};

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

},{"punycode":72,"qs":110}],115:[function(require,module,exports){
(function (global){(function (){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],116:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}]},{},[24]);
